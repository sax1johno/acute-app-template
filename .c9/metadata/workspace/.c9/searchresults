{"changed":true,"filter":false,"title":"Search Results","tooltip":"/.c9/searchresults","value":"Searching for \u0001path\u0001 in\u0001/\u0001 (Found 6653 matches in 490 files)\n\n/package.json:\n\t22:     \"path\": \"*\",\n\n/app/app.js:\n\t6:     path = require('path'),\n\t7:     configPath = path.join(__dirname, \"config.js\"),\n\t18: acute_utils.loadApp(configPath, function(err, arch) {\n\n/app/config.js:\n\t6:         packagePath: \"acute-express-app\",\n\t25:         packagePath: \"acute-express-data\",\n\t55:         packagePath: \"acute-express-controllers\",\n\n/app/index.js:\n\t6:     path = require('path'),\n\t8:     configPath = path.join(__dirname, \"config.js\");\n\t17:     acute_utils.loadApp(configPath, function(err, arch) {\n\n/app/controllers/index.js:\n\t39:            // base_path: \"/test\"\n\n/node_modules/acute-data-mongodb/package.json:\n\t28:     \"path\": \"*\"\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/HISTORY.md:\n\t23: - Optimized query path for performance, moving Object.defineProperty outside of constructors.\n\t949: * Cleanup of bson.js to remove duplicated code paths\n\t951: * Removing require.paths to make tests work with the 0.5.X branch\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/README.md:\n\t97: Let's boot up a MongoDB server instance. Download the right MongoDB version from [MongoDB](http://www.mongodb.org), open a new shell or command line and ensure the **mongod** command is in the shell or command line path. Now let's create a database directory (in our case under **/data**).\n\t100: mongod --dbpath=/data --port 27017\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/README.md:\n\t85: Let's boot up a MongoDB server instance. Download the right MongoDB version from [MongoDB](http://www.mongodb.org), open a new shell or command line and ensure the **mongod** command is in the shell or command line path. Now let's create a database directory (in our case under **/data**).\n\t88: mongod --dbpath=/data --port 27017\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/TESTING.md:\n\t6: mongod --dbpath=./db\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/lib/cursor.js:\n\t205:     // Otherwise fall back to regular find path\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/browser_build/bson.js:\n\t30: function normalize(path) {\n\t31:   var ret = [], parts = path.split('/'), cur, prev;\n\t52: function dirname(path) {\n\t53:   return path && path.substr(0, path.lastIndexOf(\"/\")) || \".\";\n\t2705:   , './long'].forEach(function (path) {\n\t2706:   \tvar module = require('./' + path);\n\t2728: ].forEach(function (path) {\n\t2729:     \tvar module = require('./' + path);\n\t2753:     , '././bson'].forEach(function (path) {\n\t2754:     \tvar module = require('./' + path);\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/build/bson.target.mk:\n\t118: # Copy this to the executable output path.\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/build/Makefile:\n\t11: abs_srcdir := $(abspath $(srcdir))\n\t28: # as they reach into the src/ directory for data with relative paths.\n\t30: abs_builddir := $(abspath $(builddir))\n\t35: abs_obj := $(abspath $(obj))\n\t79: # http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces\n\t93: # ccache or distcc lose the path to the target, so we convert a rule of\n\t97: #   path/to/foobar.o: DEP1 DEP2\n\t114: # Fixup path as in (1).\n\t171: # the local, absolute paths used on the link command-line.\n\t186: # $LD_LIBRARY_PATH), without triggering make substitution.\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/ext/wscript:\n\t3: from os.path import exists \n\t24:   # conf.check(lib='node', libpath=['/usr/lib', '/usr/local/lib'], uselib_store='NODE')\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/lib/bson/index.js:\n\t18:   , './long'].forEach(function (path) {\n\t19:   \tvar module = require('./' + path);\n\t41: ].forEach(function (path) {\n\t42:     \tvar module = require('./' + path);\n\t66:     , '././bson'].forEach(function (path) {\n\t67:     \tvar module = require('./' + path);\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/appveyor.yml:\n\t19:   - IF NOT %nodejs_version% == 1 set PATH=%APPDATA%\\npm;%PATH%\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/CHANGELOG.md:\n\t209:  - fix \"not all control paths return a value\" compile warning on some platforms\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/include_dirs.js:\n\t1: console.log(require('path').relative('.', __dirname));\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/build/kerberos.target.mk:\n\t133: # Copy this to the executable output path.\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/build/Makefile:\n\t11: abs_srcdir := $(abspath $(srcdir))\n\t28: # as they reach into the src/ directory for data with relative paths.\n\t30: abs_builddir := $(abspath $(builddir))\n\t35: abs_obj := $(abspath $(obj))\n\t79: # http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces\n\t93: # ccache or distcc lose the path to the target, so we convert a rule of\n\t97: #   path/to/foobar.o: DEP1 DEP2\n\t114: # Fixup path as in (1).\n\t171: # the local, absolute paths used on the link command-line.\n\t186: # $LD_LIBRARY_PATH), without triggering make substitution.\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/appveyor.yml:\n\t19:   - IF NOT %nodejs_version% == 1 set PATH=%APPDATA%\\npm;%PATH%\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/CHANGELOG.md:\n\t209:  - fix \"not all control paths return a value\" compile warning on some platforms\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/include_dirs.js:\n\t1: console.log(require('path').relative('.', __dirname));\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/index.js:\n\t1: var path = require('path');\n\t24:     p = path.resolve(p);\n\t33:                 mkdirP(path.dirname(p), opts, function (er, made) {\n\t67:     p = path.resolve(p);\n\t76:                 made = sync(path.dirname(p), opts, made);\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/readme.markdown:\n\t46: `opts.fs`. Your implementation should have `opts.fs.mkdir(path, mode, cb)` and\n\t47: `opts.fs.stat(path, cb)`.\n\t60: `opts.fs`. Your implementation should have `opts.fs.mkdirSync(path, mode)` and\n\t61: `opts.fs.statSync(path)`.\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/bin/cmd.js:\n\t16: var paths = argv._.slice();\n\t20:     if (paths.length === 0) return;\n\t21:     var p = paths.shift();\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/chmod.js:\n\t2: var path = require('path');\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/clobber.js:\n\t2: var path = require('path');\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/mkdirp.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/opts_fs.js:\n\t2: var path = require('path');\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/opts_fs_sync.js:\n\t2: var path = require('path');\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/perm.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/perm_sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/race.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/rel.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/return.js:\n\t2: var path = require('path');\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/return_sync.js:\n\t2: var path = require('path');\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/root.js:\n\t2: var path = require('path');\n\t8:     var file = path.resolve('/');\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/umask.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/umask_sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/bin.js:\n\t21:   log('Usage: rimraf <path>')\n\t23:   log('  Deletes all files and folders at \"path\" recursively.')\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/README.md:\n\t25: command `rimraf <path>` which is useful for cross platform support.\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/rimraf.js:\n\t4: var path = require(\"path\")\n\t131:       rimraf(path.join(p, f), function (er) {\n\t175:     rimrafSync(path.join(p, f))\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/test/test-async.js:\n\t2:   , path = require(\"path\")\n\t3: rimraf(path.join(__dirname, \"target\"), function (er) {\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/test/test-sync.js:\n\t2:   , path = require(\"path\")\n\t3: rimraf.sync(path.join(__dirname, \"target\"))\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/readable-stream/lib/_stream_transform.js:\n\t51: // a pathological inflate type of transform can cause excessive buffering\n\t57: // such a pathological inflating mechanism, there'd be no way to tell\n\t61: // However, even in such a pathological case, only a single written chunk\n\n/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/readable-stream/node_modules/isarray/build/build.js:\n\t3:  * Require the given path.\n\t5:  * @param {String} path\n\t10: function require(path, parent, orig) {\n\t11:   var resolved = require.resolve(path);\n\t15:     orig = orig || path;\n\t18:     err.path = orig;\n\t51:  * Resolve `path`.\n\t55:  *   - PATH/index.js\n\t56:  *   - PATH.js\n\t57:  *   - PATH\n\t59:  * @param {String} path\n\t60:  * @return {String} path or null\n\t64: require.resolve = function(path) {\n\t65:   if (path.charAt(0) === '/') path = path.slice(1);\n\t66:   var index = path + '/index.js';\n\t68:   var paths = [\n\t69:     path,\n\t70:     path + '.js',\n\t71:     path + '.json',\n\t72:     path + '/index.js',\n\t73:     path + '/index.json'\n\t76:   for (var i = 0; i < paths.length; i++) {\n\t77:     var path = paths[i];\n\t78:     if (require.modules.hasOwnProperty(path)) return path;\n\t87:  * Normalize `path` relative to the current path.\n\t90:  * @param {String} path\n\t95: require.normalize = function(curr, path) {\n\t98:   if ('.' != path.charAt(0)) return path;\n\t101:   path = path.split('/');\n\t103:   for (var i = 0; i < path.length; ++i) {\n\t104:     if ('..' == path[i]) {\n\t106:     } else if ('.' != path[i] && '' != path[i]) {\n\t107:       segs.push(path[i]);\n\t115:  * Register module at `path` with callback `definition`.\n\t117:  * @param {String} path\n\t122: require.register = function(path, definition) {\n\t123:   require.modules[path] = definition;\n\t142:  * Return a require function relative to the `parent` path.\n\t168:   function localRequire(path) {\n\t169:     var resolved = localRequire.resolve(path);\n\t170:     return require(resolved, parent, path);\n\t177:   localRequire.resolve = function(path) {\n\t178:     var c = path.charAt(0);\n\t179:     if ('/' == c) return path.slice(1);\n\t180:     if ('.' == c) return require.normalize(p, path);\n\t188:     path = segs.slice(0, i + 1).join('/') + '/deps/' + path;\n\t189:     return path;\n\t193:    * Check if module is defined at `path`.\n\t196:   localRequire.exists = function(path) {\n\t197:     return require.modules.hasOwnProperty(localRequire.resolve(path));\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/History.md:\n\t5:  * added; dynamic refpaths #2640 [chetvernikov](https://github.com/chetvernikov)\n\t14:  * fixed; array saved as object when path is object in array #2442\n\t33:  * added; can explicitly exclude paths from versioning #2576 [csabapalfi](https://github.com/csabapalfi)\n\t107:  * added; ability to set single populated paths to documents #1530\n\t136:  * fixed; properly remove modified array paths if array has been overwritten #1638\n\t190:  * fixed; custom getter might cause mongoose to mistakenly think a path is dirty #2100 [pgherveou](https://github.com/pgherveou)\n\t235:  * updated; added get / set to reserved path list #1903 [tstrimple](https://github.com/tstrimple)\n\t337:  * fixed; repopulating modified populated paths #1697\n\t414:  * fixed; repopulating modified populated paths #1697\n\t535:  * fixed; repopulating modified populated paths #1697\n\t677:   * fixed; strict:throw edge case using .set(path, val)\n\t678:   * fixed; schema.pathType() on some numbericAlpha paths\n\t679:   * fixed; numbericAlpha path versioning\n\t680:   * fixed; setting nested mixed paths #1418\n\t725:   * fixed; use of `setMaxListeners` as path\n\t757:   * added; doc#populated(path) stores original populated _ids\n\t762:   * added; support for rich nested path population\n\t775:   * fixed; setting populated paths #570\n\t787:   * fixed; add EventEmitter props to reserved paths #1338\n\t791:   * fixed; specifying schema type edge case { path: [{type: \"String\" }] }\n\t797:   * updated; mpath to 0.1.1\n\t840:   * fixed; setting populated paths #570\n\t852:   * fixed; add EventEmitter props to reserved paths #1338\n\t871:   * fixed; specifying schema type edge case { path: [{type: \"String\" }] }\n\t877:   * added; doc#populated(path) stores original populated _ids\n\t882:   * added; support for rich nested path population\n\t890:   * updated; mpath to 0.1.1\n\t979:   * fixed; add EventEmitter props to reserved paths #1338\n\t1009:   * changed; \"_pres\" & \"_posts\" are now reserved pathnames #1261\n\t1031:   * fixed; regression when using subdoc with `path` as pathname #1245 [daeq](https://github.com/daeq)\n\t1042:   * added; paths to CastErrors #1239\n\t1083:   * changed; adding invalid nested paths to non-objects throws 4216f14\n\t1188:   * fixed; use of nested paths beginning w/ numbers #1062\n\t1202:   * fixed; compat with non-schema path props using positional notation (#1048)\n\t1227:   * fixed; allow subdoc literal declarations containing \"type\" pathname (#993)\n\t1230:   * fixed; allow use of `options` as a pathname (#529)\n\t1231:   * fixed; `model` is again a permitted schema path name\n\t1250:   * fixed; provide helpful error msgs when reserved schema path is used (#928)\n\t1276:   * changed; doc#modifiedPaths is now a method (#950)\n\t1292:   * fixed; setting invalid paths in strict mode (#916)\n\t1299:   * fixed; subdoc paths reported in validation errors (#725)\n\t1306:   * fixed; set/updating nested objects by parent pathname (#843)\n\t1318:   * added; inclusion of deselected schema path (#786)\n\t1372:   * fixed; edge case when using 'options' as a path name (#961)\n\t1378:   * fixed; selection of _id w/ another excluded path (#954)\n\t1393:   * fixed; setting invalid paths in strict mode (#916)\n\t1435:   * fixed; doc.isSelected(otherpath) when only _id is selected (#730)\n\t1441:   * fixed; failing validation of unselected required paths (#730,#713)\n\t1469:   * added; default path selection to SchemaTypes\n\t1508:   * added; doc#isSelected(path)\n\t1512:   * added; document.modifiedPaths (#709) [ljharb]\n\t1566:   * fixed; bug in 2.4.6 with path setting\n\t1611:   * added; $unset is now used when setting a path to undefined (#519)\n\t1638:   * fixed; model.update casting for nested paths works (#542)\n\t1782:   * fixed; reset modified paths and atomics after saved (#459)\n\t1934:   * fixed; 'path' is now a valid Schema pathname\n\t1938:   * fixed; modifying subdoc property sets modified paths for subdoc and parent doc\n\t1939:   * fixed; marking subdoc path as modified properly persists the value to the db\n\t2041:   * Fixed; no longer using $set on paths to an unexisting fields\n\t2112:   * Only doValidate when path exists in Schema [aheckmann]\n\t2226:   * Fixed; it's now possible to instantiate a model even when one of the paths maps\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/package.json:\n\t31:     \"mpath\": \"0.1.1\",\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/README.md:\n\t104: Comment.path('name').set(function (v) {\n\t219: For example, this would allow you to broadcast changes about your Documents every time someone `set`s a path in your Document to a new value:\n\t222: schema.pre('set', function (next, path, val, typel) {\n\t224:   this.emit('set', path, val);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/examples/population/population-across-three-collections.js:\n\t113:           path: 'author.friends',\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/examples/population/population-of-multiple-existing-docs.js:\n\t88:     var options = { path: 'consoles', select: 'name released -_id' };\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/examples/population/population-options.js:\n\t93:       path: 'consoles'\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/examples/schema/schema.js:\n\t46: BlogPost.path('date')\n\t88:     schema.path(key).set(function(v){\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/aggregate.js:\n\t280:  * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/browserDocument.js:\n\t30:  * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n\t80:   var required = this.schema.requiredPaths();\n\t82:     this.$__.activePaths.require(required[i]);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/cast.js:\n\t18:   var paths = Object.keys(obj)\n\t19:     , i = paths.length\n\t23:     , path\n\t28:     path = paths[i];\n\t29:     val = obj[path];\n\t31:     if ('$or' === path || '$nor' === path || '$and' === path) {\n\t39:     } else if (path === '$where') {\n\t47:         obj[path] = val.toString();\n\t59:       schematype = schema.path(path);\n\t63:         var split = path.split('.')\n\t65:           , pathFirstHalf\n\t66:           , pathLastHalf\n\t70:         // Find the part of the var path that is a path of the Schema\n\t72:           pathFirstHalf = split.slice(0, j).join('.');\n\t73:           schematype = schema.path(pathFirstHalf);\n\t77:         // If a substring of the input path resolves to an actual real path...\n\t82:             pathLastHalf = split.slice(j).join('.');\n\t83:             remainingConds[pathLastHalf] = val;\n\t84:             obj[path] = cast(schematype.caster.schema, remainingConds)[pathLastHalf];\n\t86:             obj[path] = val;\n\t169:           obj[path] = schematype.castForQuery(val);\n\t202:         obj[path] = schematype.castForQuery(val);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/connection.js:\n\t8:   , driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native'\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/document.js:\n\t29:  * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n\t53:   var required = schema.requiredPaths();\n\t55:     this.$__.activePaths.require(required[i]);\n\t171:   var paths = Object.keys(this.schema.paths)\n\t172:     , plen = paths.length\n\t176:     var p = paths[ii];\n\t183:     var type = this.schema.paths[p]\n\t184:       , path = p.split('.')\n\t185:       , len = path.length\n\t187:       , curPath = ''\n\t192:       var piece = path[i]\n\t197:         curPath += piece;\n\t198:         if (curPath in fields) break;\n\t199:         curPath += '.';\n\t211:               self.$__.activePaths.default(p);\n\t219:               self.$__.activePaths.default(p);\n\t226:             self.$__.activePaths.default(p);\n\t259:   // handle docs with populated paths\n\t265:       this.populated(item.path, item._docs[id], item);\n\t292:     , path\n\t297:     path = prefix + i;\n\t298:     schema = self.schema.path(path);\n\t304:       init(self, obj[i], doc[i], path + '.');\n\t313:             self.invalidate(e.path, new ValidatorError({\n\t314:               path: e.path,\n\t325:       if (!self.isModified(path)) {\n\t326:         self.$__.activePaths.init(path);\n\t350:     , paths = Object.keys(key)\n\t351:     , len = paths.length\n\t355:     val = this.getValue(paths[i]);\n\t357:       orig[paths[i]] = val.toObject({ depopulate: true })\n\t362:       orig[paths[i]] = val.valueOf();\n\t364:       orig[paths[i]] = val;\n\t403:  * Sets the value of a path, or many paths.\n\t407:  *     // path, value\n\t408:  *     doc.set(path, value)\n\t412:  *         path  : value\n\t413:  *       , path2 : {\n\t414:  *            path  : value\n\t419:  *     doc.set(path, value, Number)\n\t422:  *     doc.set(path, value, String)\n\t425:  *     doc.set(path, value, { strict: false });\n\t427:  * @param {String|Object} path path or object of key/vals to set\n\t434: Document.prototype.set = function (path, val, type, options) {\n\t450:     adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n\t451:     adhocs[path] = Schema.interpretAsType(path, type);\n\t454:   if ('string' !== typeof path) {\n\t457:     if (null === path || undefined === path) {\n\t458:       var _ = path;\n\t459:       path = val;\n\t467:       if (path instanceof Document) path = path._doc;\n\t469:       var keys = Object.keys(path)\n\t471:         , pathtype\n\t476:         pathtype = this.schema.pathType(prefix + key);\n\t477:         if (null != path[key]\n\t479:             && utils.isObject(path[key])\n\t480:             && (!path[key].constructor || 'Object' == utils.getFunctionName(path[key].constructor))\n\t481:             && 'virtual' != pathtype\n\t482:             && !(this.$__path(prefix + key) instanceof MixedSchema)\n\t483:             && !(this.schema.paths[key] && this.schema.paths[key].options.ref)\n\t485:           this.set(path[key], prefix + key, constructing);\n\t487:           if ('real' === pathtype || 'virtual' === pathtype) {\n\t488:             this.set(prefix + key, path[key], constructing);\n\t492:         } else if (undefined !== path[key]) {\n\t493:           this.set(prefix + key, path[key], constructing);\n\t502:   // docschema = new Schema({ path: { nest: 'string' }})\n\t503:   // doc.set('path', obj);\n\t504:   var pathType = this.schema.pathType(path);\n\t505:   if ('nested' == pathType && val && utils.isObject(val) &&\n\t507:     if (!merge) this.setValue(path, null);\n\t508:     this.set(val, path, constructing);\n\t513:   var parts = path.split('.');\n\t515:   if ('adhocOrUndefined' == pathType && strict) {\n\t521:       var subpath = parts.slice(0, i+1).join('.');\n\t522:       schema = this.schema.path(subpath);\n\t524:         // allow changes to sub paths of mixed types\n\t532:         throw new Error(\"Field `\" + path + \"` is not in schema.\");\n\t537:   } else if ('virtual' == pathType) {\n\t538:     schema = this.schema.virtualpath(path);\n\t542:     schema = this.$__path(path);\n\t545:   var pathToMark;\n\t547:   // When using the $set operator the path to the field must already exist.\n\t551:     pathToMark = path;\n\t554:       var subpath = parts.slice(0, i+1).join('.');\n\t555:       if (this.isDirectModified(subpath) // earlier prefixes that are already\n\t557:           || this.get(subpath) === null) {\n\t558:         pathToMark = subpath;\n\t563:     if (!pathToMark) pathToMark = path;\n\t569:     : this.getValue(path);\n\t572:     this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n\t579:     // If the user is trying to set a ref path to a document with\n\t585:       this.populated(path, val);\n\t589:     this.invalidate(e.path, new ValidatorError({\n\t590:       path: e.path,\n\t599:     this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n\t615:     pathToMark, path, constructing, parts, schema, val, priorVal) {\n\t619:   if (undefined === val && !this.isSelected(path)) {\n\t620:     // when a path is not selected in a query, its initial\n\t625:   if (undefined === val && path in this.$__.activePaths.states.default) {\n\t630:   if (!deepEqual(val, priorVal || this.get(path))) {\n\t636:       path in this.$__.activePaths.states.default &&\n\t638:     // a path with a default was $unset on the server\n\t646:  * Handles the actual setting of the value and marking the path modified if appropriate.\n\t654:     pathToMark, path, constructing, parts, schema, val, priorVal) {\n\t661:     this.markModified(pathToMark, val);\n\t669:       // paths that were modified before the array overwrite\n\t670:       this.$__.activePaths.forEach(function(modifiedPath) {\n\t671:         if (modifiedPath.indexOf(path + '.') === 0) {\n\t672:           _this.$__.activePaths.ignore(modifiedPath);\n\t703:  * Gets a raw value from a path (no getters)\n\t705:  * @param {String} path\n\t709: Document.prototype.getValue = function (path) {\n\t710:   return utils.getValue(path, this._doc);\n\t714:  * Sets a raw value for a path (no casting, setters, transformations)\n\t716:  * @param {String} path\n\t721: Document.prototype.setValue = function (path, val) {\n\t722:   utils.setValue(path, val, this._doc);\n\t727:  * Returns the value of a path.\n\t731:  *     // path\n\t737:  * @param {String} path\n\t742: Document.prototype.get = function (path, type) {\n\t745:     adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n\t746:     adhocs[path] = Schema.interpretAsType(path, type);\n\t749:   var schema = this.$__path(path) || this.schema.virtualpath(path)\n\t750:     , pieces = path.split('.')\n\t767:  * Returns the schematype for the given `path`.\n\t769:  * @param {String} path\n\t771:  * @method $__path\n\t775: Document.prototype.$__path = function (path) {\n\t776:   var adhocs = this.$__.adhocPaths\n\t777:     , adhocType = adhocs && adhocs[path];\n\t782:     return this.schema.path(path);\n\t787:  * Marks the path as having pending changes to write to the db.\n\t797:  * @param {String} path the path to mark modified\n\t801: Document.prototype.markModified = function (path) {\n\t802:   this.$__.activePaths.modify(path);\n\t806:  * Returns the list of paths that have been modified.\n\t812: Document.prototype.modifiedPaths = function () {\n\t813:   var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n\t815:   return directModifiedPaths.reduce(function (list, path) {\n\t816:     var parts = path.split('.');\n\t826:  * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n\t836:  * @param {String} [path] optional\n\t841: Document.prototype.isModified = function (path) {\n\t842:   return path\n\t843:     ? !!~this.modifiedPaths().indexOf(path)\n\t844:     : this.$__.activePaths.some('modify');\n\t848:  * Returns true if `path` was directly set and modified, else false.\n\t856:  * @param {String} path\n\t861: Document.prototype.isDirectModified = function (path) {\n\t862:   return (path in this.$__.activePaths.states.modify);\n\t866:  * Checks if `path` was initialized.\n\t868:  * @param {String} path\n\t873: Document.prototype.isInit = function (path) {\n\t874:   return (path in this.$__.activePaths.states.init);\n\t878:  * Checks if `path` was selected in the source query which initialized this document.\n\t887:  * @param {String} path\n\t892: Document.prototype.isSelected = function isSelected (path) {\n\t895:     if ('_id' === path) {\n\t899:     var paths = Object.keys(this.$__.selected)\n\t900:       , i = paths.length\n\t904:     if (1 === i && '_id' === paths[0]) {\n\t910:       cur = paths[i];\n\t916:     if (path in this.$__.selected) {\n\t920:     i = paths.length;\n\t921:     var pathDot = path + '.';\n\t924:       cur = paths[i];\n\t927:       if (0 === cur.indexOf(pathDot)) {\n\t931:       if (0 === pathDot.indexOf(cur + '.')) {\n\t972:   var paths = Object.keys(this.$__.activePaths.states.require).filter(function (path) {\n\t973:     if (!self.isSelected(path) && !self.isModified(path)) return false;\n\t977:   paths = paths.concat(Object.keys(this.$__.activePaths.states.init));\n\t978:   paths = paths.concat(Object.keys(this.$__.activePaths.states.modify));\n\t979:   paths = paths.concat(Object.keys(this.$__.activePaths.states.default));\n\t981:   if (0 === paths.length) {\n\t993:   for (var i = 0; i < paths.length; ++i) {\n\t994:     var path = paths[i];\n\t995:     var val = self.getValue(path);\n\t1000:         paths.push(path + '.' + j);\n\t1004:   paths.forEach(validatePath);\n\t1007:   function validatePath (path) {\n\t1008:     if (validating[path]) return;\n\t1010:     validating[path] = true;\n\t1014:       var p = self.schema.path(path);\n\t1017:       var val = self.getValue(path);\n\t1020:           self.invalidate(path, err, undefined, true);\n\t1063:   var paths = Object.keys(this.$__.activePaths.states.require).filter(function (path) {\n\t1064:     if (!self.isSelected(path) && !self.isModified(path)) return false;\n\t1068:   paths = paths.concat(Object.keys(this.$__.activePaths.states.init));\n\t1069:   paths = paths.concat(Object.keys(this.$__.activePaths.states.modify));\n\t1070:   paths = paths.concat(Object.keys(this.$__.activePaths.states.default));\n\t1074:   paths.forEach(function (path) {\n\t1075:     if (validating[path]) return;\n\t1077:     validating[path] = true;\n\t1079:     var p = self.schema.path(path);\n\t1082:     var val = self.getValue(path);\n\t1085:       self.invalidate(path, err, undefined, true);\n\t1097:  * Marks a path as invalid, causing validation to fail.\n\t1114:  *               path: 'size',\n\t1119:  * @param {String} path the field to invalidate\n\t1120:  * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n\t1125: Document.prototype.invalidate = function (path, err, val) {\n\t1130:   if (this.$__.validationError.errors[path]) return;\n\t1134:       path: path,\n\t1143:   this.$__.validationError.errors[path] = err;\n\t1159:   this.$__.activePaths\n\t1184:   this.$__.activePaths.clear('modify');\n\t1188:   this.schema.requiredPaths().forEach(function (path) {\n\t1189:     self.$__.activePaths.require(path);\n\t1196:  * Returns this documents dirty paths / vals.\n\t1206:   var all = this.$__.activePaths.map('modify', function (path) {\n\t1207:     return { path: path\n\t1208:            , value: self.getValue(path)\n\t1209:            , schema: self.$__path(path) };\n\t1212:   // Sort dirty paths in a flat hierarchy.\n\t1214:     return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n\t1219:     , lastPath\n\t1223:     if (item.path.indexOf(lastPath) !== 0) {\n\t1224:       lastPath = item.path + '.';\n\t1230:         // the `top` array itself and a sub path of `top` are being modified.\n\t1239:   top = lastPath = null;\n\t1288:     , path = (prefix ? prefix + '.' : '') + prop;\n\t1299:           if (!this.$__.getters[path]) {\n\t1321:               return this.get(path);\n\t1324:             compile(subprops, nested, path);\n\t1325:             this.$__.getters[path] = nested;\n\t1328:           return this.$__.getters[path];\n\t1332:           return (this.$__.scope || this).set(path, v);\n\t1340:       , get: function ( ) { return this.get.call(this.$__.scope || this, path); }\n\t1341:       , set: function (v) { return this.set.call(this.$__.scope || this, path, v); }\n\t1362:  * Get active path that were changed and are arrays\n\t1365:  * @method $__getArrayPathsToValidate\n\t1369: Document.prototype.$__getArrayPathsToValidate = function () {\n\t1373:   return this.$__.activePaths\n\t1398:   function docReducer(seed, path) {\n\t1399:     var val = this[path];\n\t1429:   var docs = this.$__getArrayPathsToValidate();\n\t1549:  * - `getters` apply all getters (path and virtual getters)\n\t1553:  * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)\n\t1557:  * Example of only applying path getters\n\t1565:  * Example of applying both path and virtual getters\n\t1667:     // populated paths that we set to a document\n\t1703:     applyGetters(this, ret, 'paths', options);\n\t1704:     // applyGetters for paths will add nested empty objects;\n\t1778:  * @param {String} type either `virtuals` or `paths`\n\t1784:     , paths = Object.keys(schema[type])\n\t1785:     , i = paths.length\n\t1786:     , path\n\t1789:     path = paths[i];\n\t1791:     var parts = path.split('.')\n\t1800:         branch[part] = clone(self.get(path), options);\n\t1897:  *       path: 'notes',\n\t1907:  *     doc.populate(path)               // not executed\n\t1909:  *     doc.populate(path, callback)     // executed\n\t1918:  * Passing the same path a second time will overwrite the previous path options.\n\t1922:  * @param {String|Object} [path] The path to populate or an options object\n\t1941:     // use hash to remove duplicate paths\n\t1944:       pop[res[i].path] = res[i];\n\t1949:     var paths = utils.object.vals(pop);\n\t1951:     this.constructor.populate(this, paths, fn);\n\t1966:  *         path: 'notes',\n\t1981:  * Passing the same path a second time will overwrite the previous path options.\n\t2003:  * Gets _id(s) used during population of the given `path`.\n\t2012:  * If the path was not populated, undefined is returned.\n\t2014:  * @param {String} path\n\t2019: Document.prototype.populated = function (path, val, options) {\n\t2024:     var v = this.$__.populated[path];\n\t2033:     return this.$__.populated[path];\n\t2037:   this.$__.populated[path] = { value: val, options: options };\n\t2042:  * Returns the full path to this document.\n\t2044:  * @param {String} [path]\n\t2047:  * @method $__fullPath\n\t2051: Document.prototype.$__fullPath = function (path) {\n\t2053:   return path || '';\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/index.js:\n\t480: var driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/internal.js:\n\t16:   this.adhocPaths = undefined;\n\t26:   this.activePaths = new ActiveRoster;\n\t30:   this.fullPath = undefined;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/model.js:\n\t298:   delta[op][data.path] = val;\n\t303:   // path excluded from versioning?\n\t305:   if (skipVersioning && skipVersioning[data.path]) return;\n\t342:   else if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n\t343:     // subpath of array\n\t359:   if (delta.$set && delta.$set[data.path]) {\n\t441:     var match = checkDivergentArray(this, data.path, value);\n\t455:     } else if (value._path && value._atomics) {\n\t459:     } else if (value._path && Buffer.isBuffer(value)) {\n\t487:  * @param {String} path\n\t491: function checkDivergentArray (doc, path, array) {\n\t492:   // see if we populated this path\n\t493:   var pop = doc.populated(path, true);\n\t498:     var top = path.split('.')[0];\n\t526:       return path;\n\t601:   var paths\n\t605:     paths = Object.keys(this.$__.shardval)\n\t606:     len = paths.length\n\t609:       where[paths[i]] = this.$__.shardval[paths[i]];\n\t731:   if (schema.path(key)) {\n\t772:     schema._requiredpaths = undefined; // reset just in case Schema#requiredPaths() was called on either schema\n\t1225:  * @param {String} path\n\t1231: Model.where = function where (path, val) {\n\t1641:  * The document returned has no paths marked as modified initially.\n\t2094:  * - path: space delimited path(s) to populate\n\t2105:  *           { path: 'company', match: { x: 1 }, select: 'name' }\n\t2106:  *         , { path: 'notes', options: { limit: 10 }, model: 'override' }\n\t2116:  *       var opts = [{ path: 'company', match: { x: 1 }, select: 'name' }]\n\t2127:  *     Weapon.populate(user, { path: 'weapon', model: 'Weapon' }, function (err, user) {\n\t2134:  *     Weapon.populate(users, { path: 'weapon' }, function (err, users) {\n\t2145:  * @param {Object} options A hash of key/val (path, options) used for population.\n\t2151: Model.populate = function (docs, paths, cb) {\n\t2162:   // normalized paths\n\t2163:   var paths = utils.populate(paths);\n\t2164:   var pending = paths.length;\n\t2171:   // each path has its own query options and must be executed separately\n\t2173:   var path;\n\t2176:     path = paths[i];\n\t2177:     if ('function' === typeof path.model) model = path.model;\n\t2178:     populate(model, docs, path, next);\n\t2197:   var schema = model._getSchema(options.path),\n\t2244:       path: options.path,\n\t2310:     refPath = schema && schema.options && schema.options.refPath,\n\t2313:   if (refPath) {\n\t2316:       modelNames = utils.getValue(refPath, doc);\n\t2374:     i, j, doc, docs, id, len, len2, ret, isDocument, populated, options, path;\n\t2381:     path = options.path;\n\t2390:         ret = utils.getValue(path, doc);\n\t2404:         doc.populated(path, options._docs[id], options);\n\t2436:  * to the original document path.\n\t2449:   var path = o.path;\n\t2454:     utils.setValue(path, rawIds[i], docs[i], function (val) {\n\t2563:  *   if the value of the path is not an array, use findOne rules, else find.\n\t2564:  *   for findOne the results are assigned directly to doc path (including null results).\n\t2637:  * Finds the schema for `path`. This is different than\n\t2638:  * calling `schema.path` as it also resolves paths with\n\t2639:  * positional selectors (something.$.another.$.path).\n\t2641:  * @param {String} path\n\t2646: Model._getSchema = function _getSchema (path) {\n\t2648:     , pathschema = schema.path(path);\n\t2650:   if (pathschema)\n\t2651:     return pathschema;\n\t2657:       , trypath\n\t2660:       trypath = parts.slice(0, p).join('.');\n\t2661:       foundschema = schema.path(trypath);\n\t2671:           // are remaining document paths to look up for casting.\n\t2672:           // Also we need to handle array.$.path since schema.path\n\t2675:           // a path like array.$\n\t2681:               // this is the last path of the selector\n\t2689:   })(path.split('.'), schema)\n\t2705:   if (versioningEnabled && !schema.paths[schema.options.versionKey]) {\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/query.js:\n\t161:   p._path = this._path;\n\t199:  * Specifies a `path` for use with chaining.\n\t221:  * @param {String|Object} [path]\n\t228:  * Specifies the complementary comparison value for paths specified with `where()`\n\t293:  * When called with one argument, the most recent path passed to `where()` is used.\n\t304:  * @param {String} [path]\n\t313:  * When called with one argument, the most recent path passed to `where()` is used.\n\t317:  * @param {String} [path]\n\t326:  * When called with one argument, the most recent path passed to `where()` is used.\n\t330:  * @param {String} [path]\n\t339:  * When called with one argument, the most recent path passed to `where()` is used.\n\t344:  * @param {String} [path]\n\t352:  * When called with one argument, the most recent path passed to `where()` is used.\n\t357:  * @param {String} [path]\n\t365:  * When called with one argument, the most recent path passed to `where()` is used.\n\t370:  * @param {String} [path]\n\t378:  * When called with one argument, the most recent path passed to `where()` is used.\n\t383:  * @param {String} [path]\n\t391:  * When called with one argument, the most recent path passed to `where()` is used.\n\t396:  * @param {String} [path]\n\t404:  * When called with one argument, the most recent path passed to `where()` is used.\n\t418:  * @param {String} [path]\n\t426:  * When called with one argument, the most recent path passed to `where()` is used.\n\t431:  * @param {String} [path]\n\t439:  * When called with one argument, the most recent path passed to `where()` is used.\n\t444:  * @param {String} [path]\n\t454:  * @param {String} [path]\n\t477:  * @param {String} [path]\n\t505:  * @param {String|Object|Function} path\n\t517:  *     query.where(path).within().box()\n\t518:  *     query.where(path).within().circle()\n\t519:  *     query.where(path).within().geometry()\n\t563:  * @param {String} [path]\n\t702:  * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](/docs/api.html#schematype_SchemaType-select).\n\t718:  *     query.select('+path')\n\t886:  * Makes sure _path is set.\n\t888:  * @method _ensurePath\n\t1017:   this._applyPaths();\n\t1066:  * @param {Array} [pop] array of paths used in population\n\t1176:   this._applyPaths();\n\t1340:  * If a string is passed, it must be a space delimited list of path names. The\n\t1341:  * sort order of each path is ascending unless the path name is prefixed with `-`\n\t1447:  * @param {Array} [pop] array of paths used in population\n\t1623:   this._applyPaths();\n\t1720:  * _All paths passed that are not $atomic operations will become $set ops._\n\t1935:  * Finds the schema for `path`. This is different than\n\t1936:  * calling `schema.path` as it also resolves paths with\n\t1937:  * positional selectors (something.$.another.$.path).\n\t1939:  * @param {String} path\n\t1943: Query.prototype._getSchema = function _getSchema (path) {\n\t1944:   return this.model._getSchema(path);\n\t1961:  * of their path schema type.\n\t2024:       hasKeys |= this._walkUpdatePath(val, op);\n\t2030:       // Also, _walkUpdatePath expects an operation, so give it $set since that\n\t2032:       this._walkUpdatePath(ret.$set || {}, '$set');\n\t2044:  * Walk each path of obj and cast its values\n\t2049:  * @param {String} pref - path prefix (internal only)\n\t2050:  * @return {Bool} true if this path has keys to update\n\t2054: Query.prototype._walkUpdatePath = function _walkUpdatePath (obj, op, pref) {\n\t2078:           // path is not in our strict schema\n\t2082:             // ignore paths not specified in schema\n\t2115:         hasKeys |= this._walkUpdatePath(val, op, prefix + key) ||\n\t2125:                  !/real|nested/.test(this.model.schema.pathType(prefix + key));\n\t2154:     // non-existing schema path\n\t2216:  * Specifies paths which should be populated with other documents.\n\t2225:  *         path: 'owner'\n\t2238:  * Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.\n\t2240:  * @param {Object|String} path either the path to populate or an object specifying all parameters\n\t2261:     opts.populate[res[i].path] = res[i];\n\t2345: Query.prototype._applyPaths = function applyPaths () {\n\t2371:   var analyzePath = function(path, type) {\n\t2374:     var plusPath = '+' + path;\n\t2375:     if (fields && plusPath in fields) {\n\t2377:       delete fields[plusPath];\n\t2381:       if (false === exclude && keys.length > 1 && !~keys.indexOf(path)) {\n\t2382:         fields[path] = 1;\n\t2389:     var root = path.split('.')[0];\n\t2392:     ;(type.selected ? selected : excluded).push(path);\n\t2402:     schema.eachPath(function (path, type) {\n\t2403:       if (prefix) path = prefix + '.' + path;\n\t2405:       analyzePath(path, type);\n\t2409:         analyzeSchema(type.schema, path);\n\t2470:   this._applyPaths();\n\t2527:  *     query.where('path').intersects().geometry({\n\t2532:  *     query.where('path').intersects({\n\t2573:  * The argument is assigned to the most recent path passed to `where()`.\n\t2607:  * @param {String} [path]\n\t2637:       // just passing a path\n\t2713:  * @param {String|Array} [path]\n\t2777:  * @param {String} [path]\n\t2811:  * @param {String} [path]\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/queryhelpers.js:\n\t9:  * Prepare a set of path options for query population.\n\t26:  * Prepare a set of path options for query population. This is the MongooseQuery\n\t70:  * Set each path query option to lean\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema.js:\n\t63:   this.paths = {};\n\t64:   this.subpaths = {};\n\t73:   this._requiredpaths = undefined;\n\t75:   this._indexedpaths = undefined;\n\t84:   // build paths\n\t93:   var auto_id = !this.paths['_id'] && (!this.options.noId && this.options._id) && !_idSubDoc;\n\t100:   var autoid = !this.paths['id'] && (!this.options.noVirtualId && this.options.id);\n\t114:     if (!this.paths[createdAt]) {\n\t160:  * Schema as flat paths\n\t169:  * @property paths\n\t172: Schema.prototype.paths;\n\t236:  * Adds key path / schema type pairs to this schema.\n\t256:       throw new TypeError('Invalid value for schema path `'+ prefix + key +'`');\n\t260:       throw new TypeError('Invalid value for schema Array path `'+ prefix + key +'`');\n\t269:         this.path(prefix + key, obj[key]); // mixed type\n\t272:       this.path(prefix + key, obj[key]);\n\t310:  * Gets/sets schema paths.\n\t312:  * Sets a path (if arity 2)\n\t313:  * Gets a path (if arity 1)\n\t317:  *     schema.path('name') // returns a SchemaType\n\t318:  *     schema.path('name', Number) // changes the schemaType of `name` to Number\n\t320:  * @param {String} path\n\t325: Schema.prototype.path = function (path, obj) {\n\t327:     if (this.paths[path]) return this.paths[path];\n\t328:     if (this.subpaths[path]) return this.subpaths[path];\n\t330:     // subpaths?\n\t331:     return /\\.\\d+\\.?.*$/.test(path)\n\t332:       ? getPositionalPath(this, path)\n\t336:   // some path names conflict with document methods\n\t337:   if (reserved[path]) {\n\t338:     throw new Error(\"`\" + path + \"` may not be used as a schema pathname\");\n\t342:   var subpaths = path.split(/\\./)\n\t343:     , last = subpaths.pop()\n\t346:   subpaths.forEach(function(sub, i) {\n\t349:       var msg = 'Cannot set nested path `' + path + '`. '\n\t350:               + 'Parent path `'\n\t351:               + subpaths.slice(0, i).concat([sub]).join('.')\n\t361:   this.paths[path] = Schema.interpretAsType(path, obj);\n\t368:  * @param {String} path\n\t373: Schema.interpretAsType = function (path, obj) {\n\t389:     return new MongooseTypes.Mixed(path, obj);\n\t399:       return new MongooseTypes.DocumentArray(path, cast, obj);\n\t407:       return new MongooseTypes.DocumentArray(path, new Schema(cast), obj);\n\t410:     return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj);\n\t429:     throw new TypeError('Undefined type `' + name + '` at `' + path +\n\t434:   return new MongooseTypes[name](path, obj);\n\t438:  * Iterates the schemas paths similar to Array#forEach.\n\t440:  * The callback is passed the pathname and schemaType as arguments on each iteration.\n\t447: Schema.prototype.eachPath = function (fn) {\n\t448:   var keys = Object.keys(this.paths)\n\t452:     fn(keys[i], this.paths[keys[i]]);\n\t459:  * Returns an Array of path strings that are required by this schema.\n\t465: Schema.prototype.requiredPaths = function requiredPaths () {\n\t466:   if (this._requiredpaths) return this._requiredpaths;\n\t468:   var paths = Object.keys(this.paths)\n\t469:     , i = paths.length\n\t473:     var path = paths[i];\n\t474:     if (this.paths[path].isRequired) ret.push(path);\n\t477:   return this._requiredpaths = ret;\n\t487: Schema.prototype.indexedPaths = function indexedPaths () {\n\t488:   if (this._indexedpaths) return this._indexedpaths;\n\t490:   return this._indexedpaths = this.indexes();\n\t494:  * Returns the pathType of `path` for this schema.\n\t496:  * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n\t498:  * @param {String} path\n\t503: Schema.prototype.pathType = function (path) {\n\t504:   if (path in this.paths) return 'real';\n\t505:   if (path in this.virtuals) return 'virtual';\n\t506:   if (path in this.nested) return 'nested';\n\t507:   if (path in this.subpaths) return 'real';\n\t509:   if (/\\.\\d+\\.|\\.\\d+$/.test(path) && getPositionalPath(this, path)) {\n\t520: function getPositionalPath (self, path) {\n\t521:   var subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n\t522:   if (subpaths.length < 2) {\n\t523:     return self.paths[subpaths[0]];\n\t526:   var val = self.path(subpaths[0]);\n\t529:   var last = subpaths.length - 1\n\t530:     , subpath\n\t533:   for (; i < subpaths.length; ++i) {\n\t534:     subpath = subpaths[i];\n\t536:     if (i === last && val && !val.schema && !/\\D/.test(subpath)) {\n\t546:     // ignore if its just a position segment: path.0.subpath\n\t547:     if (!/\\D/.test(subpath)) continue;\n\t554:     val = val.schema.path(subpath);\n\t557:   return self.subpaths[path] = val;\n\t827:     var key, path, index, field, isObject, options, type;\n\t828:     var keys = Object.keys(schema.paths);\n\t832:       path = schema.paths[key];\n\t834:       if (path instanceof MongooseTypes.DocumentArray) {\n\t835:         collectIndexes(path.schema, key + '.');\n\t837:         index = path._index;\n\t864:       fixSubIndexPaths(schema, prefix);\n\t879:    * These indexes need their paths prefixed properly.\n\t884:   function fixSubIndexPaths (schema, prefix) {\n\t938: Schema.prototype.virtualpath = function (name) {\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schematype.js:\n\t14:  * @param {String} path\n\t20: function SchemaType (path, options, instance) {\n\t21:   this.path = path;\n\t64:  *     schema.path('mixed').default(function () {\n\t72:  *     schema.path('mixed').default({});\n\t107:  *     Schema.path('my.path').index(true);\n\t108:  *     Schema.path('my.date').index({ expires: 60 });\n\t109:  *     Schema.path('my.path').index({ unique: true, sparse: true });\n\t134:  *     Schema.path('name').index({ unique: true });\n\t160:  *      Schema.path('name').index({text : true});\n\t183:  *     Schema.path('name').index({ sparse: true });\n\t216:  *     s.path('name').set(capitalize)\n\t252:  *         return schematype.path + ' is required';\n\t296:  *     s.path('born').get(dob)\n\t320:  *         return schematype.path + ' is required';\n\t322:  *         return schematype.path + ' is not';\n\t351:  * Adds validator(s) for this document path.\n\t367:  *     var custom = [validator, 'Uh oh, {PATH} does not equal \"something\".']\n\t381:  *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');\n\t385:  * From the examples above, you may have noticed that error messages support baseic templating. There are a few other template keywords besides `{PATH}` and `{VALUE}` too. To find out more, details are available [here](#error_messages_MongooseError-messages)\n\t391:  *     schema.path('name').validate(function (value, respond) {\n\t396: *      }, '{PATH} failed validation.');\n\t469:  *     var s = new Schema({ born: { type: Date, required: '{PATH} is required!' })\n\t471:  *     // or through the path API\n\t473:  *     Schema.path('name').required(true);\n\t477:  *     Schema.path('name').required(true, 'grrr :( ');\n\t502:     // no validation when this path wasn't selected in the query.\n\t504:         !this.isSelected(self.path) &&\n\t505:         !this.isModified(self.path)) return true;\n\t612:  * Sets default `select()` behavior for this path.\n\t614:  * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.\n\t644:     , path = this.path\n\t666:     validatorProperties.path = path;\n\t702:     , path = this.path\n\t724:     validatorProperties.path = path;\n\t752:   // fast path\n\t755:   if (!ref && doc && doc.$__fullPath) {\n\t759:     var path = doc.$__fullPath(self.path);\n\t761:     ref = owner.populated(path);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/statemachine.js:\n\t16:   this.paths = {};\n\t26:  * place their path argument into the given state.\n\t53:     // Changes the `path`'s state to `state`.\n\t54:     ctor.prototype[state] = function (path) {\n\t55:       this._changeState(path, state);\n\t65:  * - `require(path)`\n\t66:  * - `modify(path)`\n\t67:  * - `init(path)`\n\t72: StateMachine.prototype._changeState = function _changeState (path, nextState) {\n\t73:   var prevBucket = this.states[this.paths[path]];\n\t74:   if (prevBucket) delete prevBucket[path];\n\t76:   this.paths[path] = nextState;\n\t77:   this.states[nextState][path] = true;\n\t87:     , path\n\t90:     path = keys[i];\n\t91:     delete this.states[state][path];\n\t92:     delete this.paths[path];\n\t97:  * Checks to see if at least one path is in the states passed in via `arguments`\n\t131:     var paths = states.reduce(function (paths, state) {\n\t132:       return paths.concat(Object.keys(self.states[state]));\n\t135:     return paths[iterMethod](function (path, i, paths) {\n\t136:       return callback(path, i, paths);\n\t142:  * Iterates over the paths that belong to one of the parameter states.\n\t145:  * this.forEach(state1, fn);         // iterates over all paths in state1\n\t146:  * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n\t147:  * this.forEach(fn);                 // iterates over all paths in all states\n\t161:  * Maps over the paths that belong to one of the parameter states.\n\t164:  * this.forEach(state1, fn);         // iterates over all paths in state1\n\t165:  * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n\t166:  * this.forEach(fn);                 // iterates over all paths in all states\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/utils.js:\n\t9:   , mpath = require('mpath')\n\t505: function PopulateOptions (path, select, match, options, model) {\n\t506:   this.path = path;\n\t524: exports.populate = function populate (path, select, model, match, options) {\n\t531:     if (path instanceof PopulateOptions) {\n\t532:       return [path];\n\t535:     if (Array.isArray(path)) {\n\t536:       return path.map(function(o){\n\t541:     if (exports.isObject(path)) {\n\t542:       match = path.match;\n\t543:       options = path.options;\n\t544:       select = path.select;\n\t545:       model = path.model;\n\t546:       path = path.path;\n\t554:   if ('string' != typeof path) {\n\t555:     throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');\n\t559:   var paths = path.split(' ');\n\t560:   for (var i = 0; i < paths.length; ++i) {\n\t561:     ret.push(new PopulateOptions(paths[i], select, match, options, model));\n\t568:  * Return the value of `obj` at the given `path`.\n\t570:  * @param {String} path\n\t574: exports.getValue = function (path, obj, map) {\n\t575:   return mpath.get(path, obj, '_doc', map);\n\t579:  * Sets the value of `obj` at the given `path`.\n\t581:  * @param {String} path\n\t586: exports.setValue = function (path, val, obj, map) {\n\t587:   mpath.set(path, val, obj, '_doc', map);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/virtualtype.js:\n\t17:   this.path = name;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/error/cast.js:\n\t16: function CastError (type, value, path) {\n\t17:   MongooseError.call(this, 'Cast to ' + type + ' failed for value \"' + value + '\" at path \"' + path + '\"');\n\t22:   this.path = path;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/error/divergentArray.js:\n\t14: function DivergentArrayError (paths) {\n\t20:           + 'path(s) would have been modified unsafely:\\n'\n\t21:           + '  ' + paths.join('\\n  ') + '\\n'\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/error/messages.js:\n\t7:  *     mongoose.Error.messages.String.enum  = \"Your custom message for {PATH}.\";\n\t11:  * - `{PATH}` is replaced with the invalid document path\n\t27: msg.general.default = \"Validator failed for path `{PATH}` with value `{VALUE}`\";\n\t28: msg.general.required = \"Path `{PATH}` is required.\";\n\t31: msg.Number.min = \"Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).\";\n\t32: msg.Number.max = \"Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).\";\n\t35: msg.Date.min = \"Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).\";\n\t36: msg.Date.max = \"Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).\";\n\t39: msg.String.enum = \"`{VALUE}` is not a valid enum value for path `{PATH}`.\";\n\t40: msg.String.match = \"Path `{PATH}` is invalid ({VALUE}).\";\n\t41: msg.String.minlength = \"Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).\";\n\t42: msg.String.maxlength = \"Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).\";\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/error/validator.js:\n\t28:   this.path = properties.path;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/array.js:\n\t60:       this.caster.path = key;\n\t77:     return new MongooseArray(arr, self.path, this);\n\t136:       var indexes = doc.schema.indexedPaths();\n\t139:         var pathIndex = indexes[i][0][this.path];\n\t140:         if ('2dsphere' === pathIndex || '2d' === pathIndex) {\n\t147:       value = new MongooseArray(value, this.path, doc);\n\t157:         throw new CastError(e.type, value, this.path);\n\t166:       doc.markModified(this.path);\n\t317:       o[this.path] = v;\n\t318:       return cast(this.casterConstructor.schema, o)[this.path];\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/boolean.js:\n\t11:  * @param {String} path\n\t17: function SchemaBoolean (path, options) {\n\t18:   SchemaType.call(this, path, options);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/buffer.js:\n\t78:     // setting a populated path\n\t82:       throw new CastError('buffer', value, this.path);\n\t86:     // path to a plain object; cast to the Model used in\n\t88:     var path = doc.$__fullPath(this.path);\n\t90:     var pop = owner.populated(path, true);\n\t107:       value = new MongooseBuffer(value, [this.path, doc]);\n\t112:     var ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n\t123:     var ret = new MongooseBuffer(value, [this.path, doc]);\n\t127:   throw new CastError('buffer', value, this.path);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/date.js:\n\t60:  *     schema.path('createdAt').expires('7d');\n\t104:  *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n\t109:  *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n\t159:  *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n\t164:  *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n\t227:   throw new CastError('date', value, this.path);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/documentarray.js:\n\t48:   var path = this.path;\n\t54:     return new MongooseDocumentArray(arr, path, this);\n\t167:     // the db and the path isn't an array in the document\n\t169:       doc.markModified(this.path);\n\t175:     value = new MongooseDocumentArray(value, this.path, doc);\n\t188:         selected || (selected = scopePaths(this, doc.$__.selected, init));\n\t215:  * Scopes paths selected in a query to this array.\n\t218:  * @param {DocumentArray} array - the array to scope `fields` paths\n\t223: function scopePaths (array, fields, init) {\n\t226:   var path = array.path + '.'\n\t235:     if (0 === key.indexOf(path)) {\n\t237:       selected[key.substring(path.length)] = fields[key];\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/mixed.js:\n\t12:  * @param {String} path\n\t18: function Mixed (path, options) {\n\t34:   SchemaType.call(this, path, options);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/number.js:\n\t68:  *     var min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n\t73:  *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).\n\t121:  *     var max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n\t126:  *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).\n\t183:     // setting a populated path\n\t187:       throw new CastError('number', value, this.path);\n\t191:     // path to a plain object; cast to the Model used in\n\t193:     var path = doc.$__fullPath(this.path);\n\t195:     var pop = owner.populated(path, true);\n\t217:   throw new CastError('number', value, this.path);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/objectid.js:\n\t93:     // setting a populated path\n\t97:       throw new CastError('ObjectId', value, this.path);\n\t101:     // path to a plain object; cast to the Model used in\n\t103:     var path = doc.$__fullPath(this.path);\n\t105:     var pop = owner.populated(path, true);\n\t124:       throw new CastError('ObjectId', value, this.path);\n\t128:   throw new CastError('ObjectId', value, this.path);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/string.js:\n\t51:  *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.\n\t59:  *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'\n\t65:  *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`\n\t200:  *     var minlength = [10, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum length ({MINLENGTH}).'];\n\t205:  *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).\n\t253:  *     var maxlength = [10, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];\n\t258:  *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (10).\n\t301:  *       console.error(String(err)) // \"ValidationError: Path `name` is invalid (I am invalid).\"\n\t381:     // setting a populated path\n\t385:       throw new CastError('string', value, this.path);\n\t389:     // path to a plain object; cast to the Model used in\n\t391:     var path = doc.$__fullPath(this.path);\n\t393:     var pop = owner.populated(path, true);\n\t415:   throw new CastError('string', value, this.path);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/services/updateValidators.js:\n\t27:       var paths = Object.keys(castedDoc[keys[i]]);\n\t28:       var numPaths = paths.length;\n\t29:       for (var j = 0; j < numPaths; ++j) {\n\t31:           updatedValues[paths[j]] = castedDoc[keys[i]][paths[j]];\n\t33:           updatedValues[paths[j]] = undefined;\n\t35:         updatedKeys[paths[j]] = true;\n\t44:     paths = Object.keys(query._conditions);\n\t45:     numPaths = keys.length;\n\t46:     for (var i = 0; i < numPaths; ++i) {\n\t47:       if (typeof query._conditions[paths[i]] === 'Object') {\n\t48:         var conditionKeys = Object.keys(query._conditions[paths[i]]);\n\t61:       updatedKeys[paths[i]] = true;\n\t65:       schema.eachPath(function(path, schemaType) {\n\t66:         if (path === '_id') {\n\t71:         if (!updatedKeys[path] && typeof def !== 'undefined') {\n\t73:           castedDoc.$setOnInsert[path] = def;\n\t74:           updatedValues[path] = def;\n\t87:         schema.path(updates[i]).doValidate(\n\t107:           err.errors[validationErrors[i].path] = validationErrors[i];\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/types/array.js:\n\t20:  * @param {String} path\n\t27: function MongooseArray (values, path, doc) {\n\t35:   arr._path = path;\n\t39:     arr._schema = doc.schema.path(path);\n\t88:       populated = owner.populated(this._path, true);\n\t121:    * @param {String} embeddedPath the path which changed in the embeddedDoc\n\t126:   _markModified: function (elem, embeddedPath) {\n\t128:       , dirtyPath;\n\t131:       dirtyPath = this._path;\n\t134:         if (null != embeddedPath) {\n\t136:           dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;\n\t139:           dirtyPath = dirtyPath + '.' + elem;\n\t142:       parent.markModified(dirtyPath);\n\t176:     // $atomic op on a single path\n\t461:       , cur = this._parent.get(this._path)\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/types/buffer.js:\n\t6: var driver = global.MONGOOSE_DRIVER_PATH || '../drivers/node-mongodb-native';\n\t39:   var path;\n\t44:     path = encode[0];\n\t57:     , _path: { value: path }\n\t61:   if (doc && \"string\" === typeof path) {\n\t63:         value: doc.schema.path(path)\n\t108:       parent.markModified(this._path);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/types/documentarray.js:\n\t16:  * @param {String} path the path to this array\n\t24: function MongooseDocumentArray (values, path, doc) {\n\t35:   arr._path = path;\n\t39:     arr._schema = doc.schema.path(path);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/types/embedded.js:\n\t51:  * @param {String} path the path which changed\n\t55: EmbeddedDocument.prototype.markModified = function (path) {\n\t58:   this.$__.activePaths.modify(path);\n\t65:     this.__parentArray._markModified(this, path);\n\t157:  * Marks a path as invalid, causing validation to fail.\n\t159:  * @param {String} path the field to invalidate\n\t160:  * @param {String|Error} err error which states the reason `path` was invalid\n\t165: EmbeddedDocument.prototype.invalidate = function (path, err, val, first) {\n\t172:   var parentPath = this.__parentArray._path;\n\t173:   var fullPath = [parentPath, index, path].join('.');\n\t179:     this.__parent.invalidate(fullPath, err, val);\n\t181:     this.__parent.invalidate(fullPath, err);\n\t211:  * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.\n\t213:  * @param {String} [path]\n\t216:  * @method $__fullPath\n\t220: EmbeddedDocument.prototype.$__fullPath = function (path) {\n\t221:   if (!this.$__.fullPath) {\n\t223:     if (!parent.__parent) return path;\n\t225:     var paths = [];\n\t227:       paths.unshift(parent.__parentArray._path);\n\t231:     this.$__.fullPath = paths.join('.');\n\t239:   return path\n\t240:     ? this.$__.fullPath + '.' + path\n\t241:     : this.$__.fullPath;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/lib/types/objectid.js:\n\t6: var driver = global.MONGOOSE_DRIVER_PATH || '../drivers/node-mongodb-native';\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/hooks-fixed/README.md:\n\t30:   , Document = require('./path/to/some/document/constructor');\n\t63:   , Document = require('./path/to/some/document/constructor');\n\t122: Document.hook('set', function (path, val) {\n\t123:   this[path] = val;\n\t132: Document.pre('set', function (next, path, val) {\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/hooks-fixed/test.js:\n\t329:     A.hook('set', function (path, val) {\n\t330:       this[path] = val;\n\t332:     A.pre('set', function (next, path, val) {\n\t333:       path.should.equal('hello');\n\t345: //    A.hook('set', function (path, val) {\n\t346: //      this[path] = val;\n\t360:     A.hook('set', function (path, val) {\n\t361:       this[path] = val;\n\t363:     A.post('set', function (next, path, val) {\n\t364:       path.should.equal('hello');\n\t375: //    A.hook('set', function (path, val) {\n\t376: //      this[path] = val;\n\t390:     A.hook('set', function (path, val) {\n\t391:       this[path] = val;\n\t394:     A.pre('set', function (next, path, val) {\n\t397:     A.pre('set', function (next, path, val) {\n\t398:       assert.equal(path, 'foo');\n\t402:     A.pre('set', function (next, path, val, opt) {\n\t403:       assert.equal(path, 'rock');\n\t416:     A.hook('set', function (path, val) {\n\t417:       this[path] = val;\n\t419:     A.pre('set', function (next, path, val) {\n\t422:     A.post('set', function (next, path, val) {\n\t423:       path.should.equal('foo');\n\t440:     A.hook('set', function (path, val, opts) {\n\t441:       this[path] = val;\n\t443:     A.pre('set', function (next, path, val, opts) {\n\t455:     A.hook('set', function (path, val) {\n\t457:       this[path] = val;\n\t460:     A.pre('set', function (next, path, val) {\n\t464:     A.pre('set', true, function (next, done, path, val) {\n\t472:     A.pre('set', function (next, path, val) {\n\t476:     A.pre('set', true, function (next, done, path, val) {\n\t492:     A.hook('set', function (path, val) {\n\t493:       this[path] = val;\n\t494:       if (path === 'hello') counter.should.equal(1);\n\t495:       if (path === 'foo') counter.should.equal(2);\n\t497:     A.pre('set', true, function (next, done, path, val) {\n\t565:     A.hook('set', function (path, val, fn) {\n\t567:       this[path] = val;\n\t570:     A.pre('set', true, function (next, done, path, val, fn) {\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/HISTORY.md:\n\t9: - Optimized query path for performance, moving Object.defineProperty outside of constructors.\n\t935: * Cleanup of bson.js to remove duplicated code paths\n\t937: * Removing require.paths to make tests work with the 0.5.X branch\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/README.md:\n\t91: Let's boot up a MongoDB server instance. Download the right MongoDB version from [MongoDB](http://www.mongodb.org), open a new shell or command line and ensure the **mongod** command is in the shell or command line path. Now let's create a database directory (in our case under **/data**).\n\t94: mongod --dbpath=/data --port 27017\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/README.md:\n\t85: Let's boot up a MongoDB server instance. Download the right MongoDB version from [MongoDB](http://www.mongodb.org), open a new shell or command line and ensure the **mongod** command is in the shell or command line path. Now let's create a database directory (in our case under **/data**).\n\t88: mongod --dbpath=/data --port 27017\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/TESTING.md:\n\t6: mongod --dbpath=./db\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/cursor.js:\n\t204:     // Otherwise fall back to regular find path\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/mongos_manager.js:\n\t4:   , path = require('path')\n\t42:   // Set default db path if none set\n\t43:   var pidfilepath = mongosOptions.pidfilepath = mongosOptions.pidfilepath || path.join(path.resolve('data'), f(\"data-%d\", port));\n\t44:   var logpath = mongosOptions.logpath = mongosOptions.logpath || path.join(path.resolve('data'), f(\"data-%d.log\", port));\n\t66:   // Add the file path\n\t67:   pidfilepath = mongosOptions.pidfilepath = f(\"%s/mongos-%s.pid\", pidfilepath, port);\n\t107:           pid = fs.readFileSync(pidfilepath, 'ascii').trim();          \n\t123:             pid = fs.readFileSync(pidfilepath, 'ascii').trim();          \n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/replset_manager.js:\n\t4:   , path = require('path')\n\t60:   // DbPath\n\t61:   var dbpath = replsetOptions.dbpath = replsetOptions.dbpath || path.resolve('data');\n\t343:     // Remove db path and recreate it\n\t346:         rimraf.sync(dbpath);\n\t347:         mkdirp.sync(dbpath);\n\t363:         opts.dbpath = opts.dbpath ? opts.dbpath + f(\"/data-%s\", opts.port) : null;\n\t364:         opts.logpath = opts.logpath ? opts.logpath + f(\"/data-%s.log\", opts.port) : null;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/server_manager.js:\n\t4:   , path = require('path')\n\t61:   // Set default db path if none set\n\t62:   var dbpath = serverOptions.dbpath = serverOptions.dbpath || path.join(path.resolve('data'), f(\"data-%d\", port));\n\t63:   var logpath = serverOptions.logpath = serverOptions.logpath || path.join(path.resolve('data'), f(\"data-%d.log\", port));\n\t73:   Object.defineProperty(this, 'dbpath', {\n\t74:     enumerable:true, get: function() { return dbpath; }\n\t77:   Object.defineProperty(this, 'logpath', {\n\t78:     enumerable:true, get: function() { return logpath; }\n\t115:     , 'journal', 'notablescan', 'noscripting', 'repairpath', 'repair'\n\t118:     , 'dbpath', 'sysinfo', 'cpu', 'profile', 'slowms', 'rest'\n\t121:     , 'keyFile', 'pidfilepath', 'timeStampFormat', 'logappend'\n\t122:     , 'syslogFacility', 'syslog', 'logpath', 'maxConns', 'bind_ip', 'port'\n\t190:             pid = fs.readFileSync(path.join(dbpath, \"mongod.lock\"), 'ascii').trim();\n\t249:         rimraf.sync(serverOptions.dbpath);\n\t250:         mkdirp.sync(serverOptions.dbpath);        \n\t255:     if(fs.existsSync(path.join(dbpath, \"mongod.lock\"))) {\n\t256:       fs.unlinkSync(path.join(dbpath, \"mongod.lock\"));\n\t289:   var locateLockFile = function(dbpath) {\n\t296:           , pid: fs.readFileSync(path.join(dbpath, possibleLockFiles[i]), 'ascii').trim()\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/sharding_manager.js:\n\t4:   , path = require('path')\n\t70:   var dbpath = mongosOptions.dbpath;\n\t71:   var logpath = mongosOptions.logpath;\n\t109:         opts.dbpath = dbpath + f(\"/data-%s\", initiallConfigPort);\n\t110:         opts.logpath = logpath + f(\"/data-%s.log\", initiallConfigPort);\n\t141:         opts.dbpath = dbpath;\n\t142:         opts.logpath = logpath;\n\t181:         opts.pidfilepath = f(\"%s\", dbpath);\n\t182:         opts.logpath = f(\"%s/mongos-%s.log\", logpath, initiallMongosPort);\n\t260:             rimraf.sync(dbpath);\n\t261:             mkdirp.sync(dbpath);\n\t272:       rimraf.sync(dbpath);\n\t273:       mkdirp.sync(dbpath);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/browser_build/bson.js:\n\t30: function normalize(path) {\n\t31:   var ret = [], parts = path.split('/'), cur, prev;\n\t52: function dirname(path) {\n\t53:   return path && path.substr(0, path.lastIndexOf(\"/\")) || \".\";\n\t2705:   , './long'].forEach(function (path) {\n\t2706:   \tvar module = require('./' + path);\n\t2728: ].forEach(function (path) {\n\t2729:     \tvar module = require('./' + path);\n\t2753:     , '././bson'].forEach(function (path) {\n\t2754:     \tvar module = require('./' + path);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/build/bson.target.mk:\n\t118: # Copy this to the executable output path.\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/build/Makefile:\n\t11: abs_srcdir := $(abspath $(srcdir))\n\t28: # as they reach into the src/ directory for data with relative paths.\n\t30: abs_builddir := $(abspath $(builddir))\n\t35: abs_obj := $(abspath $(obj))\n\t79: # http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces\n\t93: # ccache or distcc lose the path to the target, so we convert a rule of\n\t97: #   path/to/foobar.o: DEP1 DEP2\n\t114: # Fixup path as in (1).\n\t171: # the local, absolute paths used on the link command-line.\n\t186: # $LD_LIBRARY_PATH), without triggering make substitution.\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/ext/wscript:\n\t3: from os.path import exists \n\t24:   # conf.check(lib='node', libpath=['/usr/lib', '/usr/local/lib'], uselib_store='NODE')\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/lib/bson/index.js:\n\t18:   , './long'].forEach(function (path) {\n\t19:   \tvar module = require('./' + path);\n\t41: ].forEach(function (path) {\n\t42:     \tvar module = require('./' + path);\n\t66:     , '././bson'].forEach(function (path) {\n\t67:     \tvar module = require('./' + path);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/CHANGELOG.md:\n\t166:  - fix \"not all control paths return a value\" compile warning on some platforms\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/include_dirs.js:\n\t1: console.log(require('path').relative('.', __dirname));\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/README.md:\n\t92: Pull in the path to **NAN** in your *binding.gyp* so that you can use `#include <nan.h>` in your *.cpp* files:\n\t100: This works like a `-I<path-to-NAN>` when compiling your addon.\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/build/kerberos.target.mk:\n\t133: # Copy this to the executable output path.\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/build/Makefile:\n\t11: abs_srcdir := $(abspath $(srcdir))\n\t28: # as they reach into the src/ directory for data with relative paths.\n\t30: abs_builddir := $(abspath $(builddir))\n\t35: abs_obj := $(abspath $(obj))\n\t79: # http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces\n\t93: # ccache or distcc lose the path to the target, so we convert a rule of\n\t97: #   path/to/foobar.o: DEP1 DEP2\n\t114: # Fixup path as in (1).\n\t171: # the local, absolute paths used on the link command-line.\n\t186: # $LD_LIBRARY_PATH), without triggering make substitution.\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/CHANGELOG.md:\n\t166:  - fix \"not all control paths return a value\" compile warning on some platforms\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/include_dirs.js:\n\t1: console.log(require('path').relative('.', __dirname));\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/README.md:\n\t92: Pull in the path to **NAN** in your *binding.gyp* so that you can use `#include <nan.h>` in your *.cpp* files:\n\t100: This works like a `-I<path-to-NAN>` when compiling your addon.\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/index.js:\n\t1: var path = require('path');\n\t24:     p = path.resolve(p);\n\t33:                 mkdirP(path.dirname(p), opts, function (er, made) {\n\t67:     p = path.resolve(p);\n\t76:                 made = sync(path.dirname(p), opts, made);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/readme.markdown:\n\t46: `opts.fs`. Your implementation should have `opts.fs.mkdir(path, mode, cb)` and\n\t47: `opts.fs.stat(path, cb)`.\n\t60: `opts.fs`. Your implementation should have `opts.fs.mkdirSync(path, mode)` and\n\t61: `opts.fs.statSync(path)`.\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/bin/cmd.js:\n\t16: var paths = argv._.slice();\n\t20:     if (paths.length === 0) return;\n\t21:     var p = paths.shift();\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/chmod.js:\n\t2: var path = require('path');\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/clobber.js:\n\t2: var path = require('path');\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/mkdirp.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/opts_fs.js:\n\t2: var path = require('path');\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/opts_fs_sync.js:\n\t2: var path = require('path');\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/perm.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/perm_sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/race.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/rel.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/return.js:\n\t2: var path = require('path');\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/return_sync.js:\n\t2: var path = require('path');\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/root.js:\n\t2: var path = require('path');\n\t8:     var file = path.resolve('/');\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/umask.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/umask_sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/bin.js:\n\t21:   log('Usage: rimraf <path>')\n\t23:   log('  Deletes all files and folders at \"path\" recursively.')\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/README.md:\n\t25: command `rimraf <path>` which is useful for cross platform support.\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/rimraf.js:\n\t4: var path = require(\"path\")\n\t131:       rimraf(path.join(p, f), function (er) {\n\t175:     rimrafSync(path.join(p, f))\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/test/test-async.js:\n\t2:   , path = require(\"path\")\n\t3: rimraf(path.join(__dirname, \"target\"), function (er) {\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/test/test-sync.js:\n\t2:   , path = require(\"path\")\n\t3: rimraf.sync(path.join(__dirname, \"target\"))\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/readable-stream/lib/_stream_transform.js:\n\t51: // a pathological inflate type of transform can cause excessive buffering\n\t57: // such a pathological inflating mechanism, there'd be no way to tell\n\t61: // However, even in such a pathological case, only a single written chunk\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/readable-stream/node_modules/isarray/build/build.js:\n\t3:  * Require the given path.\n\t5:  * @param {String} path\n\t10: function require(path, parent, orig) {\n\t11:   var resolved = require.resolve(path);\n\t15:     orig = orig || path;\n\t18:     err.path = orig;\n\t51:  * Resolve `path`.\n\t55:  *   - PATH/index.js\n\t56:  *   - PATH.js\n\t57:  *   - PATH\n\t59:  * @param {String} path\n\t60:  * @return {String} path or null\n\t64: require.resolve = function(path) {\n\t65:   if (path.charAt(0) === '/') path = path.slice(1);\n\t66:   var index = path + '/index.js';\n\t68:   var paths = [\n\t69:     path,\n\t70:     path + '.js',\n\t71:     path + '.json',\n\t72:     path + '/index.js',\n\t73:     path + '/index.json'\n\t76:   for (var i = 0; i < paths.length; i++) {\n\t77:     var path = paths[i];\n\t78:     if (require.modules.hasOwnProperty(path)) return path;\n\t87:  * Normalize `path` relative to the current path.\n\t90:  * @param {String} path\n\t95: require.normalize = function(curr, path) {\n\t98:   if ('.' != path.charAt(0)) return path;\n\t101:   path = path.split('/');\n\t103:   for (var i = 0; i < path.length; ++i) {\n\t104:     if ('..' == path[i]) {\n\t106:     } else if ('.' != path[i] && '' != path[i]) {\n\t107:       segs.push(path[i]);\n\t115:  * Register module at `path` with callback `definition`.\n\t117:  * @param {String} path\n\t122: require.register = function(path, definition) {\n\t123:   require.modules[path] = definition;\n\t142:  * Return a require function relative to the `parent` path.\n\t168:   function localRequire(path) {\n\t169:     var resolved = localRequire.resolve(path);\n\t170:     return require(resolved, parent, path);\n\t177:   localRequire.resolve = function(path) {\n\t178:     var c = path.charAt(0);\n\t179:     if ('/' == c) return path.slice(1);\n\t180:     if ('.' == c) return require.normalize(p, path);\n\t188:     path = segs.slice(0, i + 1).join('/') + '/deps/' + path;\n\t189:     return path;\n\t193:    * Check if module is defined at `path`.\n\t196:   localRequire.exists = function(path) {\n\t197:     return require.modules.hasOwnProperty(localRequire.resolve(path));\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mpath/package.json:\n\t2:   \"name\": \"mpath\",\n\t4:   \"description\": \"{G,S}et object values using MongoDB path notation\",\n\t11:     \"url\": \"git://github.com/aheckmann/mpath.git\"\n\t15:     \"path\",\n\t27:   \"readme\": \"#mpath\\n\\n{G,S}et javascript object values using MongoDB-like path notation.\\n\\n###Getting\\n\\n```js\\nvar mpath = require('mpath');\\n\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.get('comments.1.title', obj) // 'exciting!'\\n```\\n\\n`mpath.get` supports array property notation as well.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.get('comments.title', obj) // ['funny', 'exciting!']\\n```\\n\\nArray property and indexing syntax, when used together, are very powerful.\\n\\n```js\\nvar obj = {\\n  array: [\\n      { o: { array: [{x: {b: [4,6,8]}}, { y: 10} ] }}\\n    , { o: { array: [{x: {b: [1,2,3]}}, { x: {z: 10 }}, { x: 'Turkey Day' }] }}\\n    , { o: { array: [{x: {b: null }}, { x: { b: [null, 1]}}] }}\\n    , { o: { array: [{x: null }] }}\\n    , { o: { array: [{y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ];\\n}\\n\\nvar found = mpath.get('array.o.array.x.b.1', obj);\\n\\nconsole.log(found); // prints..\\n\\n    [ [6, undefined]\\n    , [2, undefined, undefined]\\n    , [null, 1]\\n    , [null]\\n    , [undefined]\\n    , [undefined, undefined, undefined]\\n    , undefined\\n    ]\\n\\n```\\n\\n#####Field selection rules:\\n\\nThe following rules are iteratively applied to each `segment` in the passed `path`. For example:\\n\\n```js\\nvar path = 'one.two.14'; // path\\n'one' // segment 0\\n'two' // segment 1\\n14    // segment 2\\n```\\n\\n- 1) when value of the segment parent is not an array, return the value of `parent.segment`\\n- 2) when value of the segment parent is an array\\n  - a) if the segment is an integer, replace the parent array with the value at `parent[segment]`\\n  - b) if not an integer, keep the array but replace each array `item` with the value returned from calling `get(remainingSegments, item)` or undefined if falsey.\\n\\n#####Maps\\n\\n`mpath.get` also accepts an optional `map` argument which receives each individual found value. The value returned from the `map` function will be used in the original found values place.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.get('comments.title', obj, function (val) {\\n  return 'funny' == val\\n    ? 'amusing'\\n    : val;\\n});\\n// ['amusing', 'exciting!']\\n```\\n\\n###Setting\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.1.title', 'hilarious', obj)\\nconsole.log(obj.comments[1].title) // 'hilarious'\\n```\\n\\n`mpath.set` supports the same array property notation as `mpath.get`.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.title', ['hilarious', 'fruity'], obj);\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: 'hilarious' },\\n      { title: 'fruity' }\\n  ]}\\n```\\n\\nArray property and indexing syntax can be used together also when setting.\\n\\n```js\\nvar obj = {\\n  array: [\\n      { o: { array: [{x: {b: [4,6,8]}}, { y: 10} ] }}\\n    , { o: { array: [{x: {b: [1,2,3]}}, { x: {z: 10 }}, { x: 'Turkey Day' }] }}\\n    , { o: { array: [{x: {b: null }}, { x: { b: [null, 1]}}] }}\\n    , { o: { array: [{x: null }] }}\\n    , { o: { array: [{y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ]\\n}\\n\\nmpath.set('array.1.o', 'this was changed', obj);\\n\\nconsole.log(require('util').inspect(obj, false, 1000)); // prints..\\n\\n{\\n  array: [\\n      { o: { array: [{x: {b: [4,6,8]}}, { y: 10} ] }}\\n    , { o: 'this was changed' }\\n    , { o: { array: [{x: {b: null }}, { x: { b: [null, 1]}}] }}\\n    , { o: { array: [{x: null }] }}\\n    , { o: { array: [{y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ];\\n}\\n\\nmpath.set('array.o.array.x', 'this was changed too', obj);\\n\\nconsole.log(require('util').inspect(obj, false, 1000)); // prints..\\n\\n{\\n  array: [\\n      { o: { array: [{x: 'this was changed too'}, { y: 10, x: 'this was changed too'} ] }}\\n    , { o: 'this was changed' }\\n    , { o: { array: [{x: 'this was changed too'}, { x: 'this was changed too'}] }}\\n    , { o: { array: [{x: 'this was changed too'}] }}\\n    , { o: { array: [{x: 'this was changed too', y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ];\\n}\\n```\\n\\n####Setting arrays\\n\\nBy default, setting a property within an array to another array results in each element of the new array being set to the item in the destination array at the matching index. An example is helpful.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.title', ['hilarious', 'fruity'], obj);\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: 'hilarious' },\\n      { title: 'fruity' }\\n  ]}\\n```\\n\\nIf we do not desire this destructuring-like assignment behavior we may instead specify the `$` operator in the path being set to force the array to be copied directly.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.$.title', ['hilarious', 'fruity'], obj);\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: ['hilarious', 'fruity'] },\\n      { title: ['hilarious', 'fruity'] }\\n  ]}\\n```\\n\\n####Field assignment rules\\n\\nThe rules utilized mirror those used on `mpath.get`, meaning we can take values returned from `mpath.get`, update them, and reassign them using `mpath.set`. Note that setting nested arrays of arrays can get unweildy quickly. Check out the [tests](https://github.com/aheckmann/mpath/blob/master/test/index.js) for more extreme examples.\\n\\n#####Maps\\n\\n`mpath.set` also accepts an optional `map` argument which receives each individual value being set. The value returned from the `map` function will be used in the original values place.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.title', ['hilarious', 'fruity'], obj, function (val) {\\n  return val.length;\\n});\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: 9 },\\n      { title: 6 }\\n  ]}\\n```\\n\\n### Custom object types\\n\\nSometimes you may want to enact the same functionality on custom object types that store all their real data internally, say for an ODM type object. No fear, `mpath` has you covered. Simply pass the name of the property being used to store the internal data and it will be traversed instead:\\n\\n```js\\nvar mpath = require('mpath');\\n\\nvar obj = {\\n    comments: [\\n      { title: 'exciting!', _doc: { title: 'great!' }}\\n    ]\\n}\\n\\nmpath.get('comments.0.title', obj, '_doc')            // 'great!'\\nmpath.set('comments.0.title', 'nov 3rd', obj, '_doc')\\nmpath.get('comments.0.title', obj, '_doc')            // 'nov 3rd'\\nmpath.get('comments.0.title', obj)                    // 'exciting'\\n```\\n\\nWhen used with a `map`, the `map` argument comes last.\\n\\n```js\\nmpath.get(path, obj, '_doc', map);\\nmpath.set(path, val, obj, '_doc', map);\\n```\\n\\n[LICENSE](https://github.com/aheckmann/mpath/blob/master/LICENSE)\\n\\n\",\n\t28:   \"_id\": \"mpath@0.1.1\",\n\t31:     \"tarball\": \"http://registry.npmjs.org/mpath/-/mpath-0.1.1.tgz\"\n\t46:   \"_from\": \"mpath@0.1.1\",\n\t47:   \"_resolved\": \"https://registry.npmjs.org/mpath/-/mpath-0.1.1.tgz\",\n\t49:     \"url\": \"https://github.com/aheckmann/mpath/issues\"\n\t51:   \"homepage\": \"https://github.com/aheckmann/mpath\"\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mpath/README.md:\n\t1: #mpath\n\t3: {G,S}et javascript object values using MongoDB-like path notation.\n\t8: var mpath = require('mpath');\n\t17: mpath.get('comments.1.title', obj) // 'exciting!'\n\t20: `mpath.get` supports array property notation as well.\n\t30: mpath.get('comments.title', obj) // ['funny', 'exciting!']\n\t48: var found = mpath.get('array.o.array.x.b.1', obj);\n\t65: The following rules are iteratively applied to each `segment` in the passed `path`. For example:\n\t68: var path = 'one.two.14'; // path\n\t81: `mpath.get` also accepts an optional `map` argument which receives each individual found value. The value returned from the `map` function will be used in the original found values place.\n\t91: mpath.get('comments.title', obj, function (val) {\n\t109: mpath.set('comments.1.title', 'hilarious', obj)\n\t113: `mpath.set` supports the same array property notation as `mpath.get`.\n\t123: mpath.set('comments.title', ['hilarious', 'fruity'], obj);\n\t148: mpath.set('array.1.o', 'this was changed', obj);\n\t164: mpath.set('array.o.array.x', 'this was changed too', obj);\n\t193: mpath.set('comments.title', ['hilarious', 'fruity'], obj);\n\t203: If we do not desire this destructuring-like assignment behavior we may instead specify the `$` operator in the path being set to force the array to be copied directly.\n\t213: mpath.set('comments.$.title', ['hilarious', 'fruity'], obj);\n\t225: The rules utilized mirror those used on `mpath.get`, meaning we can take values returned from `mpath.get`, update them, and reassign them using `mpath.set`. Note that setting nested arrays of arrays can get unweildy quickly. Check out the [tests](https://github.com/aheckmann/mpath/blob/master/test/index.js) for more extreme examples.\n\t229: `mpath.set` also accepts an optional `map` argument which receives each individual value being set. The value returned from the `map` function will be used in the original values place.\n\t239: mpath.set('comments.title', ['hilarious', 'fruity'], obj, function (val) {\n\t253: Sometimes you may want to enact the same functionality on custom object types that store all their real data internally, say for an ODM type object. No fear, `mpath` has you covered. Simply pass the name of the property being used to store the internal data and it will be traversed instead:\n\t256: var mpath = require('mpath');\n\t264: mpath.get('comments.0.title', obj, '_doc')            // 'great!'\n\t265: mpath.set('comments.0.title', 'nov 3rd', obj, '_doc')\n\t266: mpath.get('comments.0.title', obj, '_doc')            // 'nov 3rd'\n\t267: mpath.get('comments.0.title', obj)                    // 'exciting'\n\t273: mpath.get(path, obj, '_doc', map);\n\t274: mpath.set(path, val, obj, '_doc', map);\n\t277: [LICENSE](https://github.com/aheckmann/mpath/blob/master/LICENSE)\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mpath/lib/index.js:\n\t3:  * Returns the value of object `o` at the given `path`.\n\t14:  *     mpath.get('comments.0.title', o)         // 'exciting!'\n\t15:  *     mpath.get('comments.0.title', o, '_doc') // 'great!'\n\t16:  *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']\n\t19:  *     mpath.get(path, o)\n\t20:  *     mpath.get(path, o, special)\n\t21:  *     mpath.get(path, o, map)\n\t22:  *     mpath.get(path, o, special, map)\n\t24:  * @param {String} path\n\t26:  * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n\t30: exports.get = function (path, o, special, map) {\n\t38:   var parts = 'string' == typeof path\n\t39:     ? path.split('.')\n\t40:     : path\n\t43:     throw new TypeError('Invalid `path`. Must be either string or array');\n\t54:       var paths = parts.slice(i);\n\t58:           ? exports.get(paths, item, special, map)\n\t74:  * Sets the `val` at the given `path` of object `o`.\n\t76:  * @param {String} path\n\t79:  * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n\t84: exports.set = function (path, val, o, special, map, _copying) {\n\t92:   var parts = 'string' == typeof path\n\t93:     ? path.split('.')\n\t94:     : path\n\t97:     throw new TypeError('Invalid `path`. Must be either string or array');\n\t102:   // the existance of $ in a path tells us if the user desires\n\t106:   var copy = _copying || /\\$/.test(path)\n\t122:       var paths = parts.slice(i);\n\t126:           exports.set(paths, val[j], obj[j], special, map, copy);\n\t131:           exports.set(paths, val, obj[j], special, map, copy);\n\t144:   // process the last property of the path\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mpath/test/index.js:\n\t6: var mpath = require('../')\n\t19:  * special path for override tests\n\t28: describe('mpath', function(){\n\t63:     it('`path` must be a string or array', function(done){\n\t65:         mpath.get({}, o);\n\t68:         mpath.get(4, o);\n\t71:         mpath.get(function(){}, o);\n\t74:         mpath.get(/asdf/, o);\n\t77:         mpath.get(Math, o);\n\t80:         mpath.get(Buffer, o);\n\t83:         mpath.get('string', o);\n\t86:         mpath.get([], o);\n\t93:         assert.equal('jiro', mpath.get('name', o));\n\t97:           , mpath.get('first', o)\n\t102:           , mpath.get('first.second', o)\n\t107:           , mpath.get('first.second.third', o)\n\t112:           , mpath.get('first.second.third.0', o)\n\t117:           , mpath.get('first.second.third.2', o)\n\t122:           , mpath.get('first.second.third.1', o)\n\t127:           , mpath.get('first.second.third.1.name', o)\n\t136:           mpath.get('comments', o));\n\t138:         assert.deepEqual({ name: 'one' }, mpath.get('comments.0', o));\n\t139:         assert.deepEqual('one', mpath.get('comments.0.name', o));\n\t140:         assert.deepEqual('two', mpath.get('comments.1.name', o));\n\t141:         assert.deepEqual('three', mpath.get('comments.2.name', o));\n\t144:             , mpath.get('comments.2.comments', o));\n\t147:             , mpath.get('comments.2.comments.1', o));\n\t149:         assert.deepEqual('twoo', mpath.get('comments.2.comments.1.comments.0.val', o));\n\t157:           , mpath.get('comments.name', o)\n\t165:           , mpath.get('comments.comments', o)\n\t173:           , mpath.get('first.second.third.name', o)\n\t177:           , mpath.get('first.second.third.name', o, function (v) {\n\t194:           , mpath.get('array.o.array', o)\n\t209:           , mpath.get('array.o.array.0', o)\n\t224:           , mpath.get('array.o.array.0.x', o)\n\t239:           , mpath.get('array.o.array.y', o)\n\t250:           , mpath.get('array.o.array.x', o)\n\t265:           , mpath.get('array.o.array.x.b', o)\n\t280:           , mpath.get('array.o.array.x.b.1', o)\n\t291:           , mpath.get('array.o.array.x.b.1', o, function (v) {\n\t301:           , mpath.get('array.1.o.array', o)\n\t305:           , mpath.get('array.1.o.array', o, function (v) {\n\t320:           , mpath.get('arr.arr.1', o)\n\t324:           , mpath.get('arr.arr.1', o, function (v) {\n\t335:           , mpath.get('arr.arr.1.a', o, function (v) {\n\t342:           , mpath.get('arr.arr.1.a', o)\n\t344:         mpath.set('arr.arr.1.a', [{c:49},undefined], o)\n\t347:           , mpath.get('arr.arr.1.a', o)\n\t349:         mpath.set('arr.arr.1.a', [{c:48},undefined], o)\n\t356:           , mpath.get('arr.arr.1.a.c', o)\n\t360:           , mpath.get('arr.arr.1.a.c', o, function (v) {\n\t372:         assert.equal('jiro', mpath.get('name', o, special));\n\t376:           , mpath.get('first', o, special)\n\t381:           , mpath.get('first.second', o, special)\n\t386:           , mpath.get('first.second.third', o, special)\n\t391:           , mpath.get('first.second.third.0', o, special)\n\t396:           , mpath.get('first.second.third.0', o, special, function (v) {\n\t403:           , mpath.get('first.second.third.2', o, special)\n\t408:           , mpath.get('first.second.third.1', o, special)\n\t413:           , mpath.get('first.second.third.1.name', o, special)\n\t422:           mpath.get('comments', o, special));\n\t424:         assert.deepEqual({ name: 'one' }, mpath.get('comments.0', o, special));\n\t425:         assert.deepEqual('one', mpath.get('comments.0.name', o, special));\n\t426:         assert.deepEqual('2', mpath.get('comments.1.name', o, special));\n\t427:         assert.deepEqual('3', mpath.get('comments.2.name', o, special));\n\t428:         assert.deepEqual('nice', mpath.get('comments.2.name', o, special, function (v) {\n\t433:             , mpath.get('comments.2.comments', o, special));\n\t436:             , mpath.get('comments.2.comments.1', o, special));\n\t438:         assert.deepEqual(2, mpath.get('comments.2.comments.1.comments.0.val', o, special));\n\t445:           , mpath.get('comments.name', o, special)\n\t449:           , mpath.get('comments.name', o, special, function (v) {\n\t459:           , mpath.get('comments.comments', o, special)\n\t467:           , mpath.get('comments.comments.1.comments', o, special)\n\t475:           , mpath.get('comments.comments.1.comments.val', o, special)\n\t479:           , mpath.get('comments.comments.1.comments.val', o, special, function (v) {\n\t494:         mpath.set('name', 'a new val', o, function (v) {\n\t499:         mpath.set('name', 'changed', o);\n\t502:         mpath.set('first.second.third', [1,{name:'x'},9], o);\n\t505:         mpath.set('first.second.third.1.name', 'y', o)\n\t508:         mpath.set('comments.1.name', 'ttwwoo', o);\n\t511:         mpath.set('comments.2.comments.1.comments.0.expand', 'added', o);\n\t516:         mpath.set('comments.2.comments.1.comments.2', 'added', o);\n\t531:       describe('array.path', function(){\n\t534:             mpath.set('arr.yep', false, o, function (v) {\n\t542:             mpath.set('arr.yep', false, o);\n\t554:             mpath.set('arr.yep', ['one',2], o, function (v) {\n\t561:             mpath.set('arr.yep', ['one',2], o);\n\t572:             mpath.set('arr.yep', [47], o, function (v) {\n\t580:             mpath.set('arr.yep', [47], o);\n\t590:             mpath.set('arr.yep', [5,6,7], o, function (v) {\n\t598:             mpath.set('arr.yep', [5,6,7], o);\n\t609:       describe('array.$.path', function(){\n\t612:             mpath.set('arr.$.yep', {xtra: 'double good'}, o, function (v) {\n\t620:             mpath.set('arr.$.yep', {xtra: 'double good'}, o);\n\t631:             mpath.set('arr.$.yep', [15], o, function (v) {\n\t639:             mpath.set('arr.$.yep', [15], o);\n\t650:       describe('array.index.path', function(){\n\t652:           mpath.set('arr.1.yep', 0, o, function (v) {\n\t660:           mpath.set('arr.1.yep', 0, o);\n\t670:       describe('array.index.array.path', function(){\n\t672:           mpath.set('arr.0.arr.e', 35, o, function (v) {\n\t680:           mpath.set('arr.0.arr.e', 35, o);\n\t689:           mpath.set('arr.0.arr.e', ['a','b'], o, function (v) {\n\t697:           mpath.set('arr.0.arr.e', ['a','b'], o);\n\t707:       describe('array.index.array.path.path', function(){\n\t709:           mpath.set('arr.0.arr.a.b', 36, o, function (v) {\n\t717:           mpath.set('arr.0.arr.a.b', 36, o);\n\t726:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o, function (v) {\n\t734:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o);\n\t744:       describe('array.index.array.$.path.path', function(){\n\t746:           mpath.set('arr.0.arr.$.a.b', '$', o, function (v) {\n\t754:           mpath.set('arr.0.arr.$.a.b', '$', o);\n\t763:           mpath.set('arr.0.arr.$.a.b', [1], o, function (v) {\n\t771:           mpath.set('arr.0.arr.$.a.b', [1], o);\n\t781:       describe('array.array.index.path', function(){\n\t783:           mpath.set('arr.arr.0.a', 'single', o, function (v) {\n\t791:           mpath.set('arr.arr.0.a', 'single', o);\n\t800:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o, function (v) {\n\t808:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o);\n\t818:       describe('array.array.$.index.path', function(){\n\t820:           mpath.set('arr.arr.$.0.a', 'singles', o, function (v) {\n\t828:           mpath.set('arr.arr.$.0.a', 'singles', o);\n\t834:           mpath.set('$.arr.arr.0.a', 'single', o);\n\t843:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o, function (v) {\n\t851:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o);\n\t857:           mpath.set('arr.$.arr.0.a', [4,8,15,16,23,42,108], o);\n\t867:       describe('array.array.path.index', function(){\n\t869:           mpath.set('arr.arr.a.7', 47, o, function (v) {\n\t877:           mpath.set('arr.arr.a.7', 47, o);\n\t887:           mpath.set('arr.arr.a.7', [[null,46], [undefined, 'woot']], o);\n\t903:       describe('handles array.array.path', function(){\n\t916:           mpath.set('arr.arr.e', 47, o, function (v) {\n\t936:           mpath.set('arr.arr.e', 47, o);\n\t955:           mpath.set('arr.arr.e', [[1,2,3],[4,5],null,[],[6], [7,8,9]], o, function (v) {\n\t977:           mpath.set('arr.arr.e', [[1,2,3],[4,5],null,[],[6], [7,8,9]], o);\n\t1005:         mpath.set('name', 'chan', o, special, function (v) {\n\t1010:         mpath.set('name', 'changer', o, special);\n\t1013:         mpath.set('first.second.third', [1,{name:'y'},9], o, special);\n\t1016:         mpath.set('first.second.third.1.name', 'z', o, special)\n\t1019:         mpath.set('comments.1.name', 'ttwwoo', o, special);\n\t1022:         mpath.set('comments.2.comments.1.comments.0.expander', 'adder', o, special, function (v) {\n\t1029:         mpath.set('comments.2.comments.1.comments.0.expander', 'adder', o, special);\n\t1034:         mpath.set('comments.2.comments.1.comments.2', 'set', o, special);\n\t1048:       describe('array.path', function(){\n\t1053:             mpath.set('arr.yep', false, o, special, function (v) {\n\t1061:             mpath.set('arr.yep', false, o, special);\n\t1072:             mpath.set('arr.yep', ['one',2], o, special, function (v) {\n\t1080:             mpath.set('arr.yep', ['one',2], o, special);\n\t1090:             mpath.set('arr.yep', [47], o, special, function (v) {\n\t1098:             mpath.set('arr.yep', [47], o, special);\n\t1107:             mpath.set('arr.yep', [20], o, special);\n\t1117:             mpath.set('arr.yep', [5,6,7], o, special, function () {\n\t1125:             mpath.set('arr.yep', [5,6,7], o, special);\n\t1136:       describe('array.$.path', function(){\n\t1139:             mpath.set('arr.$.yep', {xtra: 'double good'}, o, special, function (v) {\n\t1148:             mpath.set('arr.$.yep', {xtra: 'double good'}, o, special);\n\t1160:             mpath.set('arr.$.yep', [15], o, special, function (v) {\n\t1169:             mpath.set('arr.$.yep', [15], o, special);\n\t1181:       describe('array.index.path', function(){\n\t1183:           mpath.set('arr.1.yep', 0, o, special, function (v) {\n\t1192:           mpath.set('arr.1.yep', 0, o, special);\n\t1203:       describe('array.index.array.path', function(){\n\t1205:           mpath.set('arr.0.arr.e', 35, o, special, function (v) {\n\t1214:           mpath.set('arr.0.arr.e', 35, o, special);\n\t1224:           mpath.set('arr.0.arr.e', ['a','b'], o, special, function (v) {\n\t1233:           mpath.set('arr.0.arr.e', ['a','b'], o, special);\n\t1244:       describe('array.index.array.path.path', function(){\n\t1246:           mpath.set('arr.0.arr.a.b', 36, o, special, function (v) {\n\t1255:           mpath.set('arr.0.arr.a.b', 36, o, special);\n\t1265:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o, special, function (v) {\n\t1274:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o, special);\n\t1285:       describe('array.index.array.$.path.path', function(){\n\t1287:           mpath.set('arr.0.arr.$.a.b', '$', o, special, function (v) {\n\t1296:           mpath.set('arr.0.arr.$.a.b', '$', o, special);\n\t1306:           mpath.set('arr.0.arr.$.a.b', [1], o, special, function (v) {\n\t1315:           mpath.set('arr.0.arr.$.a.b', [1], o, special);\n\t1326:       describe('array.array.index.path', function(){\n\t1328:           mpath.set('arr.arr.0.a', 'single', o, special, function (v) {\n\t1337:           mpath.set('arr.arr.0.a', 'single', o, special);\n\t1347:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o, special, function (v) {\n\t1356:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o, special);\n\t1367:       describe('array.array.$.index.path', function(){\n\t1369:           mpath.set('arr.arr.$.0.a', 'singles', o, special, function (v) {\n\t1378:           mpath.set('arr.arr.$.0.a', 'singles', o, special);\n\t1385:           mpath.set('$.arr.arr.0.a', 'single', o, special);\n\t1395:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o, special, function (v) {\n\t1404:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o, special);\n\t1411:           mpath.set('arr.$.arr.0.a', [4,8,15,16,23,42,108], o, special);\n\t1422:       describe('array.array.path.index', function(){\n\t1424:           mpath.set('arr.arr.a.7', 47, o, special, function (v) {\n\t1433:           mpath.set('arr.arr.a.7', 47, o, special);\n\t1444:           mpath.set('arr.arr.a.7', [[null,46], [undefined, 'woot']], o, special, function (v) {\n\t1459:           mpath.set('arr.arr.a.7', [[null,46], [undefined, 'woot']], o, special);\n\t1473:       describe('handles array.array.path', function(){\n\t1483:           mpath.set('arr.arr.e', 47, o, special);\n\t1519:           mpath.set('arr.arr.e', [[1,2,3],[4,5],null,[],[6], [7,8,9]], o, special);\n\t1562:         var vals = mpath.get('array.o.array.x.b', o);\n\t1570:         mpath.set('array.o.array.x.b', vals, o);\n\t1586:         mpath.set('comments.name', ['this', 'was', 'changed'], o);\n\t1596:         mpath.set('comments.name', ['also', 'changed', 'this'], o, special);\n\t1615:           mpath.set('arr.$.arr.$.a', 35, o);\n\t1621:     it('ignores setting a nested path that doesnt exist', function(done){\n\t1624:         mpath.set('thing.that.is.new', 10, o);\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mquery/README.md:\n\t180: All paths passed that are not `$atomic` operations will become `$set` ops. For example:\n\t405: Specifies the complementary comparison value for the path specified with `where()`.\n\t499: query.where('path').intersects().geometry({\n\t505: query.where('path').intersects({\n\t655: When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.\n\t721: Specifies a `$slice` projection for a `path`\n\t757: Specifies a `path` for use with chaining\n\t884: If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mquery/lib/mquery.js:\n\t50:   this._path = proto._path || undefined;\n\t135:   p._path = this._path;\n\t231:  * Specifies a `path` for use with chaining.\n\t251:  * @param {String} [path]\n\t264:     this._path = arguments[0];\n\t267:       this._conditions[this._path] = arguments[1];\n\t277:   throw new TypeError('path must be a string or object');\n\t281:  * Specifies the complementary comparison value for paths specified with `where()`\n\t297:   this._ensurePath('equals');\n\t298:   var path = this._path;\n\t299:   this._conditions[path] = val;\n\t364:  * When called with one argument, the most recent path passed to `where()` is used.\n\t375:  * @param {String} [path]\n\t383:  * When called with one argument, the most recent path passed to `where()` is used.\n\t387:  * @param {String} [path]\n\t395:  * When called with one argument, the most recent path passed to `where()` is used.\n\t399:  * @param {String} [path]\n\t407:  * When called with one argument, the most recent path passed to `where()` is used.\n\t411:  * @param {String} [path]\n\t419:  * When called with one argument, the most recent path passed to `where()` is used.\n\t423:  * @param {String} [path]\n\t431:  * When called with one argument, the most recent path passed to `where()` is used.\n\t435:  * @param {String} [path]\n\t443:  * When called with one argument, the most recent path passed to `where()` is used.\n\t447:  * @param {String} [path]\n\t455:  * When called with one argument, the most recent path passed to `where()` is used.\n\t459:  * @param {String} [path]\n\t467:  * When called with one argument, the most recent path passed to `where()` is used.\n\t471:  * @param {String} [path]\n\t479:  * When called with one argument, the most recent path passed to `where()` is used.\n\t483:  * @param {String} [path]\n\t491:  * When called with one argument, the most recent path passed to `where()` is used.\n\t495:  * @param {String} [path]\n\t508:     var path, val;\n\t511:       this._ensurePath($conditional);\n\t513:       path = this._path;\n\t516:       path = arguments[0];\n\t519:     var conds = this._conditions[path] || (this._conditions[path] = {});\n\t528:  * @param {String} [path]\n\t535:   var val, path;\n\t538:     this._ensurePath('mod')\n\t540:     path = this._path;\n\t542:     this._ensurePath('mod')\n\t544:     path = this._path;\n\t547:     path = arguments[0];\n\t550:     path = arguments[0];\n\t553:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t572:  * @param {String} [path]\n\t579:   var path, val;\n\t582:     this._ensurePath('exists');\n\t583:     path = this._path;\n\t587:       this._ensurePath('exists');\n\t588:       path = this._path;\n\t591:       path = arguments[0];\n\t595:     path = arguments[0];\n\t599:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t623:  * @param {String|Object|Function} path\n\t633:   var fn, path, criteria;\n\t636:     this._ensurePath('elemMatch');\n\t637:     path = this._path;\n\t640:     this._ensurePath('elemMatch');\n\t641:     path = this._path;\n\t644:     path = arguments[0];\n\t647:     path = arguments[0];\n\t659:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t694:   this._ensurePath('within');\n\t740:  * @param {String} path\n\t747:   var path, box;\n\t751:     path = arguments[0];\n\t755:     this._ensurePath('box');\n\t756:     path = this._path;\n\t762:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t775:  * @param {String|Array} [path]\n\t783:   var val, path;\n\t787:     path = arguments[0];\n\t791:     this._ensurePath('polygon');\n\t792:     path = this._path;\n\t796:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t815:  * @param {String} [path]\n\t823:   var path, val;\n\t826:     this._ensurePath('circle');\n\t827:     path = this._path;\n\t830:     path = arguments[0];\n\t839:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t869:  * @param {String} [path]\n\t877:   var path, val;\n\t884:     this._ensurePath('near');\n\t885:     path = this._path;\n\t888:     path = arguments[0];\n\t898:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t936:  *     query.where('path').intersects().geometry({\n\t941:  *     query.where('path').intersects({\n\t953:   this._ensurePath('intersects');\n\t996:  * The most recent path passed to `where()` is used.\n\t1014:   var val, path;\n\t1017:     this._ensurePath('geometry');\n\t1018:     path = this._path;\n\t1028:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t1041:  * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.\n\t1102:  * Specifies a $slice condition for a `path`\n\t1112:  * @param {String} [path]\n\t1125:   var path, val;\n\t1128:     this._ensurePath('slice');\n\t1129:     path = this._path;\n\t1133:       this._ensurePath('slice');\n\t1134:       path = this._path;\n\t1137:       path = arguments[0];\n\t1141:     path = arguments[0];\n\t1146:   myFields[path] = { '$slice': val };\n\t1155:  * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n\t1798:  * _All paths passed that are not $atomic operations will become $set ops._\n\t2381:  * Make sure _path is set.\n\t2386: Query.prototype._ensurePath = function (method) {\n\t2387:   if (!this._path) {\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mquery/test/index.js:\n\t61:       var path = 'street';\n\t67:       q.where(path);\n\t78:       assert.equal(path, m._path);\n\t143:       }, /path must be a string or object/);\n\t160:         assert.equal('name', m._path);\n\t167:       assert.equal('name', m._path);\n\t186:     it('sets value of path set with where()', function(){\n\t287:       it('uses previously set `where` path if 1 arg passed', function(){\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/ms/test/support/jquery.js:\n\t1665: \t\t\t// the code to shortcut on the same path as a DOM node with no cache\n\t3047: \t\t\tcache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;\n\t3117: \t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t3119: \t\teventPath = [[ elem, special.bindType || type ]];\n\t3126: \t\t\t\teventPath.push([ cur, bubbleType ]);\n\t3132: \t\t\t\teventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);\n\t3136: \t\t// Fire handlers on the event path\n\t3137: \t\tfor ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {\n\t3139: \t\t\tcur = eventPath[i][0];\n\t3140: \t\t\tevent.type = eventPath[i][1];\n\t6667: \t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...\n\n/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/muri/lib/index.js:\n\t44:   var path = match[2];\n\t75:   var parts = path.split('?');\n\n/node_modules/acute-data-mongodb/tests/testMongoDb.js:\n\t2:     path = require('path'),\n\t9:         var configPath = path.join(__dirname, \"testconfig.js\");\n\t10:         var config = architect.loadConfig(configPath);\n\n/node_modules/acute-express-app/tests/testApp.js:\n\t2:     path = require('path'),\n\t9:         var configPath = path.join(__dirname, \"testconfig.js\");\n\t10:         var config = architect.loadConfig(configPath);\n\n/node_modules/acute-express-app/tests/testconfig.js:\n\t7:         packagePath: \"../\",\n\n/node_modules/acute-express-controllers/package.json:\n\t36:     \"path\": \"*\"\n\n/node_modules/acute-express-controllers/lib/index.js:\n\t5:  * can be overridden by exporting a \"mountPath\" option from the controller.\n\t9:     path = require('path'),\n\t16: var DEFAULT_MOUNTPATH = \"/\";\n\t18: var add = function(mountPath, router, fn) {\n\t19:   console.log(\"loading router at \", mountPath);\n\t21:     if (!mountPath) {\n\t22:       mountPath = DEFAULT_MOUNTPATH;\n\t24:     app.app.use(mountPath, router);\n\t37:   console.log(\"path = \", path.join(basedir, dirname));\n\t38:     acuteUtils.walkFs(path.join(basedir, dirname), function(err, files) {\n\t47:             if (_.isUndefined(controller.mountPath)) {\n\t48:               var relPath = path.relative(path.join(basedir, dirname), file);\n\t49:               var p = relPath.split(path.sep);\n\t52:                 controller.mountPath = path.sep + p.join(path.sep);\n\t54:                 controller.mountPath = DEFAULT_MOUNTPATH;\n\t57:             add(controller.mountPath, controller.routes, function(err) {\n\n/node_modules/acute-express-controllers/tests/testconfig.js:\n\t3:         packagePath: \"../\",\n\n/node_modules/acute-express-controllers/tests/testControllers.js:\n\t2:     path = require('path'),\n\t9:         var configPath = path.join(__dirname, \"testconfig.js\");\n\t10:         var config = architect.loadConfig(configPath);\n\n/node_modules/acute-express-controllers/tests/test_controllers/index.js:\n\t26:       // mountPath: \"/\"\n\n/node_modules/acute-express-controllers/tests/test_controllers/index2.js:\n\t26:       // mountPath: \"/\"\n\n/node_modules/acute-express-controllers/tests/test_controllers/controller_folder/controller_in_subfolder.js:\n\t26:       // mountPath: \"/\"\n\n/node_modules/acute-express-data/package.json:\n\t35:     \"path\": \"*\",\n\n/node_modules/acute-express-data/node_modules/util/test/node/debug.js:\n\t49:   var child = spawn(process.execPath, [__filename, 'child'], {\n\n/node_modules/acute-express-data/tests/testconfig.js:\n\t3:         packagePath: \"../\",\n\n/node_modules/acute-express-data/tests/testData.js:\n\t2:     path = require('path'),\n\t9:         var configPath = path.join(__dirname, \"testconfig.js\");\n\t10:         var config = architect.loadConfig(configPath);\n\n/node_modules/acute-express-utils/package.json:\n\t35:     \"path\": \"*\",\n\n/node_modules/acute-express-utils/lib/index.js:\n\t9:     path = require('path');\n\t38:   var path = require('path');\n\t41:       var base = path.basename(dir);\n\t64:     fn(err.path);\n\t70:  * using the path components.\n\t75: var pathsToFileTree = function(files, basedir, fn) {\n\t79:     var relativePath = path.relative(basedir, file);\n\t80:     // var base = path.dirname(file);\n\t81:     var pathComponents = relativePath.split(path.sep);\n\t82:     // to reverse this, call pathComponents.join(path.sep);\n\t84:     // console.log(\"pathComponents = \", pathComponents);\n\t85:     tree.push(pathComponents);\n\t97:  * Converts path components in an array to a path.\n\t98:  * @param pathComponents the array that describes the file path.\n\t99:  * @param fn a callback with the signature (path)\n\t101: var urlFromPathComponents = function(pathComponents, basedir, fn) {\n\t103:   pathComponents.pop();\n\t104:   fn(\"/\" + pathComponents.join(\"/\"));\n\t106:     // This snippet of code can search through a relative path to get the directory\n\t107:     // structure and separate them out into separate path components\n\t108:     // var relativePath = path.relative(baseDir, file);\n\t109:     // var pathComponents = relativePath.split(path.sep);\n\t110:     // // console.log(\"path components\", pathComponents);\n\t111:     // if (pathComponents.length > 1) {\n\t112:     //   async.reduce(pathComponents, returnFile, function(memo, item, callback){\n\t121:     //       result[pathComponents[-1]] = file;\n\t141:       pathsToFileTree: pathsToFileTree,\n\t142:       urlFromPathComponents: urlFromPathComponents\n\n/node_modules/acute-express-utils/node_modules/findit/index.js:\n\t3: var path = require('path');\n\t26:         emitter.emit('path', fdir, dstat);\n\t47:             if (!err.path) err.path = dir;\n\t60:                     if (!err.path) err.path = dir;\n\t64:                 var file_ = path.resolve(dir, rfile);\n\t75:             emitter.emit('path', fdir, stat);\n\t83:             emitter.emit('path', fdir, stat);\n\t95:             emitter.emit('path', fdir, stat);\n\t115:             if (!err.path) err.path = dir;\n\t121:             var file = path.join(fdir, rfile);\n\t129:                     if (!err.path) err.path = file;\n\t154:                     if (!err.path) err.path = file;\n\t158:                 var file_ = path.resolve(path.dirname(file), rfile);\n\t166:                         if (!err.path) err.path = file_;\n\t178:             emitter.emit('path', file, stat);\n\t183:             emitter.emit('path', file, stat);\n\n/node_modules/acute-express-utils/node_modules/findit/readme.markdown:\n\t11: var path = require('path');\n\t14:     var base = path.basename(dir);\n\t61: ## finder.on('path', function (file, stat) {})\n\t71: For each directory, this event fires with the path `dir`.\n\t98: You can always get the source of the error by checking `err.path`.\n\n/node_modules/acute-express-utils/node_modules/findit/example/emitter.js:\n\t2: var path = require('path');\n\t5:     var base = path.basename(dir);\n\n/node_modules/acute-express-utils/node_modules/findit/test/err.js:\n\t3: var path = require('path');\n\t10:         t.equal(err.path, __dirname + '/does/not/exist');\n\n/node_modules/acute-express-utils/node_modules/findit/test/foo.js:\n\t8:     var paths = []\n\t9:     finder.on('path', function (p, stat) {\n\t10:         paths.push(p);\n\t37:         var count = { dirs : 0, files : 0, paths : 0 };\n\t54:         t.deepEqual(paths.sort(), Object.keys(ps).sort());\n\n/node_modules/acute-express-utils/node_modules/findit/test/stop.js:\n\t3: var path = require('path');\n\n/node_modules/acute-express-utils/node_modules/findit/test/symlinks.js:\n\t2: var path = require('path');\n\t15:         symlinks.push(path.basename(link));\n\t20:         files.push(path.basename(file));\n\t25:         dirs.push(path.basename(dir));\n\t65:             data.errors[0].path, __dirname\n\n/node_modules/acute-express-utils/node_modules/util/test/node/debug.js:\n\t49:   var child = spawn(process.execPath, [__filename, 'child'], {\n\n/node_modules/acute-express-utils/tests/testUtils.js:\n\t2:     path = require('path'),\n\t9:         var configPath = path.join(__dirname, \"testconfig.js\");\n\t10:         var config = architect.loadConfig(configPath);\n\t26:             app.services.utils.walkFs(path.join(__dirname, \"testdir\"), function(err, file) {\n\t38:     describe(\"#pathsToFileTree\", function() {\n\t41:             app.services.utils.walkFs(path.join(__dirname, \"testdir\"), function(err, fileArray) {\n\t45:                     app.services.utils.pathsToFileTree(fileArray, path.join(__dirname, \"testdir\"), function(err, fileTree) {\n\t58:     describe(\"#urlFromPathComponents\", function() {\n\t59:         it(\"should create a url from path components\", function(done) {\n\t61:             app.services.utils.walkFs(path.join(__dirname, \"testdir\"), function(err, fileArray) {\n\t66:                     app.services.utils.pathsToFileTree(fileArray, path.join(__dirname, \"testdir\"), function(err, fileTree) {\n\t73:                                 app.services.utils.urlFromPathComponents(item, \"/\", function(route) {\n\n/node_modules/acute-mongoose-models/package.json:\n\t36:     \"path\": \"*\"\n\n/node_modules/acute-mongoose-models/lib/index.js:\n\t9:     path = require('path'),\n\t25:           path = require('path');\n\t54:     acuteUtils.walkFs(path.join(basedir, dirname), function(err, files) {\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/History.md:\n\t5:  * added; dynamic refpaths #2640 [chetvernikov](https://github.com/chetvernikov)\n\t14:  * fixed; array saved as object when path is object in array #2442\n\t33:  * added; can explicitly exclude paths from versioning #2576 [csabapalfi](https://github.com/csabapalfi)\n\t107:  * added; ability to set single populated paths to documents #1530\n\t136:  * fixed; properly remove modified array paths if array has been overwritten #1638\n\t190:  * fixed; custom getter might cause mongoose to mistakenly think a path is dirty #2100 [pgherveou](https://github.com/pgherveou)\n\t235:  * updated; added get / set to reserved path list #1903 [tstrimple](https://github.com/tstrimple)\n\t337:  * fixed; repopulating modified populated paths #1697\n\t414:  * fixed; repopulating modified populated paths #1697\n\t535:  * fixed; repopulating modified populated paths #1697\n\t677:   * fixed; strict:throw edge case using .set(path, val)\n\t678:   * fixed; schema.pathType() on some numbericAlpha paths\n\t679:   * fixed; numbericAlpha path versioning\n\t680:   * fixed; setting nested mixed paths #1418\n\t725:   * fixed; use of `setMaxListeners` as path\n\t757:   * added; doc#populated(path) stores original populated _ids\n\t762:   * added; support for rich nested path population\n\t775:   * fixed; setting populated paths #570\n\t787:   * fixed; add EventEmitter props to reserved paths #1338\n\t791:   * fixed; specifying schema type edge case { path: [{type: \"String\" }] }\n\t797:   * updated; mpath to 0.1.1\n\t840:   * fixed; setting populated paths #570\n\t852:   * fixed; add EventEmitter props to reserved paths #1338\n\t871:   * fixed; specifying schema type edge case { path: [{type: \"String\" }] }\n\t877:   * added; doc#populated(path) stores original populated _ids\n\t882:   * added; support for rich nested path population\n\t890:   * updated; mpath to 0.1.1\n\t979:   * fixed; add EventEmitter props to reserved paths #1338\n\t1009:   * changed; \"_pres\" & \"_posts\" are now reserved pathnames #1261\n\t1031:   * fixed; regression when using subdoc with `path` as pathname #1245 [daeq](https://github.com/daeq)\n\t1042:   * added; paths to CastErrors #1239\n\t1083:   * changed; adding invalid nested paths to non-objects throws 4216f14\n\t1188:   * fixed; use of nested paths beginning w/ numbers #1062\n\t1202:   * fixed; compat with non-schema path props using positional notation (#1048)\n\t1227:   * fixed; allow subdoc literal declarations containing \"type\" pathname (#993)\n\t1230:   * fixed; allow use of `options` as a pathname (#529)\n\t1231:   * fixed; `model` is again a permitted schema path name\n\t1250:   * fixed; provide helpful error msgs when reserved schema path is used (#928)\n\t1276:   * changed; doc#modifiedPaths is now a method (#950)\n\t1292:   * fixed; setting invalid paths in strict mode (#916)\n\t1299:   * fixed; subdoc paths reported in validation errors (#725)\n\t1306:   * fixed; set/updating nested objects by parent pathname (#843)\n\t1318:   * added; inclusion of deselected schema path (#786)\n\t1372:   * fixed; edge case when using 'options' as a path name (#961)\n\t1378:   * fixed; selection of _id w/ another excluded path (#954)\n\t1393:   * fixed; setting invalid paths in strict mode (#916)\n\t1435:   * fixed; doc.isSelected(otherpath) when only _id is selected (#730)\n\t1441:   * fixed; failing validation of unselected required paths (#730,#713)\n\t1469:   * added; default path selection to SchemaTypes\n\t1508:   * added; doc#isSelected(path)\n\t1512:   * added; document.modifiedPaths (#709) [ljharb]\n\t1566:   * fixed; bug in 2.4.6 with path setting\n\t1611:   * added; $unset is now used when setting a path to undefined (#519)\n\t1638:   * fixed; model.update casting for nested paths works (#542)\n\t1782:   * fixed; reset modified paths and atomics after saved (#459)\n\t1934:   * fixed; 'path' is now a valid Schema pathname\n\t1938:   * fixed; modifying subdoc property sets modified paths for subdoc and parent doc\n\t1939:   * fixed; marking subdoc path as modified properly persists the value to the db\n\t2041:   * Fixed; no longer using $set on paths to an unexisting fields\n\t2112:   * Only doValidate when path exists in Schema [aheckmann]\n\t2226:   * Fixed; it's now possible to instantiate a model even when one of the paths maps\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/package.json:\n\t31:     \"mpath\": \"0.1.1\",\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/README.md:\n\t104: Comment.path('name').set(function (v) {\n\t219: For example, this would allow you to broadcast changes about your Documents every time someone `set`s a path in your Document to a new value:\n\t222: schema.pre('set', function (next, path, val, typel) {\n\t224:   this.emit('set', path, val);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/examples/population/population-across-three-collections.js:\n\t113:           path: 'author.friends',\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/examples/population/population-of-multiple-existing-docs.js:\n\t88:     var options = { path: 'consoles', select: 'name released -_id' };\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/examples/population/population-options.js:\n\t93:       path: 'consoles'\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/examples/schema/schema.js:\n\t46: BlogPost.path('date')\n\t88:     schema.path(key).set(function(v){\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/aggregate.js:\n\t280:  * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/browserDocument.js:\n\t30:  * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n\t80:   var required = this.schema.requiredPaths();\n\t82:     this.$__.activePaths.require(required[i]);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/cast.js:\n\t18:   var paths = Object.keys(obj)\n\t19:     , i = paths.length\n\t23:     , path\n\t28:     path = paths[i];\n\t29:     val = obj[path];\n\t31:     if ('$or' === path || '$nor' === path || '$and' === path) {\n\t39:     } else if (path === '$where') {\n\t47:         obj[path] = val.toString();\n\t59:       schematype = schema.path(path);\n\t63:         var split = path.split('.')\n\t65:           , pathFirstHalf\n\t66:           , pathLastHalf\n\t70:         // Find the part of the var path that is a path of the Schema\n\t72:           pathFirstHalf = split.slice(0, j).join('.');\n\t73:           schematype = schema.path(pathFirstHalf);\n\t77:         // If a substring of the input path resolves to an actual real path...\n\t82:             pathLastHalf = split.slice(j).join('.');\n\t83:             remainingConds[pathLastHalf] = val;\n\t84:             obj[path] = cast(schematype.caster.schema, remainingConds)[pathLastHalf];\n\t86:             obj[path] = val;\n\t169:           obj[path] = schematype.castForQuery(val);\n\t202:         obj[path] = schematype.castForQuery(val);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/connection.js:\n\t8:   , driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native'\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/document.js:\n\t29:  * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n\t53:   var required = schema.requiredPaths();\n\t55:     this.$__.activePaths.require(required[i]);\n\t171:   var paths = Object.keys(this.schema.paths)\n\t172:     , plen = paths.length\n\t176:     var p = paths[ii];\n\t183:     var type = this.schema.paths[p]\n\t184:       , path = p.split('.')\n\t185:       , len = path.length\n\t187:       , curPath = ''\n\t192:       var piece = path[i]\n\t197:         curPath += piece;\n\t198:         if (curPath in fields) break;\n\t199:         curPath += '.';\n\t211:               self.$__.activePaths.default(p);\n\t219:               self.$__.activePaths.default(p);\n\t226:             self.$__.activePaths.default(p);\n\t259:   // handle docs with populated paths\n\t265:       this.populated(item.path, item._docs[id], item);\n\t292:     , path\n\t297:     path = prefix + i;\n\t298:     schema = self.schema.path(path);\n\t304:       init(self, obj[i], doc[i], path + '.');\n\t313:             self.invalidate(e.path, new ValidatorError({\n\t314:               path: e.path,\n\t325:       if (!self.isModified(path)) {\n\t326:         self.$__.activePaths.init(path);\n\t350:     , paths = Object.keys(key)\n\t351:     , len = paths.length\n\t355:     val = this.getValue(paths[i]);\n\t357:       orig[paths[i]] = val.toObject({ depopulate: true })\n\t362:       orig[paths[i]] = val.valueOf();\n\t364:       orig[paths[i]] = val;\n\t403:  * Sets the value of a path, or many paths.\n\t407:  *     // path, value\n\t408:  *     doc.set(path, value)\n\t412:  *         path  : value\n\t413:  *       , path2 : {\n\t414:  *            path  : value\n\t419:  *     doc.set(path, value, Number)\n\t422:  *     doc.set(path, value, String)\n\t425:  *     doc.set(path, value, { strict: false });\n\t427:  * @param {String|Object} path path or object of key/vals to set\n\t434: Document.prototype.set = function (path, val, type, options) {\n\t450:     adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n\t451:     adhocs[path] = Schema.interpretAsType(path, type);\n\t454:   if ('string' !== typeof path) {\n\t457:     if (null === path || undefined === path) {\n\t458:       var _ = path;\n\t459:       path = val;\n\t467:       if (path instanceof Document) path = path._doc;\n\t469:       var keys = Object.keys(path)\n\t471:         , pathtype\n\t476:         pathtype = this.schema.pathType(prefix + key);\n\t477:         if (null != path[key]\n\t479:             && utils.isObject(path[key])\n\t480:             && (!path[key].constructor || 'Object' == utils.getFunctionName(path[key].constructor))\n\t481:             && 'virtual' != pathtype\n\t482:             && !(this.$__path(prefix + key) instanceof MixedSchema)\n\t483:             && !(this.schema.paths[key] && this.schema.paths[key].options.ref)\n\t485:           this.set(path[key], prefix + key, constructing);\n\t487:           if ('real' === pathtype || 'virtual' === pathtype) {\n\t488:             this.set(prefix + key, path[key], constructing);\n\t492:         } else if (undefined !== path[key]) {\n\t493:           this.set(prefix + key, path[key], constructing);\n\t502:   // docschema = new Schema({ path: { nest: 'string' }})\n\t503:   // doc.set('path', obj);\n\t504:   var pathType = this.schema.pathType(path);\n\t505:   if ('nested' == pathType && val && utils.isObject(val) &&\n\t507:     if (!merge) this.setValue(path, null);\n\t508:     this.set(val, path, constructing);\n\t513:   var parts = path.split('.');\n\t515:   if ('adhocOrUndefined' == pathType && strict) {\n\t521:       var subpath = parts.slice(0, i+1).join('.');\n\t522:       schema = this.schema.path(subpath);\n\t524:         // allow changes to sub paths of mixed types\n\t532:         throw new Error(\"Field `\" + path + \"` is not in schema.\");\n\t537:   } else if ('virtual' == pathType) {\n\t538:     schema = this.schema.virtualpath(path);\n\t542:     schema = this.$__path(path);\n\t545:   var pathToMark;\n\t547:   // When using the $set operator the path to the field must already exist.\n\t551:     pathToMark = path;\n\t554:       var subpath = parts.slice(0, i+1).join('.');\n\t555:       if (this.isDirectModified(subpath) // earlier prefixes that are already\n\t557:           || this.get(subpath) === null) {\n\t558:         pathToMark = subpath;\n\t563:     if (!pathToMark) pathToMark = path;\n\t569:     : this.getValue(path);\n\t572:     this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n\t579:     // If the user is trying to set a ref path to a document with\n\t585:       this.populated(path, val);\n\t589:     this.invalidate(e.path, new ValidatorError({\n\t590:       path: e.path,\n\t599:     this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n\t615:     pathToMark, path, constructing, parts, schema, val, priorVal) {\n\t619:   if (undefined === val && !this.isSelected(path)) {\n\t620:     // when a path is not selected in a query, its initial\n\t625:   if (undefined === val && path in this.$__.activePaths.states.default) {\n\t630:   if (!deepEqual(val, priorVal || this.get(path))) {\n\t636:       path in this.$__.activePaths.states.default &&\n\t638:     // a path with a default was $unset on the server\n\t646:  * Handles the actual setting of the value and marking the path modified if appropriate.\n\t654:     pathToMark, path, constructing, parts, schema, val, priorVal) {\n\t661:     this.markModified(pathToMark, val);\n\t669:       // paths that were modified before the array overwrite\n\t670:       this.$__.activePaths.forEach(function(modifiedPath) {\n\t671:         if (modifiedPath.indexOf(path + '.') === 0) {\n\t672:           _this.$__.activePaths.ignore(modifiedPath);\n\t703:  * Gets a raw value from a path (no getters)\n\t705:  * @param {String} path\n\t709: Document.prototype.getValue = function (path) {\n\t710:   return utils.getValue(path, this._doc);\n\t714:  * Sets a raw value for a path (no casting, setters, transformations)\n\t716:  * @param {String} path\n\t721: Document.prototype.setValue = function (path, val) {\n\t722:   utils.setValue(path, val, this._doc);\n\t727:  * Returns the value of a path.\n\t731:  *     // path\n\t737:  * @param {String} path\n\t742: Document.prototype.get = function (path, type) {\n\t745:     adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n\t746:     adhocs[path] = Schema.interpretAsType(path, type);\n\t749:   var schema = this.$__path(path) || this.schema.virtualpath(path)\n\t750:     , pieces = path.split('.')\n\t767:  * Returns the schematype for the given `path`.\n\t769:  * @param {String} path\n\t771:  * @method $__path\n\t775: Document.prototype.$__path = function (path) {\n\t776:   var adhocs = this.$__.adhocPaths\n\t777:     , adhocType = adhocs && adhocs[path];\n\t782:     return this.schema.path(path);\n\t787:  * Marks the path as having pending changes to write to the db.\n\t797:  * @param {String} path the path to mark modified\n\t801: Document.prototype.markModified = function (path) {\n\t802:   this.$__.activePaths.modify(path);\n\t806:  * Returns the list of paths that have been modified.\n\t812: Document.prototype.modifiedPaths = function () {\n\t813:   var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n\t815:   return directModifiedPaths.reduce(function (list, path) {\n\t816:     var parts = path.split('.');\n\t826:  * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n\t836:  * @param {String} [path] optional\n\t841: Document.prototype.isModified = function (path) {\n\t842:   return path\n\t843:     ? !!~this.modifiedPaths().indexOf(path)\n\t844:     : this.$__.activePaths.some('modify');\n\t848:  * Returns true if `path` was directly set and modified, else false.\n\t856:  * @param {String} path\n\t861: Document.prototype.isDirectModified = function (path) {\n\t862:   return (path in this.$__.activePaths.states.modify);\n\t866:  * Checks if `path` was initialized.\n\t868:  * @param {String} path\n\t873: Document.prototype.isInit = function (path) {\n\t874:   return (path in this.$__.activePaths.states.init);\n\t878:  * Checks if `path` was selected in the source query which initialized this document.\n\t887:  * @param {String} path\n\t892: Document.prototype.isSelected = function isSelected (path) {\n\t895:     if ('_id' === path) {\n\t899:     var paths = Object.keys(this.$__.selected)\n\t900:       , i = paths.length\n\t904:     if (1 === i && '_id' === paths[0]) {\n\t910:       cur = paths[i];\n\t916:     if (path in this.$__.selected) {\n\t920:     i = paths.length;\n\t921:     var pathDot = path + '.';\n\t924:       cur = paths[i];\n\t927:       if (0 === cur.indexOf(pathDot)) {\n\t931:       if (0 === pathDot.indexOf(cur + '.')) {\n\t972:   var paths = Object.keys(this.$__.activePaths.states.require).filter(function (path) {\n\t973:     if (!self.isSelected(path) && !self.isModified(path)) return false;\n\t977:   paths = paths.concat(Object.keys(this.$__.activePaths.states.init));\n\t978:   paths = paths.concat(Object.keys(this.$__.activePaths.states.modify));\n\t979:   paths = paths.concat(Object.keys(this.$__.activePaths.states.default));\n\t981:   if (0 === paths.length) {\n\t993:   for (var i = 0; i < paths.length; ++i) {\n\t994:     var path = paths[i];\n\t995:     var val = self.getValue(path);\n\t1000:         paths.push(path + '.' + j);\n\t1004:   paths.forEach(validatePath);\n\t1007:   function validatePath (path) {\n\t1008:     if (validating[path]) return;\n\t1010:     validating[path] = true;\n\t1014:       var p = self.schema.path(path);\n\t1017:       var val = self.getValue(path);\n\t1020:           self.invalidate(path, err, undefined, true);\n\t1063:   var paths = Object.keys(this.$__.activePaths.states.require).filter(function (path) {\n\t1064:     if (!self.isSelected(path) && !self.isModified(path)) return false;\n\t1068:   paths = paths.concat(Object.keys(this.$__.activePaths.states.init));\n\t1069:   paths = paths.concat(Object.keys(this.$__.activePaths.states.modify));\n\t1070:   paths = paths.concat(Object.keys(this.$__.activePaths.states.default));\n\t1074:   paths.forEach(function (path) {\n\t1075:     if (validating[path]) return;\n\t1077:     validating[path] = true;\n\t1079:     var p = self.schema.path(path);\n\t1082:     var val = self.getValue(path);\n\t1085:       self.invalidate(path, err, undefined, true);\n\t1097:  * Marks a path as invalid, causing validation to fail.\n\t1114:  *               path: 'size',\n\t1119:  * @param {String} path the field to invalidate\n\t1120:  * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n\t1125: Document.prototype.invalidate = function (path, err, val) {\n\t1130:   if (this.$__.validationError.errors[path]) return;\n\t1134:       path: path,\n\t1143:   this.$__.validationError.errors[path] = err;\n\t1159:   this.$__.activePaths\n\t1184:   this.$__.activePaths.clear('modify');\n\t1188:   this.schema.requiredPaths().forEach(function (path) {\n\t1189:     self.$__.activePaths.require(path);\n\t1196:  * Returns this documents dirty paths / vals.\n\t1206:   var all = this.$__.activePaths.map('modify', function (path) {\n\t1207:     return { path: path\n\t1208:            , value: self.getValue(path)\n\t1209:            , schema: self.$__path(path) };\n\t1212:   // Sort dirty paths in a flat hierarchy.\n\t1214:     return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n\t1219:     , lastPath\n\t1223:     if (item.path.indexOf(lastPath) !== 0) {\n\t1224:       lastPath = item.path + '.';\n\t1230:         // the `top` array itself and a sub path of `top` are being modified.\n\t1239:   top = lastPath = null;\n\t1288:     , path = (prefix ? prefix + '.' : '') + prop;\n\t1299:           if (!this.$__.getters[path]) {\n\t1321:               return this.get(path);\n\t1324:             compile(subprops, nested, path);\n\t1325:             this.$__.getters[path] = nested;\n\t1328:           return this.$__.getters[path];\n\t1332:           return (this.$__.scope || this).set(path, v);\n\t1340:       , get: function ( ) { return this.get.call(this.$__.scope || this, path); }\n\t1341:       , set: function (v) { return this.set.call(this.$__.scope || this, path, v); }\n\t1362:  * Get active path that were changed and are arrays\n\t1365:  * @method $__getArrayPathsToValidate\n\t1369: Document.prototype.$__getArrayPathsToValidate = function () {\n\t1373:   return this.$__.activePaths\n\t1398:   function docReducer(seed, path) {\n\t1399:     var val = this[path];\n\t1429:   var docs = this.$__getArrayPathsToValidate();\n\t1549:  * - `getters` apply all getters (path and virtual getters)\n\t1553:  * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)\n\t1557:  * Example of only applying path getters\n\t1565:  * Example of applying both path and virtual getters\n\t1667:     // populated paths that we set to a document\n\t1703:     applyGetters(this, ret, 'paths', options);\n\t1704:     // applyGetters for paths will add nested empty objects;\n\t1778:  * @param {String} type either `virtuals` or `paths`\n\t1784:     , paths = Object.keys(schema[type])\n\t1785:     , i = paths.length\n\t1786:     , path\n\t1789:     path = paths[i];\n\t1791:     var parts = path.split('.')\n\t1800:         branch[part] = clone(self.get(path), options);\n\t1897:  *       path: 'notes',\n\t1907:  *     doc.populate(path)               // not executed\n\t1909:  *     doc.populate(path, callback)     // executed\n\t1918:  * Passing the same path a second time will overwrite the previous path options.\n\t1922:  * @param {String|Object} [path] The path to populate or an options object\n\t1941:     // use hash to remove duplicate paths\n\t1944:       pop[res[i].path] = res[i];\n\t1949:     var paths = utils.object.vals(pop);\n\t1951:     this.constructor.populate(this, paths, fn);\n\t1966:  *         path: 'notes',\n\t1981:  * Passing the same path a second time will overwrite the previous path options.\n\t2003:  * Gets _id(s) used during population of the given `path`.\n\t2012:  * If the path was not populated, undefined is returned.\n\t2014:  * @param {String} path\n\t2019: Document.prototype.populated = function (path, val, options) {\n\t2024:     var v = this.$__.populated[path];\n\t2033:     return this.$__.populated[path];\n\t2037:   this.$__.populated[path] = { value: val, options: options };\n\t2042:  * Returns the full path to this document.\n\t2044:  * @param {String} [path]\n\t2047:  * @method $__fullPath\n\t2051: Document.prototype.$__fullPath = function (path) {\n\t2053:   return path || '';\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/index.js:\n\t480: var driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/internal.js:\n\t16:   this.adhocPaths = undefined;\n\t26:   this.activePaths = new ActiveRoster;\n\t30:   this.fullPath = undefined;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/model.js:\n\t298:   delta[op][data.path] = val;\n\t303:   // path excluded from versioning?\n\t305:   if (skipVersioning && skipVersioning[data.path]) return;\n\t342:   else if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n\t343:     // subpath of array\n\t359:   if (delta.$set && delta.$set[data.path]) {\n\t441:     var match = checkDivergentArray(this, data.path, value);\n\t455:     } else if (value._path && value._atomics) {\n\t459:     } else if (value._path && Buffer.isBuffer(value)) {\n\t487:  * @param {String} path\n\t491: function checkDivergentArray (doc, path, array) {\n\t492:   // see if we populated this path\n\t493:   var pop = doc.populated(path, true);\n\t498:     var top = path.split('.')[0];\n\t526:       return path;\n\t601:   var paths\n\t605:     paths = Object.keys(this.$__.shardval)\n\t606:     len = paths.length\n\t609:       where[paths[i]] = this.$__.shardval[paths[i]];\n\t731:   if (schema.path(key)) {\n\t772:     schema._requiredpaths = undefined; // reset just in case Schema#requiredPaths() was called on either schema\n\t1225:  * @param {String} path\n\t1231: Model.where = function where (path, val) {\n\t1641:  * The document returned has no paths marked as modified initially.\n\t2094:  * - path: space delimited path(s) to populate\n\t2105:  *           { path: 'company', match: { x: 1 }, select: 'name' }\n\t2106:  *         , { path: 'notes', options: { limit: 10 }, model: 'override' }\n\t2116:  *       var opts = [{ path: 'company', match: { x: 1 }, select: 'name' }]\n\t2127:  *     Weapon.populate(user, { path: 'weapon', model: 'Weapon' }, function (err, user) {\n\t2134:  *     Weapon.populate(users, { path: 'weapon' }, function (err, users) {\n\t2145:  * @param {Object} options A hash of key/val (path, options) used for population.\n\t2151: Model.populate = function (docs, paths, cb) {\n\t2162:   // normalized paths\n\t2163:   var paths = utils.populate(paths);\n\t2164:   var pending = paths.length;\n\t2171:   // each path has its own query options and must be executed separately\n\t2173:   var path;\n\t2176:     path = paths[i];\n\t2177:     if ('function' === typeof path.model) model = path.model;\n\t2178:     populate(model, docs, path, next);\n\t2197:   var schema = model._getSchema(options.path),\n\t2244:       path: options.path,\n\t2310:     refPath = schema && schema.options && schema.options.refPath,\n\t2313:   if (refPath) {\n\t2316:       modelNames = utils.getValue(refPath, doc);\n\t2374:     i, j, doc, docs, id, len, len2, ret, isDocument, populated, options, path;\n\t2381:     path = options.path;\n\t2390:         ret = utils.getValue(path, doc);\n\t2404:         doc.populated(path, options._docs[id], options);\n\t2436:  * to the original document path.\n\t2449:   var path = o.path;\n\t2454:     utils.setValue(path, rawIds[i], docs[i], function (val) {\n\t2563:  *   if the value of the path is not an array, use findOne rules, else find.\n\t2564:  *   for findOne the results are assigned directly to doc path (including null results).\n\t2637:  * Finds the schema for `path`. This is different than\n\t2638:  * calling `schema.path` as it also resolves paths with\n\t2639:  * positional selectors (something.$.another.$.path).\n\t2641:  * @param {String} path\n\t2646: Model._getSchema = function _getSchema (path) {\n\t2648:     , pathschema = schema.path(path);\n\t2650:   if (pathschema)\n\t2651:     return pathschema;\n\t2657:       , trypath\n\t2660:       trypath = parts.slice(0, p).join('.');\n\t2661:       foundschema = schema.path(trypath);\n\t2671:           // are remaining document paths to look up for casting.\n\t2672:           // Also we need to handle array.$.path since schema.path\n\t2675:           // a path like array.$\n\t2681:               // this is the last path of the selector\n\t2689:   })(path.split('.'), schema)\n\t2705:   if (versioningEnabled && !schema.paths[schema.options.versionKey]) {\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/query.js:\n\t161:   p._path = this._path;\n\t199:  * Specifies a `path` for use with chaining.\n\t221:  * @param {String|Object} [path]\n\t228:  * Specifies the complementary comparison value for paths specified with `where()`\n\t293:  * When called with one argument, the most recent path passed to `where()` is used.\n\t304:  * @param {String} [path]\n\t313:  * When called with one argument, the most recent path passed to `where()` is used.\n\t317:  * @param {String} [path]\n\t326:  * When called with one argument, the most recent path passed to `where()` is used.\n\t330:  * @param {String} [path]\n\t339:  * When called with one argument, the most recent path passed to `where()` is used.\n\t344:  * @param {String} [path]\n\t352:  * When called with one argument, the most recent path passed to `where()` is used.\n\t357:  * @param {String} [path]\n\t365:  * When called with one argument, the most recent path passed to `where()` is used.\n\t370:  * @param {String} [path]\n\t378:  * When called with one argument, the most recent path passed to `where()` is used.\n\t383:  * @param {String} [path]\n\t391:  * When called with one argument, the most recent path passed to `where()` is used.\n\t396:  * @param {String} [path]\n\t404:  * When called with one argument, the most recent path passed to `where()` is used.\n\t418:  * @param {String} [path]\n\t426:  * When called with one argument, the most recent path passed to `where()` is used.\n\t431:  * @param {String} [path]\n\t439:  * When called with one argument, the most recent path passed to `where()` is used.\n\t444:  * @param {String} [path]\n\t454:  * @param {String} [path]\n\t477:  * @param {String} [path]\n\t505:  * @param {String|Object|Function} path\n\t517:  *     query.where(path).within().box()\n\t518:  *     query.where(path).within().circle()\n\t519:  *     query.where(path).within().geometry()\n\t563:  * @param {String} [path]\n\t702:  * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](/docs/api.html#schematype_SchemaType-select).\n\t718:  *     query.select('+path')\n\t886:  * Makes sure _path is set.\n\t888:  * @method _ensurePath\n\t1017:   this._applyPaths();\n\t1066:  * @param {Array} [pop] array of paths used in population\n\t1176:   this._applyPaths();\n\t1340:  * If a string is passed, it must be a space delimited list of path names. The\n\t1341:  * sort order of each path is ascending unless the path name is prefixed with `-`\n\t1447:  * @param {Array} [pop] array of paths used in population\n\t1623:   this._applyPaths();\n\t1720:  * _All paths passed that are not $atomic operations will become $set ops._\n\t1935:  * Finds the schema for `path`. This is different than\n\t1936:  * calling `schema.path` as it also resolves paths with\n\t1937:  * positional selectors (something.$.another.$.path).\n\t1939:  * @param {String} path\n\t1943: Query.prototype._getSchema = function _getSchema (path) {\n\t1944:   return this.model._getSchema(path);\n\t1961:  * of their path schema type.\n\t2024:       hasKeys |= this._walkUpdatePath(val, op);\n\t2030:       // Also, _walkUpdatePath expects an operation, so give it $set since that\n\t2032:       this._walkUpdatePath(ret.$set || {}, '$set');\n\t2044:  * Walk each path of obj and cast its values\n\t2049:  * @param {String} pref - path prefix (internal only)\n\t2050:  * @return {Bool} true if this path has keys to update\n\t2054: Query.prototype._walkUpdatePath = function _walkUpdatePath (obj, op, pref) {\n\t2078:           // path is not in our strict schema\n\t2082:             // ignore paths not specified in schema\n\t2115:         hasKeys |= this._walkUpdatePath(val, op, prefix + key) ||\n\t2125:                  !/real|nested/.test(this.model.schema.pathType(prefix + key));\n\t2154:     // non-existing schema path\n\t2216:  * Specifies paths which should be populated with other documents.\n\t2225:  *         path: 'owner'\n\t2238:  * Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.\n\t2240:  * @param {Object|String} path either the path to populate or an object specifying all parameters\n\t2261:     opts.populate[res[i].path] = res[i];\n\t2345: Query.prototype._applyPaths = function applyPaths () {\n\t2371:   var analyzePath = function(path, type) {\n\t2374:     var plusPath = '+' + path;\n\t2375:     if (fields && plusPath in fields) {\n\t2377:       delete fields[plusPath];\n\t2381:       if (false === exclude && keys.length > 1 && !~keys.indexOf(path)) {\n\t2382:         fields[path] = 1;\n\t2389:     var root = path.split('.')[0];\n\t2392:     ;(type.selected ? selected : excluded).push(path);\n\t2402:     schema.eachPath(function (path, type) {\n\t2403:       if (prefix) path = prefix + '.' + path;\n\t2405:       analyzePath(path, type);\n\t2409:         analyzeSchema(type.schema, path);\n\t2470:   this._applyPaths();\n\t2527:  *     query.where('path').intersects().geometry({\n\t2532:  *     query.where('path').intersects({\n\t2573:  * The argument is assigned to the most recent path passed to `where()`.\n\t2607:  * @param {String} [path]\n\t2637:       // just passing a path\n\t2713:  * @param {String|Array} [path]\n\t2777:  * @param {String} [path]\n\t2811:  * @param {String} [path]\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/queryhelpers.js:\n\t9:  * Prepare a set of path options for query population.\n\t26:  * Prepare a set of path options for query population. This is the MongooseQuery\n\t70:  * Set each path query option to lean\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema.js:\n\t63:   this.paths = {};\n\t64:   this.subpaths = {};\n\t73:   this._requiredpaths = undefined;\n\t75:   this._indexedpaths = undefined;\n\t84:   // build paths\n\t93:   var auto_id = !this.paths['_id'] && (!this.options.noId && this.options._id) && !_idSubDoc;\n\t100:   var autoid = !this.paths['id'] && (!this.options.noVirtualId && this.options.id);\n\t114:     if (!this.paths[createdAt]) {\n\t160:  * Schema as flat paths\n\t169:  * @property paths\n\t172: Schema.prototype.paths;\n\t236:  * Adds key path / schema type pairs to this schema.\n\t256:       throw new TypeError('Invalid value for schema path `'+ prefix + key +'`');\n\t260:       throw new TypeError('Invalid value for schema Array path `'+ prefix + key +'`');\n\t269:         this.path(prefix + key, obj[key]); // mixed type\n\t272:       this.path(prefix + key, obj[key]);\n\t310:  * Gets/sets schema paths.\n\t312:  * Sets a path (if arity 2)\n\t313:  * Gets a path (if arity 1)\n\t317:  *     schema.path('name') // returns a SchemaType\n\t318:  *     schema.path('name', Number) // changes the schemaType of `name` to Number\n\t320:  * @param {String} path\n\t325: Schema.prototype.path = function (path, obj) {\n\t327:     if (this.paths[path]) return this.paths[path];\n\t328:     if (this.subpaths[path]) return this.subpaths[path];\n\t330:     // subpaths?\n\t331:     return /\\.\\d+\\.?.*$/.test(path)\n\t332:       ? getPositionalPath(this, path)\n\t336:   // some path names conflict with document methods\n\t337:   if (reserved[path]) {\n\t338:     throw new Error(\"`\" + path + \"` may not be used as a schema pathname\");\n\t342:   var subpaths = path.split(/\\./)\n\t343:     , last = subpaths.pop()\n\t346:   subpaths.forEach(function(sub, i) {\n\t349:       var msg = 'Cannot set nested path `' + path + '`. '\n\t350:               + 'Parent path `'\n\t351:               + subpaths.slice(0, i).concat([sub]).join('.')\n\t361:   this.paths[path] = Schema.interpretAsType(path, obj);\n\t368:  * @param {String} path\n\t373: Schema.interpretAsType = function (path, obj) {\n\t389:     return new MongooseTypes.Mixed(path, obj);\n\t399:       return new MongooseTypes.DocumentArray(path, cast, obj);\n\t407:       return new MongooseTypes.DocumentArray(path, new Schema(cast), obj);\n\t410:     return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj);\n\t429:     throw new TypeError('Undefined type `' + name + '` at `' + path +\n\t434:   return new MongooseTypes[name](path, obj);\n\t438:  * Iterates the schemas paths similar to Array#forEach.\n\t440:  * The callback is passed the pathname and schemaType as arguments on each iteration.\n\t447: Schema.prototype.eachPath = function (fn) {\n\t448:   var keys = Object.keys(this.paths)\n\t452:     fn(keys[i], this.paths[keys[i]]);\n\t459:  * Returns an Array of path strings that are required by this schema.\n\t465: Schema.prototype.requiredPaths = function requiredPaths () {\n\t466:   if (this._requiredpaths) return this._requiredpaths;\n\t468:   var paths = Object.keys(this.paths)\n\t469:     , i = paths.length\n\t473:     var path = paths[i];\n\t474:     if (this.paths[path].isRequired) ret.push(path);\n\t477:   return this._requiredpaths = ret;\n\t487: Schema.prototype.indexedPaths = function indexedPaths () {\n\t488:   if (this._indexedpaths) return this._indexedpaths;\n\t490:   return this._indexedpaths = this.indexes();\n\t494:  * Returns the pathType of `path` for this schema.\n\t496:  * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n\t498:  * @param {String} path\n\t503: Schema.prototype.pathType = function (path) {\n\t504:   if (path in this.paths) return 'real';\n\t505:   if (path in this.virtuals) return 'virtual';\n\t506:   if (path in this.nested) return 'nested';\n\t507:   if (path in this.subpaths) return 'real';\n\t509:   if (/\\.\\d+\\.|\\.\\d+$/.test(path) && getPositionalPath(this, path)) {\n\t520: function getPositionalPath (self, path) {\n\t521:   var subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n\t522:   if (subpaths.length < 2) {\n\t523:     return self.paths[subpaths[0]];\n\t526:   var val = self.path(subpaths[0]);\n\t529:   var last = subpaths.length - 1\n\t530:     , subpath\n\t533:   for (; i < subpaths.length; ++i) {\n\t534:     subpath = subpaths[i];\n\t536:     if (i === last && val && !val.schema && !/\\D/.test(subpath)) {\n\t546:     // ignore if its just a position segment: path.0.subpath\n\t547:     if (!/\\D/.test(subpath)) continue;\n\t554:     val = val.schema.path(subpath);\n\t557:   return self.subpaths[path] = val;\n\t827:     var key, path, index, field, isObject, options, type;\n\t828:     var keys = Object.keys(schema.paths);\n\t832:       path = schema.paths[key];\n\t834:       if (path instanceof MongooseTypes.DocumentArray) {\n\t835:         collectIndexes(path.schema, key + '.');\n\t837:         index = path._index;\n\t864:       fixSubIndexPaths(schema, prefix);\n\t879:    * These indexes need their paths prefixed properly.\n\t884:   function fixSubIndexPaths (schema, prefix) {\n\t938: Schema.prototype.virtualpath = function (name) {\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schematype.js:\n\t14:  * @param {String} path\n\t20: function SchemaType (path, options, instance) {\n\t21:   this.path = path;\n\t64:  *     schema.path('mixed').default(function () {\n\t72:  *     schema.path('mixed').default({});\n\t107:  *     Schema.path('my.path').index(true);\n\t108:  *     Schema.path('my.date').index({ expires: 60 });\n\t109:  *     Schema.path('my.path').index({ unique: true, sparse: true });\n\t134:  *     Schema.path('name').index({ unique: true });\n\t160:  *      Schema.path('name').index({text : true});\n\t183:  *     Schema.path('name').index({ sparse: true });\n\t216:  *     s.path('name').set(capitalize)\n\t252:  *         return schematype.path + ' is required';\n\t296:  *     s.path('born').get(dob)\n\t320:  *         return schematype.path + ' is required';\n\t322:  *         return schematype.path + ' is not';\n\t351:  * Adds validator(s) for this document path.\n\t367:  *     var custom = [validator, 'Uh oh, {PATH} does not equal \"something\".']\n\t381:  *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');\n\t385:  * From the examples above, you may have noticed that error messages support baseic templating. There are a few other template keywords besides `{PATH}` and `{VALUE}` too. To find out more, details are available [here](#error_messages_MongooseError-messages)\n\t391:  *     schema.path('name').validate(function (value, respond) {\n\t396: *      }, '{PATH} failed validation.');\n\t469:  *     var s = new Schema({ born: { type: Date, required: '{PATH} is required!' })\n\t471:  *     // or through the path API\n\t473:  *     Schema.path('name').required(true);\n\t477:  *     Schema.path('name').required(true, 'grrr :( ');\n\t502:     // no validation when this path wasn't selected in the query.\n\t504:         !this.isSelected(self.path) &&\n\t505:         !this.isModified(self.path)) return true;\n\t612:  * Sets default `select()` behavior for this path.\n\t614:  * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.\n\t644:     , path = this.path\n\t666:     validatorProperties.path = path;\n\t702:     , path = this.path\n\t724:     validatorProperties.path = path;\n\t752:   // fast path\n\t755:   if (!ref && doc && doc.$__fullPath) {\n\t759:     var path = doc.$__fullPath(self.path);\n\t761:     ref = owner.populated(path);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/statemachine.js:\n\t16:   this.paths = {};\n\t26:  * place their path argument into the given state.\n\t53:     // Changes the `path`'s state to `state`.\n\t54:     ctor.prototype[state] = function (path) {\n\t55:       this._changeState(path, state);\n\t65:  * - `require(path)`\n\t66:  * - `modify(path)`\n\t67:  * - `init(path)`\n\t72: StateMachine.prototype._changeState = function _changeState (path, nextState) {\n\t73:   var prevBucket = this.states[this.paths[path]];\n\t74:   if (prevBucket) delete prevBucket[path];\n\t76:   this.paths[path] = nextState;\n\t77:   this.states[nextState][path] = true;\n\t87:     , path\n\t90:     path = keys[i];\n\t91:     delete this.states[state][path];\n\t92:     delete this.paths[path];\n\t97:  * Checks to see if at least one path is in the states passed in via `arguments`\n\t131:     var paths = states.reduce(function (paths, state) {\n\t132:       return paths.concat(Object.keys(self.states[state]));\n\t135:     return paths[iterMethod](function (path, i, paths) {\n\t136:       return callback(path, i, paths);\n\t142:  * Iterates over the paths that belong to one of the parameter states.\n\t145:  * this.forEach(state1, fn);         // iterates over all paths in state1\n\t146:  * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n\t147:  * this.forEach(fn);                 // iterates over all paths in all states\n\t161:  * Maps over the paths that belong to one of the parameter states.\n\t164:  * this.forEach(state1, fn);         // iterates over all paths in state1\n\t165:  * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n\t166:  * this.forEach(fn);                 // iterates over all paths in all states\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/utils.js:\n\t9:   , mpath = require('mpath')\n\t505: function PopulateOptions (path, select, match, options, model) {\n\t506:   this.path = path;\n\t524: exports.populate = function populate (path, select, model, match, options) {\n\t531:     if (path instanceof PopulateOptions) {\n\t532:       return [path];\n\t535:     if (Array.isArray(path)) {\n\t536:       return path.map(function(o){\n\t541:     if (exports.isObject(path)) {\n\t542:       match = path.match;\n\t543:       options = path.options;\n\t544:       select = path.select;\n\t545:       model = path.model;\n\t546:       path = path.path;\n\t554:   if ('string' != typeof path) {\n\t555:     throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');\n\t559:   var paths = path.split(' ');\n\t560:   for (var i = 0; i < paths.length; ++i) {\n\t561:     ret.push(new PopulateOptions(paths[i], select, match, options, model));\n\t568:  * Return the value of `obj` at the given `path`.\n\t570:  * @param {String} path\n\t574: exports.getValue = function (path, obj, map) {\n\t575:   return mpath.get(path, obj, '_doc', map);\n\t579:  * Sets the value of `obj` at the given `path`.\n\t581:  * @param {String} path\n\t586: exports.setValue = function (path, val, obj, map) {\n\t587:   mpath.set(path, val, obj, '_doc', map);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/virtualtype.js:\n\t17:   this.path = name;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/error/cast.js:\n\t16: function CastError (type, value, path) {\n\t17:   MongooseError.call(this, 'Cast to ' + type + ' failed for value \"' + value + '\" at path \"' + path + '\"');\n\t22:   this.path = path;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/error/divergentArray.js:\n\t14: function DivergentArrayError (paths) {\n\t20:           + 'path(s) would have been modified unsafely:\\n'\n\t21:           + '  ' + paths.join('\\n  ') + '\\n'\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/error/messages.js:\n\t7:  *     mongoose.Error.messages.String.enum  = \"Your custom message for {PATH}.\";\n\t11:  * - `{PATH}` is replaced with the invalid document path\n\t27: msg.general.default = \"Validator failed for path `{PATH}` with value `{VALUE}`\";\n\t28: msg.general.required = \"Path `{PATH}` is required.\";\n\t31: msg.Number.min = \"Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).\";\n\t32: msg.Number.max = \"Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).\";\n\t35: msg.Date.min = \"Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).\";\n\t36: msg.Date.max = \"Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).\";\n\t39: msg.String.enum = \"`{VALUE}` is not a valid enum value for path `{PATH}`.\";\n\t40: msg.String.match = \"Path `{PATH}` is invalid ({VALUE}).\";\n\t41: msg.String.minlength = \"Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).\";\n\t42: msg.String.maxlength = \"Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).\";\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/error/validator.js:\n\t28:   this.path = properties.path;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/array.js:\n\t60:       this.caster.path = key;\n\t77:     return new MongooseArray(arr, self.path, this);\n\t136:       var indexes = doc.schema.indexedPaths();\n\t139:         var pathIndex = indexes[i][0][this.path];\n\t140:         if ('2dsphere' === pathIndex || '2d' === pathIndex) {\n\t147:       value = new MongooseArray(value, this.path, doc);\n\t157:         throw new CastError(e.type, value, this.path);\n\t166:       doc.markModified(this.path);\n\t317:       o[this.path] = v;\n\t318:       return cast(this.casterConstructor.schema, o)[this.path];\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/boolean.js:\n\t11:  * @param {String} path\n\t17: function SchemaBoolean (path, options) {\n\t18:   SchemaType.call(this, path, options);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/buffer.js:\n\t78:     // setting a populated path\n\t82:       throw new CastError('buffer', value, this.path);\n\t86:     // path to a plain object; cast to the Model used in\n\t88:     var path = doc.$__fullPath(this.path);\n\t90:     var pop = owner.populated(path, true);\n\t107:       value = new MongooseBuffer(value, [this.path, doc]);\n\t112:     var ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n\t123:     var ret = new MongooseBuffer(value, [this.path, doc]);\n\t127:   throw new CastError('buffer', value, this.path);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/date.js:\n\t60:  *     schema.path('createdAt').expires('7d');\n\t104:  *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n\t109:  *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n\t159:  *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n\t164:  *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n\t227:   throw new CastError('date', value, this.path);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/documentarray.js:\n\t48:   var path = this.path;\n\t54:     return new MongooseDocumentArray(arr, path, this);\n\t167:     // the db and the path isn't an array in the document\n\t169:       doc.markModified(this.path);\n\t175:     value = new MongooseDocumentArray(value, this.path, doc);\n\t188:         selected || (selected = scopePaths(this, doc.$__.selected, init));\n\t215:  * Scopes paths selected in a query to this array.\n\t218:  * @param {DocumentArray} array - the array to scope `fields` paths\n\t223: function scopePaths (array, fields, init) {\n\t226:   var path = array.path + '.'\n\t235:     if (0 === key.indexOf(path)) {\n\t237:       selected[key.substring(path.length)] = fields[key];\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/mixed.js:\n\t12:  * @param {String} path\n\t18: function Mixed (path, options) {\n\t34:   SchemaType.call(this, path, options);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/number.js:\n\t68:  *     var min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n\t73:  *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).\n\t121:  *     var max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n\t126:  *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).\n\t183:     // setting a populated path\n\t187:       throw new CastError('number', value, this.path);\n\t191:     // path to a plain object; cast to the Model used in\n\t193:     var path = doc.$__fullPath(this.path);\n\t195:     var pop = owner.populated(path, true);\n\t217:   throw new CastError('number', value, this.path);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/objectid.js:\n\t93:     // setting a populated path\n\t97:       throw new CastError('ObjectId', value, this.path);\n\t101:     // path to a plain object; cast to the Model used in\n\t103:     var path = doc.$__fullPath(this.path);\n\t105:     var pop = owner.populated(path, true);\n\t124:       throw new CastError('ObjectId', value, this.path);\n\t128:   throw new CastError('ObjectId', value, this.path);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/string.js:\n\t51:  *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.\n\t59:  *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'\n\t65:  *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`\n\t200:  *     var minlength = [10, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum length ({MINLENGTH}).'];\n\t205:  *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).\n\t253:  *     var maxlength = [10, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];\n\t258:  *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (10).\n\t301:  *       console.error(String(err)) // \"ValidationError: Path `name` is invalid (I am invalid).\"\n\t381:     // setting a populated path\n\t385:       throw new CastError('string', value, this.path);\n\t389:     // path to a plain object; cast to the Model used in\n\t391:     var path = doc.$__fullPath(this.path);\n\t393:     var pop = owner.populated(path, true);\n\t415:   throw new CastError('string', value, this.path);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/services/updateValidators.js:\n\t27:       var paths = Object.keys(castedDoc[keys[i]]);\n\t28:       var numPaths = paths.length;\n\t29:       for (var j = 0; j < numPaths; ++j) {\n\t31:           updatedValues[paths[j]] = castedDoc[keys[i]][paths[j]];\n\t33:           updatedValues[paths[j]] = undefined;\n\t35:         updatedKeys[paths[j]] = true;\n\t44:     paths = Object.keys(query._conditions);\n\t45:     numPaths = keys.length;\n\t46:     for (var i = 0; i < numPaths; ++i) {\n\t47:       if (typeof query._conditions[paths[i]] === 'Object') {\n\t48:         var conditionKeys = Object.keys(query._conditions[paths[i]]);\n\t61:       updatedKeys[paths[i]] = true;\n\t65:       schema.eachPath(function(path, schemaType) {\n\t66:         if (path === '_id') {\n\t71:         if (!updatedKeys[path] && typeof def !== 'undefined') {\n\t73:           castedDoc.$setOnInsert[path] = def;\n\t74:           updatedValues[path] = def;\n\t87:         schema.path(updates[i]).doValidate(\n\t107:           err.errors[validationErrors[i].path] = validationErrors[i];\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/types/array.js:\n\t20:  * @param {String} path\n\t27: function MongooseArray (values, path, doc) {\n\t35:   arr._path = path;\n\t39:     arr._schema = doc.schema.path(path);\n\t88:       populated = owner.populated(this._path, true);\n\t121:    * @param {String} embeddedPath the path which changed in the embeddedDoc\n\t126:   _markModified: function (elem, embeddedPath) {\n\t128:       , dirtyPath;\n\t131:       dirtyPath = this._path;\n\t134:         if (null != embeddedPath) {\n\t136:           dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;\n\t139:           dirtyPath = dirtyPath + '.' + elem;\n\t142:       parent.markModified(dirtyPath);\n\t176:     // $atomic op on a single path\n\t461:       , cur = this._parent.get(this._path)\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/types/buffer.js:\n\t6: var driver = global.MONGOOSE_DRIVER_PATH || '../drivers/node-mongodb-native';\n\t39:   var path;\n\t44:     path = encode[0];\n\t57:     , _path: { value: path }\n\t61:   if (doc && \"string\" === typeof path) {\n\t63:         value: doc.schema.path(path)\n\t108:       parent.markModified(this._path);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/types/documentarray.js:\n\t16:  * @param {String} path the path to this array\n\t24: function MongooseDocumentArray (values, path, doc) {\n\t35:   arr._path = path;\n\t39:     arr._schema = doc.schema.path(path);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/types/embedded.js:\n\t51:  * @param {String} path the path which changed\n\t55: EmbeddedDocument.prototype.markModified = function (path) {\n\t58:   this.$__.activePaths.modify(path);\n\t65:     this.__parentArray._markModified(this, path);\n\t157:  * Marks a path as invalid, causing validation to fail.\n\t159:  * @param {String} path the field to invalidate\n\t160:  * @param {String|Error} err error which states the reason `path` was invalid\n\t165: EmbeddedDocument.prototype.invalidate = function (path, err, val, first) {\n\t172:   var parentPath = this.__parentArray._path;\n\t173:   var fullPath = [parentPath, index, path].join('.');\n\t179:     this.__parent.invalidate(fullPath, err, val);\n\t181:     this.__parent.invalidate(fullPath, err);\n\t211:  * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.\n\t213:  * @param {String} [path]\n\t216:  * @method $__fullPath\n\t220: EmbeddedDocument.prototype.$__fullPath = function (path) {\n\t221:   if (!this.$__.fullPath) {\n\t223:     if (!parent.__parent) return path;\n\t225:     var paths = [];\n\t227:       paths.unshift(parent.__parentArray._path);\n\t231:     this.$__.fullPath = paths.join('.');\n\t239:   return path\n\t240:     ? this.$__.fullPath + '.' + path\n\t241:     : this.$__.fullPath;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/lib/types/objectid.js:\n\t6: var driver = global.MONGOOSE_DRIVER_PATH || '../drivers/node-mongodb-native';\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/hooks-fixed/README.md:\n\t30:   , Document = require('./path/to/some/document/constructor');\n\t63:   , Document = require('./path/to/some/document/constructor');\n\t122: Document.hook('set', function (path, val) {\n\t123:   this[path] = val;\n\t132: Document.pre('set', function (next, path, val) {\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/hooks-fixed/test.js:\n\t329:     A.hook('set', function (path, val) {\n\t330:       this[path] = val;\n\t332:     A.pre('set', function (next, path, val) {\n\t333:       path.should.equal('hello');\n\t345: //    A.hook('set', function (path, val) {\n\t346: //      this[path] = val;\n\t360:     A.hook('set', function (path, val) {\n\t361:       this[path] = val;\n\t363:     A.post('set', function (next, path, val) {\n\t364:       path.should.equal('hello');\n\t375: //    A.hook('set', function (path, val) {\n\t376: //      this[path] = val;\n\t390:     A.hook('set', function (path, val) {\n\t391:       this[path] = val;\n\t394:     A.pre('set', function (next, path, val) {\n\t397:     A.pre('set', function (next, path, val) {\n\t398:       assert.equal(path, 'foo');\n\t402:     A.pre('set', function (next, path, val, opt) {\n\t403:       assert.equal(path, 'rock');\n\t416:     A.hook('set', function (path, val) {\n\t417:       this[path] = val;\n\t419:     A.pre('set', function (next, path, val) {\n\t422:     A.post('set', function (next, path, val) {\n\t423:       path.should.equal('foo');\n\t440:     A.hook('set', function (path, val, opts) {\n\t441:       this[path] = val;\n\t443:     A.pre('set', function (next, path, val, opts) {\n\t455:     A.hook('set', function (path, val) {\n\t457:       this[path] = val;\n\t460:     A.pre('set', function (next, path, val) {\n\t464:     A.pre('set', true, function (next, done, path, val) {\n\t472:     A.pre('set', function (next, path, val) {\n\t476:     A.pre('set', true, function (next, done, path, val) {\n\t492:     A.hook('set', function (path, val) {\n\t493:       this[path] = val;\n\t494:       if (path === 'hello') counter.should.equal(1);\n\t495:       if (path === 'foo') counter.should.equal(2);\n\t497:     A.pre('set', true, function (next, done, path, val) {\n\t565:     A.hook('set', function (path, val, fn) {\n\t567:       this[path] = val;\n\t570:     A.pre('set', true, function (next, done, path, val, fn) {\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/HISTORY.md:\n\t9: - Optimized query path for performance, moving Object.defineProperty outside of constructors.\n\t935: * Cleanup of bson.js to remove duplicated code paths\n\t937: * Removing require.paths to make tests work with the 0.5.X branch\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/README.md:\n\t91: Let's boot up a MongoDB server instance. Download the right MongoDB version from [MongoDB](http://www.mongodb.org), open a new shell or command line and ensure the **mongod** command is in the shell or command line path. Now let's create a database directory (in our case under **/data**).\n\t94: mongod --dbpath=/data --port 27017\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/README.md:\n\t85: Let's boot up a MongoDB server instance. Download the right MongoDB version from [MongoDB](http://www.mongodb.org), open a new shell or command line and ensure the **mongod** command is in the shell or command line path. Now let's create a database directory (in our case under **/data**).\n\t88: mongod --dbpath=/data --port 27017\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/TESTING.md:\n\t6: mongod --dbpath=./db\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/cursor.js:\n\t204:     // Otherwise fall back to regular find path\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/mongos_manager.js:\n\t4:   , path = require('path')\n\t42:   // Set default db path if none set\n\t43:   var pidfilepath = mongosOptions.pidfilepath = mongosOptions.pidfilepath || path.join(path.resolve('data'), f(\"data-%d\", port));\n\t44:   var logpath = mongosOptions.logpath = mongosOptions.logpath || path.join(path.resolve('data'), f(\"data-%d.log\", port));\n\t66:   // Add the file path\n\t67:   pidfilepath = mongosOptions.pidfilepath = f(\"%s/mongos-%s.pid\", pidfilepath, port);\n\t107:           pid = fs.readFileSync(pidfilepath, 'ascii').trim();          \n\t123:             pid = fs.readFileSync(pidfilepath, 'ascii').trim();          \n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/replset_manager.js:\n\t4:   , path = require('path')\n\t60:   // DbPath\n\t61:   var dbpath = replsetOptions.dbpath = replsetOptions.dbpath || path.resolve('data');\n\t343:     // Remove db path and recreate it\n\t346:         rimraf.sync(dbpath);\n\t347:         mkdirp.sync(dbpath);\n\t363:         opts.dbpath = opts.dbpath ? opts.dbpath + f(\"/data-%s\", opts.port) : null;\n\t364:         opts.logpath = opts.logpath ? opts.logpath + f(\"/data-%s.log\", opts.port) : null;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/server_manager.js:\n\t4:   , path = require('path')\n\t61:   // Set default db path if none set\n\t62:   var dbpath = serverOptions.dbpath = serverOptions.dbpath || path.join(path.resolve('data'), f(\"data-%d\", port));\n\t63:   var logpath = serverOptions.logpath = serverOptions.logpath || path.join(path.resolve('data'), f(\"data-%d.log\", port));\n\t73:   Object.defineProperty(this, 'dbpath', {\n\t74:     enumerable:true, get: function() { return dbpath; }\n\t77:   Object.defineProperty(this, 'logpath', {\n\t78:     enumerable:true, get: function() { return logpath; }\n\t115:     , 'journal', 'notablescan', 'noscripting', 'repairpath', 'repair'\n\t118:     , 'dbpath', 'sysinfo', 'cpu', 'profile', 'slowms', 'rest'\n\t121:     , 'keyFile', 'pidfilepath', 'timeStampFormat', 'logappend'\n\t122:     , 'syslogFacility', 'syslog', 'logpath', 'maxConns', 'bind_ip', 'port'\n\t190:             pid = fs.readFileSync(path.join(dbpath, \"mongod.lock\"), 'ascii').trim();\n\t249:         rimraf.sync(serverOptions.dbpath);\n\t250:         mkdirp.sync(serverOptions.dbpath);        \n\t255:     if(fs.existsSync(path.join(dbpath, \"mongod.lock\"))) {\n\t256:       fs.unlinkSync(path.join(dbpath, \"mongod.lock\"));\n\t289:   var locateLockFile = function(dbpath) {\n\t296:           , pid: fs.readFileSync(path.join(dbpath, possibleLockFiles[i]), 'ascii').trim()\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/sharding_manager.js:\n\t4:   , path = require('path')\n\t70:   var dbpath = mongosOptions.dbpath;\n\t71:   var logpath = mongosOptions.logpath;\n\t109:         opts.dbpath = dbpath + f(\"/data-%s\", initiallConfigPort);\n\t110:         opts.logpath = logpath + f(\"/data-%s.log\", initiallConfigPort);\n\t141:         opts.dbpath = dbpath;\n\t142:         opts.logpath = logpath;\n\t181:         opts.pidfilepath = f(\"%s\", dbpath);\n\t182:         opts.logpath = f(\"%s/mongos-%s.log\", logpath, initiallMongosPort);\n\t260:             rimraf.sync(dbpath);\n\t261:             mkdirp.sync(dbpath);\n\t272:       rimraf.sync(dbpath);\n\t273:       mkdirp.sync(dbpath);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/browser_build/bson.js:\n\t30: function normalize(path) {\n\t31:   var ret = [], parts = path.split('/'), cur, prev;\n\t52: function dirname(path) {\n\t53:   return path && path.substr(0, path.lastIndexOf(\"/\")) || \".\";\n\t2705:   , './long'].forEach(function (path) {\n\t2706:   \tvar module = require('./' + path);\n\t2728: ].forEach(function (path) {\n\t2729:     \tvar module = require('./' + path);\n\t2753:     , '././bson'].forEach(function (path) {\n\t2754:     \tvar module = require('./' + path);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/build/bson.target.mk:\n\t118: # Copy this to the executable output path.\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/build/Makefile:\n\t11: abs_srcdir := $(abspath $(srcdir))\n\t28: # as they reach into the src/ directory for data with relative paths.\n\t30: abs_builddir := $(abspath $(builddir))\n\t35: abs_obj := $(abspath $(obj))\n\t79: # http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces\n\t93: # ccache or distcc lose the path to the target, so we convert a rule of\n\t97: #   path/to/foobar.o: DEP1 DEP2\n\t114: # Fixup path as in (1).\n\t171: # the local, absolute paths used on the link command-line.\n\t186: # $LD_LIBRARY_PATH), without triggering make substitution.\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/ext/wscript:\n\t3: from os.path import exists \n\t24:   # conf.check(lib='node', libpath=['/usr/lib', '/usr/local/lib'], uselib_store='NODE')\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/lib/bson/index.js:\n\t18:   , './long'].forEach(function (path) {\n\t19:   \tvar module = require('./' + path);\n\t41: ].forEach(function (path) {\n\t42:     \tvar module = require('./' + path);\n\t66:     , '././bson'].forEach(function (path) {\n\t67:     \tvar module = require('./' + path);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/CHANGELOG.md:\n\t166:  - fix \"not all control paths return a value\" compile warning on some platforms\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/include_dirs.js:\n\t1: console.log(require('path').relative('.', __dirname));\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/README.md:\n\t92: Pull in the path to **NAN** in your *binding.gyp* so that you can use `#include <nan.h>` in your *.cpp* files:\n\t100: This works like a `-I<path-to-NAN>` when compiling your addon.\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/build/kerberos.target.mk:\n\t133: # Copy this to the executable output path.\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/build/Makefile:\n\t11: abs_srcdir := $(abspath $(srcdir))\n\t28: # as they reach into the src/ directory for data with relative paths.\n\t30: abs_builddir := $(abspath $(builddir))\n\t35: abs_obj := $(abspath $(obj))\n\t79: # http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces\n\t93: # ccache or distcc lose the path to the target, so we convert a rule of\n\t97: #   path/to/foobar.o: DEP1 DEP2\n\t114: # Fixup path as in (1).\n\t171: # the local, absolute paths used on the link command-line.\n\t186: # $LD_LIBRARY_PATH), without triggering make substitution.\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/CHANGELOG.md:\n\t166:  - fix \"not all control paths return a value\" compile warning on some platforms\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/include_dirs.js:\n\t1: console.log(require('path').relative('.', __dirname));\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/README.md:\n\t92: Pull in the path to **NAN** in your *binding.gyp* so that you can use `#include <nan.h>` in your *.cpp* files:\n\t100: This works like a `-I<path-to-NAN>` when compiling your addon.\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/index.js:\n\t1: var path = require('path');\n\t24:     p = path.resolve(p);\n\t33:                 mkdirP(path.dirname(p), opts, function (er, made) {\n\t67:     p = path.resolve(p);\n\t76:                 made = sync(path.dirname(p), opts, made);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/readme.markdown:\n\t46: `opts.fs`. Your implementation should have `opts.fs.mkdir(path, mode, cb)` and\n\t47: `opts.fs.stat(path, cb)`.\n\t60: `opts.fs`. Your implementation should have `opts.fs.mkdirSync(path, mode)` and\n\t61: `opts.fs.statSync(path)`.\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/bin/cmd.js:\n\t16: var paths = argv._.slice();\n\t20:     if (paths.length === 0) return;\n\t21:     var p = paths.shift();\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/chmod.js:\n\t2: var path = require('path');\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/clobber.js:\n\t2: var path = require('path');\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/mkdirp.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/opts_fs.js:\n\t2: var path = require('path');\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/opts_fs_sync.js:\n\t2: var path = require('path');\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/perm.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/perm_sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/race.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/rel.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/return.js:\n\t2: var path = require('path');\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/return_sync.js:\n\t2: var path = require('path');\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/root.js:\n\t2: var path = require('path');\n\t8:     var file = path.resolve('/');\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/umask.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/umask_sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/bin.js:\n\t21:   log('Usage: rimraf <path>')\n\t23:   log('  Deletes all files and folders at \"path\" recursively.')\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/README.md:\n\t25: command `rimraf <path>` which is useful for cross platform support.\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/rimraf.js:\n\t4: var path = require(\"path\")\n\t131:       rimraf(path.join(p, f), function (er) {\n\t175:     rimrafSync(path.join(p, f))\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/test/test-async.js:\n\t2:   , path = require(\"path\")\n\t3: rimraf(path.join(__dirname, \"target\"), function (er) {\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/test/test-sync.js:\n\t2:   , path = require(\"path\")\n\t3: rimraf.sync(path.join(__dirname, \"target\"))\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/readable-stream/lib/_stream_transform.js:\n\t51: // a pathological inflate type of transform can cause excessive buffering\n\t57: // such a pathological inflating mechanism, there'd be no way to tell\n\t61: // However, even in such a pathological case, only a single written chunk\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/readable-stream/node_modules/isarray/build/build.js:\n\t3:  * Require the given path.\n\t5:  * @param {String} path\n\t10: function require(path, parent, orig) {\n\t11:   var resolved = require.resolve(path);\n\t15:     orig = orig || path;\n\t18:     err.path = orig;\n\t51:  * Resolve `path`.\n\t55:  *   - PATH/index.js\n\t56:  *   - PATH.js\n\t57:  *   - PATH\n\t59:  * @param {String} path\n\t60:  * @return {String} path or null\n\t64: require.resolve = function(path) {\n\t65:   if (path.charAt(0) === '/') path = path.slice(1);\n\t66:   var index = path + '/index.js';\n\t68:   var paths = [\n\t69:     path,\n\t70:     path + '.js',\n\t71:     path + '.json',\n\t72:     path + '/index.js',\n\t73:     path + '/index.json'\n\t76:   for (var i = 0; i < paths.length; i++) {\n\t77:     var path = paths[i];\n\t78:     if (require.modules.hasOwnProperty(path)) return path;\n\t87:  * Normalize `path` relative to the current path.\n\t90:  * @param {String} path\n\t95: require.normalize = function(curr, path) {\n\t98:   if ('.' != path.charAt(0)) return path;\n\t101:   path = path.split('/');\n\t103:   for (var i = 0; i < path.length; ++i) {\n\t104:     if ('..' == path[i]) {\n\t106:     } else if ('.' != path[i] && '' != path[i]) {\n\t107:       segs.push(path[i]);\n\t115:  * Register module at `path` with callback `definition`.\n\t117:  * @param {String} path\n\t122: require.register = function(path, definition) {\n\t123:   require.modules[path] = definition;\n\t142:  * Return a require function relative to the `parent` path.\n\t168:   function localRequire(path) {\n\t169:     var resolved = localRequire.resolve(path);\n\t170:     return require(resolved, parent, path);\n\t177:   localRequire.resolve = function(path) {\n\t178:     var c = path.charAt(0);\n\t179:     if ('/' == c) return path.slice(1);\n\t180:     if ('.' == c) return require.normalize(p, path);\n\t188:     path = segs.slice(0, i + 1).join('/') + '/deps/' + path;\n\t189:     return path;\n\t193:    * Check if module is defined at `path`.\n\t196:   localRequire.exists = function(path) {\n\t197:     return require.modules.hasOwnProperty(localRequire.resolve(path));\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mpath/package.json:\n\t2:   \"name\": \"mpath\",\n\t4:   \"description\": \"{G,S}et object values using MongoDB path notation\",\n\t11:     \"url\": \"git://github.com/aheckmann/mpath.git\"\n\t15:     \"path\",\n\t27:   \"readme\": \"#mpath\\n\\n{G,S}et javascript object values using MongoDB-like path notation.\\n\\n###Getting\\n\\n```js\\nvar mpath = require('mpath');\\n\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.get('comments.1.title', obj) // 'exciting!'\\n```\\n\\n`mpath.get` supports array property notation as well.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.get('comments.title', obj) // ['funny', 'exciting!']\\n```\\n\\nArray property and indexing syntax, when used together, are very powerful.\\n\\n```js\\nvar obj = {\\n  array: [\\n      { o: { array: [{x: {b: [4,6,8]}}, { y: 10} ] }}\\n    , { o: { array: [{x: {b: [1,2,3]}}, { x: {z: 10 }}, { x: 'Turkey Day' }] }}\\n    , { o: { array: [{x: {b: null }}, { x: { b: [null, 1]}}] }}\\n    , { o: { array: [{x: null }] }}\\n    , { o: { array: [{y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ];\\n}\\n\\nvar found = mpath.get('array.o.array.x.b.1', obj);\\n\\nconsole.log(found); // prints..\\n\\n    [ [6, undefined]\\n    , [2, undefined, undefined]\\n    , [null, 1]\\n    , [null]\\n    , [undefined]\\n    , [undefined, undefined, undefined]\\n    , undefined\\n    ]\\n\\n```\\n\\n#####Field selection rules:\\n\\nThe following rules are iteratively applied to each `segment` in the passed `path`. For example:\\n\\n```js\\nvar path = 'one.two.14'; // path\\n'one' // segment 0\\n'two' // segment 1\\n14    // segment 2\\n```\\n\\n- 1) when value of the segment parent is not an array, return the value of `parent.segment`\\n- 2) when value of the segment parent is an array\\n  - a) if the segment is an integer, replace the parent array with the value at `parent[segment]`\\n  - b) if not an integer, keep the array but replace each array `item` with the value returned from calling `get(remainingSegments, item)` or undefined if falsey.\\n\\n#####Maps\\n\\n`mpath.get` also accepts an optional `map` argument which receives each individual found value. The value returned from the `map` function will be used in the original found values place.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.get('comments.title', obj, function (val) {\\n  return 'funny' == val\\n    ? 'amusing'\\n    : val;\\n});\\n// ['amusing', 'exciting!']\\n```\\n\\n###Setting\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.1.title', 'hilarious', obj)\\nconsole.log(obj.comments[1].title) // 'hilarious'\\n```\\n\\n`mpath.set` supports the same array property notation as `mpath.get`.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.title', ['hilarious', 'fruity'], obj);\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: 'hilarious' },\\n      { title: 'fruity' }\\n  ]}\\n```\\n\\nArray property and indexing syntax can be used together also when setting.\\n\\n```js\\nvar obj = {\\n  array: [\\n      { o: { array: [{x: {b: [4,6,8]}}, { y: 10} ] }}\\n    , { o: { array: [{x: {b: [1,2,3]}}, { x: {z: 10 }}, { x: 'Turkey Day' }] }}\\n    , { o: { array: [{x: {b: null }}, { x: { b: [null, 1]}}] }}\\n    , { o: { array: [{x: null }] }}\\n    , { o: { array: [{y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ]\\n}\\n\\nmpath.set('array.1.o', 'this was changed', obj);\\n\\nconsole.log(require('util').inspect(obj, false, 1000)); // prints..\\n\\n{\\n  array: [\\n      { o: { array: [{x: {b: [4,6,8]}}, { y: 10} ] }}\\n    , { o: 'this was changed' }\\n    , { o: { array: [{x: {b: null }}, { x: { b: [null, 1]}}] }}\\n    , { o: { array: [{x: null }] }}\\n    , { o: { array: [{y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ];\\n}\\n\\nmpath.set('array.o.array.x', 'this was changed too', obj);\\n\\nconsole.log(require('util').inspect(obj, false, 1000)); // prints..\\n\\n{\\n  array: [\\n      { o: { array: [{x: 'this was changed too'}, { y: 10, x: 'this was changed too'} ] }}\\n    , { o: 'this was changed' }\\n    , { o: { array: [{x: 'this was changed too'}, { x: 'this was changed too'}] }}\\n    , { o: { array: [{x: 'this was changed too'}] }}\\n    , { o: { array: [{x: 'this was changed too', y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ];\\n}\\n```\\n\\n####Setting arrays\\n\\nBy default, setting a property within an array to another array results in each element of the new array being set to the item in the destination array at the matching index. An example is helpful.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.title', ['hilarious', 'fruity'], obj);\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: 'hilarious' },\\n      { title: 'fruity' }\\n  ]}\\n```\\n\\nIf we do not desire this destructuring-like assignment behavior we may instead specify the `$` operator in the path being set to force the array to be copied directly.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.$.title', ['hilarious', 'fruity'], obj);\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: ['hilarious', 'fruity'] },\\n      { title: ['hilarious', 'fruity'] }\\n  ]}\\n```\\n\\n####Field assignment rules\\n\\nThe rules utilized mirror those used on `mpath.get`, meaning we can take values returned from `mpath.get`, update them, and reassign them using `mpath.set`. Note that setting nested arrays of arrays can get unweildy quickly. Check out the [tests](https://github.com/aheckmann/mpath/blob/master/test/index.js) for more extreme examples.\\n\\n#####Maps\\n\\n`mpath.set` also accepts an optional `map` argument which receives each individual value being set. The value returned from the `map` function will be used in the original values place.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.title', ['hilarious', 'fruity'], obj, function (val) {\\n  return val.length;\\n});\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: 9 },\\n      { title: 6 }\\n  ]}\\n```\\n\\n### Custom object types\\n\\nSometimes you may want to enact the same functionality on custom object types that store all their real data internally, say for an ODM type object. No fear, `mpath` has you covered. Simply pass the name of the property being used to store the internal data and it will be traversed instead:\\n\\n```js\\nvar mpath = require('mpath');\\n\\nvar obj = {\\n    comments: [\\n      { title: 'exciting!', _doc: { title: 'great!' }}\\n    ]\\n}\\n\\nmpath.get('comments.0.title', obj, '_doc')            // 'great!'\\nmpath.set('comments.0.title', 'nov 3rd', obj, '_doc')\\nmpath.get('comments.0.title', obj, '_doc')            // 'nov 3rd'\\nmpath.get('comments.0.title', obj)                    // 'exciting'\\n```\\n\\nWhen used with a `map`, the `map` argument comes last.\\n\\n```js\\nmpath.get(path, obj, '_doc', map);\\nmpath.set(path, val, obj, '_doc', map);\\n```\\n\\n[LICENSE](https://github.com/aheckmann/mpath/blob/master/LICENSE)\\n\\n\",\n\t28:   \"_id\": \"mpath@0.1.1\",\n\t31:     \"tarball\": \"http://registry.npmjs.org/mpath/-/mpath-0.1.1.tgz\"\n\t46:   \"_from\": \"mpath@0.1.1\",\n\t47:   \"_resolved\": \"https://registry.npmjs.org/mpath/-/mpath-0.1.1.tgz\",\n\t49:     \"url\": \"https://github.com/aheckmann/mpath/issues\"\n\t51:   \"homepage\": \"https://github.com/aheckmann/mpath\"\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mpath/README.md:\n\t1: #mpath\n\t3: {G,S}et javascript object values using MongoDB-like path notation.\n\t8: var mpath = require('mpath');\n\t17: mpath.get('comments.1.title', obj) // 'exciting!'\n\t20: `mpath.get` supports array property notation as well.\n\t30: mpath.get('comments.title', obj) // ['funny', 'exciting!']\n\t48: var found = mpath.get('array.o.array.x.b.1', obj);\n\t65: The following rules are iteratively applied to each `segment` in the passed `path`. For example:\n\t68: var path = 'one.two.14'; // path\n\t81: `mpath.get` also accepts an optional `map` argument which receives each individual found value. The value returned from the `map` function will be used in the original found values place.\n\t91: mpath.get('comments.title', obj, function (val) {\n\t109: mpath.set('comments.1.title', 'hilarious', obj)\n\t113: `mpath.set` supports the same array property notation as `mpath.get`.\n\t123: mpath.set('comments.title', ['hilarious', 'fruity'], obj);\n\t148: mpath.set('array.1.o', 'this was changed', obj);\n\t164: mpath.set('array.o.array.x', 'this was changed too', obj);\n\t193: mpath.set('comments.title', ['hilarious', 'fruity'], obj);\n\t203: If we do not desire this destructuring-like assignment behavior we may instead specify the `$` operator in the path being set to force the array to be copied directly.\n\t213: mpath.set('comments.$.title', ['hilarious', 'fruity'], obj);\n\t225: The rules utilized mirror those used on `mpath.get`, meaning we can take values returned from `mpath.get`, update them, and reassign them using `mpath.set`. Note that setting nested arrays of arrays can get unweildy quickly. Check out the [tests](https://github.com/aheckmann/mpath/blob/master/test/index.js) for more extreme examples.\n\t229: `mpath.set` also accepts an optional `map` argument which receives each individual value being set. The value returned from the `map` function will be used in the original values place.\n\t239: mpath.set('comments.title', ['hilarious', 'fruity'], obj, function (val) {\n\t253: Sometimes you may want to enact the same functionality on custom object types that store all their real data internally, say for an ODM type object. No fear, `mpath` has you covered. Simply pass the name of the property being used to store the internal data and it will be traversed instead:\n\t256: var mpath = require('mpath');\n\t264: mpath.get('comments.0.title', obj, '_doc')            // 'great!'\n\t265: mpath.set('comments.0.title', 'nov 3rd', obj, '_doc')\n\t266: mpath.get('comments.0.title', obj, '_doc')            // 'nov 3rd'\n\t267: mpath.get('comments.0.title', obj)                    // 'exciting'\n\t273: mpath.get(path, obj, '_doc', map);\n\t274: mpath.set(path, val, obj, '_doc', map);\n\t277: [LICENSE](https://github.com/aheckmann/mpath/blob/master/LICENSE)\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mpath/lib/index.js:\n\t3:  * Returns the value of object `o` at the given `path`.\n\t14:  *     mpath.get('comments.0.title', o)         // 'exciting!'\n\t15:  *     mpath.get('comments.0.title', o, '_doc') // 'great!'\n\t16:  *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']\n\t19:  *     mpath.get(path, o)\n\t20:  *     mpath.get(path, o, special)\n\t21:  *     mpath.get(path, o, map)\n\t22:  *     mpath.get(path, o, special, map)\n\t24:  * @param {String} path\n\t26:  * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n\t30: exports.get = function (path, o, special, map) {\n\t38:   var parts = 'string' == typeof path\n\t39:     ? path.split('.')\n\t40:     : path\n\t43:     throw new TypeError('Invalid `path`. Must be either string or array');\n\t54:       var paths = parts.slice(i);\n\t58:           ? exports.get(paths, item, special, map)\n\t74:  * Sets the `val` at the given `path` of object `o`.\n\t76:  * @param {String} path\n\t79:  * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n\t84: exports.set = function (path, val, o, special, map, _copying) {\n\t92:   var parts = 'string' == typeof path\n\t93:     ? path.split('.')\n\t94:     : path\n\t97:     throw new TypeError('Invalid `path`. Must be either string or array');\n\t102:   // the existance of $ in a path tells us if the user desires\n\t106:   var copy = _copying || /\\$/.test(path)\n\t122:       var paths = parts.slice(i);\n\t126:           exports.set(paths, val[j], obj[j], special, map, copy);\n\t131:           exports.set(paths, val, obj[j], special, map, copy);\n\t144:   // process the last property of the path\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mpath/test/index.js:\n\t6: var mpath = require('../')\n\t19:  * special path for override tests\n\t28: describe('mpath', function(){\n\t63:     it('`path` must be a string or array', function(done){\n\t65:         mpath.get({}, o);\n\t68:         mpath.get(4, o);\n\t71:         mpath.get(function(){}, o);\n\t74:         mpath.get(/asdf/, o);\n\t77:         mpath.get(Math, o);\n\t80:         mpath.get(Buffer, o);\n\t83:         mpath.get('string', o);\n\t86:         mpath.get([], o);\n\t93:         assert.equal('jiro', mpath.get('name', o));\n\t97:           , mpath.get('first', o)\n\t102:           , mpath.get('first.second', o)\n\t107:           , mpath.get('first.second.third', o)\n\t112:           , mpath.get('first.second.third.0', o)\n\t117:           , mpath.get('first.second.third.2', o)\n\t122:           , mpath.get('first.second.third.1', o)\n\t127:           , mpath.get('first.second.third.1.name', o)\n\t136:           mpath.get('comments', o));\n\t138:         assert.deepEqual({ name: 'one' }, mpath.get('comments.0', o));\n\t139:         assert.deepEqual('one', mpath.get('comments.0.name', o));\n\t140:         assert.deepEqual('two', mpath.get('comments.1.name', o));\n\t141:         assert.deepEqual('three', mpath.get('comments.2.name', o));\n\t144:             , mpath.get('comments.2.comments', o));\n\t147:             , mpath.get('comments.2.comments.1', o));\n\t149:         assert.deepEqual('twoo', mpath.get('comments.2.comments.1.comments.0.val', o));\n\t157:           , mpath.get('comments.name', o)\n\t165:           , mpath.get('comments.comments', o)\n\t173:           , mpath.get('first.second.third.name', o)\n\t177:           , mpath.get('first.second.third.name', o, function (v) {\n\t194:           , mpath.get('array.o.array', o)\n\t209:           , mpath.get('array.o.array.0', o)\n\t224:           , mpath.get('array.o.array.0.x', o)\n\t239:           , mpath.get('array.o.array.y', o)\n\t250:           , mpath.get('array.o.array.x', o)\n\t265:           , mpath.get('array.o.array.x.b', o)\n\t280:           , mpath.get('array.o.array.x.b.1', o)\n\t291:           , mpath.get('array.o.array.x.b.1', o, function (v) {\n\t301:           , mpath.get('array.1.o.array', o)\n\t305:           , mpath.get('array.1.o.array', o, function (v) {\n\t320:           , mpath.get('arr.arr.1', o)\n\t324:           , mpath.get('arr.arr.1', o, function (v) {\n\t335:           , mpath.get('arr.arr.1.a', o, function (v) {\n\t342:           , mpath.get('arr.arr.1.a', o)\n\t344:         mpath.set('arr.arr.1.a', [{c:49},undefined], o)\n\t347:           , mpath.get('arr.arr.1.a', o)\n\t349:         mpath.set('arr.arr.1.a', [{c:48},undefined], o)\n\t356:           , mpath.get('arr.arr.1.a.c', o)\n\t360:           , mpath.get('arr.arr.1.a.c', o, function (v) {\n\t372:         assert.equal('jiro', mpath.get('name', o, special));\n\t376:           , mpath.get('first', o, special)\n\t381:           , mpath.get('first.second', o, special)\n\t386:           , mpath.get('first.second.third', o, special)\n\t391:           , mpath.get('first.second.third.0', o, special)\n\t396:           , mpath.get('first.second.third.0', o, special, function (v) {\n\t403:           , mpath.get('first.second.third.2', o, special)\n\t408:           , mpath.get('first.second.third.1', o, special)\n\t413:           , mpath.get('first.second.third.1.name', o, special)\n\t422:           mpath.get('comments', o, special));\n\t424:         assert.deepEqual({ name: 'one' }, mpath.get('comments.0', o, special));\n\t425:         assert.deepEqual('one', mpath.get('comments.0.name', o, special));\n\t426:         assert.deepEqual('2', mpath.get('comments.1.name', o, special));\n\t427:         assert.deepEqual('3', mpath.get('comments.2.name', o, special));\n\t428:         assert.deepEqual('nice', mpath.get('comments.2.name', o, special, function (v) {\n\t433:             , mpath.get('comments.2.comments', o, special));\n\t436:             , mpath.get('comments.2.comments.1', o, special));\n\t438:         assert.deepEqual(2, mpath.get('comments.2.comments.1.comments.0.val', o, special));\n\t445:           , mpath.get('comments.name', o, special)\n\t449:           , mpath.get('comments.name', o, special, function (v) {\n\t459:           , mpath.get('comments.comments', o, special)\n\t467:           , mpath.get('comments.comments.1.comments', o, special)\n\t475:           , mpath.get('comments.comments.1.comments.val', o, special)\n\t479:           , mpath.get('comments.comments.1.comments.val', o, special, function (v) {\n\t494:         mpath.set('name', 'a new val', o, function (v) {\n\t499:         mpath.set('name', 'changed', o);\n\t502:         mpath.set('first.second.third', [1,{name:'x'},9], o);\n\t505:         mpath.set('first.second.third.1.name', 'y', o)\n\t508:         mpath.set('comments.1.name', 'ttwwoo', o);\n\t511:         mpath.set('comments.2.comments.1.comments.0.expand', 'added', o);\n\t516:         mpath.set('comments.2.comments.1.comments.2', 'added', o);\n\t531:       describe('array.path', function(){\n\t534:             mpath.set('arr.yep', false, o, function (v) {\n\t542:             mpath.set('arr.yep', false, o);\n\t554:             mpath.set('arr.yep', ['one',2], o, function (v) {\n\t561:             mpath.set('arr.yep', ['one',2], o);\n\t572:             mpath.set('arr.yep', [47], o, function (v) {\n\t580:             mpath.set('arr.yep', [47], o);\n\t590:             mpath.set('arr.yep', [5,6,7], o, function (v) {\n\t598:             mpath.set('arr.yep', [5,6,7], o);\n\t609:       describe('array.$.path', function(){\n\t612:             mpath.set('arr.$.yep', {xtra: 'double good'}, o, function (v) {\n\t620:             mpath.set('arr.$.yep', {xtra: 'double good'}, o);\n\t631:             mpath.set('arr.$.yep', [15], o, function (v) {\n\t639:             mpath.set('arr.$.yep', [15], o);\n\t650:       describe('array.index.path', function(){\n\t652:           mpath.set('arr.1.yep', 0, o, function (v) {\n\t660:           mpath.set('arr.1.yep', 0, o);\n\t670:       describe('array.index.array.path', function(){\n\t672:           mpath.set('arr.0.arr.e', 35, o, function (v) {\n\t680:           mpath.set('arr.0.arr.e', 35, o);\n\t689:           mpath.set('arr.0.arr.e', ['a','b'], o, function (v) {\n\t697:           mpath.set('arr.0.arr.e', ['a','b'], o);\n\t707:       describe('array.index.array.path.path', function(){\n\t709:           mpath.set('arr.0.arr.a.b', 36, o, function (v) {\n\t717:           mpath.set('arr.0.arr.a.b', 36, o);\n\t726:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o, function (v) {\n\t734:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o);\n\t744:       describe('array.index.array.$.path.path', function(){\n\t746:           mpath.set('arr.0.arr.$.a.b', '$', o, function (v) {\n\t754:           mpath.set('arr.0.arr.$.a.b', '$', o);\n\t763:           mpath.set('arr.0.arr.$.a.b', [1], o, function (v) {\n\t771:           mpath.set('arr.0.arr.$.a.b', [1], o);\n\t781:       describe('array.array.index.path', function(){\n\t783:           mpath.set('arr.arr.0.a', 'single', o, function (v) {\n\t791:           mpath.set('arr.arr.0.a', 'single', o);\n\t800:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o, function (v) {\n\t808:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o);\n\t818:       describe('array.array.$.index.path', function(){\n\t820:           mpath.set('arr.arr.$.0.a', 'singles', o, function (v) {\n\t828:           mpath.set('arr.arr.$.0.a', 'singles', o);\n\t834:           mpath.set('$.arr.arr.0.a', 'single', o);\n\t843:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o, function (v) {\n\t851:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o);\n\t857:           mpath.set('arr.$.arr.0.a', [4,8,15,16,23,42,108], o);\n\t867:       describe('array.array.path.index', function(){\n\t869:           mpath.set('arr.arr.a.7', 47, o, function (v) {\n\t877:           mpath.set('arr.arr.a.7', 47, o);\n\t887:           mpath.set('arr.arr.a.7', [[null,46], [undefined, 'woot']], o);\n\t903:       describe('handles array.array.path', function(){\n\t916:           mpath.set('arr.arr.e', 47, o, function (v) {\n\t936:           mpath.set('arr.arr.e', 47, o);\n\t955:           mpath.set('arr.arr.e', [[1,2,3],[4,5],null,[],[6], [7,8,9]], o, function (v) {\n\t977:           mpath.set('arr.arr.e', [[1,2,3],[4,5],null,[],[6], [7,8,9]], o);\n\t1005:         mpath.set('name', 'chan', o, special, function (v) {\n\t1010:         mpath.set('name', 'changer', o, special);\n\t1013:         mpath.set('first.second.third', [1,{name:'y'},9], o, special);\n\t1016:         mpath.set('first.second.third.1.name', 'z', o, special)\n\t1019:         mpath.set('comments.1.name', 'ttwwoo', o, special);\n\t1022:         mpath.set('comments.2.comments.1.comments.0.expander', 'adder', o, special, function (v) {\n\t1029:         mpath.set('comments.2.comments.1.comments.0.expander', 'adder', o, special);\n\t1034:         mpath.set('comments.2.comments.1.comments.2', 'set', o, special);\n\t1048:       describe('array.path', function(){\n\t1053:             mpath.set('arr.yep', false, o, special, function (v) {\n\t1061:             mpath.set('arr.yep', false, o, special);\n\t1072:             mpath.set('arr.yep', ['one',2], o, special, function (v) {\n\t1080:             mpath.set('arr.yep', ['one',2], o, special);\n\t1090:             mpath.set('arr.yep', [47], o, special, function (v) {\n\t1098:             mpath.set('arr.yep', [47], o, special);\n\t1107:             mpath.set('arr.yep', [20], o, special);\n\t1117:             mpath.set('arr.yep', [5,6,7], o, special, function () {\n\t1125:             mpath.set('arr.yep', [5,6,7], o, special);\n\t1136:       describe('array.$.path', function(){\n\t1139:             mpath.set('arr.$.yep', {xtra: 'double good'}, o, special, function (v) {\n\t1148:             mpath.set('arr.$.yep', {xtra: 'double good'}, o, special);\n\t1160:             mpath.set('arr.$.yep', [15], o, special, function (v) {\n\t1169:             mpath.set('arr.$.yep', [15], o, special);\n\t1181:       describe('array.index.path', function(){\n\t1183:           mpath.set('arr.1.yep', 0, o, special, function (v) {\n\t1192:           mpath.set('arr.1.yep', 0, o, special);\n\t1203:       describe('array.index.array.path', function(){\n\t1205:           mpath.set('arr.0.arr.e', 35, o, special, function (v) {\n\t1214:           mpath.set('arr.0.arr.e', 35, o, special);\n\t1224:           mpath.set('arr.0.arr.e', ['a','b'], o, special, function (v) {\n\t1233:           mpath.set('arr.0.arr.e', ['a','b'], o, special);\n\t1244:       describe('array.index.array.path.path', function(){\n\t1246:           mpath.set('arr.0.arr.a.b', 36, o, special, function (v) {\n\t1255:           mpath.set('arr.0.arr.a.b', 36, o, special);\n\t1265:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o, special, function (v) {\n\t1274:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o, special);\n\t1285:       describe('array.index.array.$.path.path', function(){\n\t1287:           mpath.set('arr.0.arr.$.a.b', '$', o, special, function (v) {\n\t1296:           mpath.set('arr.0.arr.$.a.b', '$', o, special);\n\t1306:           mpath.set('arr.0.arr.$.a.b', [1], o, special, function (v) {\n\t1315:           mpath.set('arr.0.arr.$.a.b', [1], o, special);\n\t1326:       describe('array.array.index.path', function(){\n\t1328:           mpath.set('arr.arr.0.a', 'single', o, special, function (v) {\n\t1337:           mpath.set('arr.arr.0.a', 'single', o, special);\n\t1347:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o, special, function (v) {\n\t1356:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o, special);\n\t1367:       describe('array.array.$.index.path', function(){\n\t1369:           mpath.set('arr.arr.$.0.a', 'singles', o, special, function (v) {\n\t1378:           mpath.set('arr.arr.$.0.a', 'singles', o, special);\n\t1385:           mpath.set('$.arr.arr.0.a', 'single', o, special);\n\t1395:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o, special, function (v) {\n\t1404:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o, special);\n\t1411:           mpath.set('arr.$.arr.0.a', [4,8,15,16,23,42,108], o, special);\n\t1422:       describe('array.array.path.index', function(){\n\t1424:           mpath.set('arr.arr.a.7', 47, o, special, function (v) {\n\t1433:           mpath.set('arr.arr.a.7', 47, o, special);\n\t1444:           mpath.set('arr.arr.a.7', [[null,46], [undefined, 'woot']], o, special, function (v) {\n\t1459:           mpath.set('arr.arr.a.7', [[null,46], [undefined, 'woot']], o, special);\n\t1473:       describe('handles array.array.path', function(){\n\t1483:           mpath.set('arr.arr.e', 47, o, special);\n\t1519:           mpath.set('arr.arr.e', [[1,2,3],[4,5],null,[],[6], [7,8,9]], o, special);\n\t1562:         var vals = mpath.get('array.o.array.x.b', o);\n\t1570:         mpath.set('array.o.array.x.b', vals, o);\n\t1586:         mpath.set('comments.name', ['this', 'was', 'changed'], o);\n\t1596:         mpath.set('comments.name', ['also', 'changed', 'this'], o, special);\n\t1615:           mpath.set('arr.$.arr.$.a', 35, o);\n\t1621:     it('ignores setting a nested path that doesnt exist', function(done){\n\t1624:         mpath.set('thing.that.is.new', 10, o);\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mquery/README.md:\n\t180: All paths passed that are not `$atomic` operations will become `$set` ops. For example:\n\t405: Specifies the complementary comparison value for the path specified with `where()`.\n\t499: query.where('path').intersects().geometry({\n\t505: query.where('path').intersects({\n\t655: When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.\n\t721: Specifies a `$slice` projection for a `path`\n\t757: Specifies a `path` for use with chaining\n\t884: If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mquery/lib/mquery.js:\n\t50:   this._path = proto._path || undefined;\n\t135:   p._path = this._path;\n\t231:  * Specifies a `path` for use with chaining.\n\t251:  * @param {String} [path]\n\t264:     this._path = arguments[0];\n\t267:       this._conditions[this._path] = arguments[1];\n\t277:   throw new TypeError('path must be a string or object');\n\t281:  * Specifies the complementary comparison value for paths specified with `where()`\n\t297:   this._ensurePath('equals');\n\t298:   var path = this._path;\n\t299:   this._conditions[path] = val;\n\t364:  * When called with one argument, the most recent path passed to `where()` is used.\n\t375:  * @param {String} [path]\n\t383:  * When called with one argument, the most recent path passed to `where()` is used.\n\t387:  * @param {String} [path]\n\t395:  * When called with one argument, the most recent path passed to `where()` is used.\n\t399:  * @param {String} [path]\n\t407:  * When called with one argument, the most recent path passed to `where()` is used.\n\t411:  * @param {String} [path]\n\t419:  * When called with one argument, the most recent path passed to `where()` is used.\n\t423:  * @param {String} [path]\n\t431:  * When called with one argument, the most recent path passed to `where()` is used.\n\t435:  * @param {String} [path]\n\t443:  * When called with one argument, the most recent path passed to `where()` is used.\n\t447:  * @param {String} [path]\n\t455:  * When called with one argument, the most recent path passed to `where()` is used.\n\t459:  * @param {String} [path]\n\t467:  * When called with one argument, the most recent path passed to `where()` is used.\n\t471:  * @param {String} [path]\n\t479:  * When called with one argument, the most recent path passed to `where()` is used.\n\t483:  * @param {String} [path]\n\t491:  * When called with one argument, the most recent path passed to `where()` is used.\n\t495:  * @param {String} [path]\n\t508:     var path, val;\n\t511:       this._ensurePath($conditional);\n\t513:       path = this._path;\n\t516:       path = arguments[0];\n\t519:     var conds = this._conditions[path] || (this._conditions[path] = {});\n\t528:  * @param {String} [path]\n\t535:   var val, path;\n\t538:     this._ensurePath('mod')\n\t540:     path = this._path;\n\t542:     this._ensurePath('mod')\n\t544:     path = this._path;\n\t547:     path = arguments[0];\n\t550:     path = arguments[0];\n\t553:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t572:  * @param {String} [path]\n\t579:   var path, val;\n\t582:     this._ensurePath('exists');\n\t583:     path = this._path;\n\t587:       this._ensurePath('exists');\n\t588:       path = this._path;\n\t591:       path = arguments[0];\n\t595:     path = arguments[0];\n\t599:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t623:  * @param {String|Object|Function} path\n\t633:   var fn, path, criteria;\n\t636:     this._ensurePath('elemMatch');\n\t637:     path = this._path;\n\t640:     this._ensurePath('elemMatch');\n\t641:     path = this._path;\n\t644:     path = arguments[0];\n\t647:     path = arguments[0];\n\t659:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t694:   this._ensurePath('within');\n\t740:  * @param {String} path\n\t747:   var path, box;\n\t751:     path = arguments[0];\n\t755:     this._ensurePath('box');\n\t756:     path = this._path;\n\t762:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t775:  * @param {String|Array} [path]\n\t783:   var val, path;\n\t787:     path = arguments[0];\n\t791:     this._ensurePath('polygon');\n\t792:     path = this._path;\n\t796:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t815:  * @param {String} [path]\n\t823:   var path, val;\n\t826:     this._ensurePath('circle');\n\t827:     path = this._path;\n\t830:     path = arguments[0];\n\t839:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t869:  * @param {String} [path]\n\t877:   var path, val;\n\t884:     this._ensurePath('near');\n\t885:     path = this._path;\n\t888:     path = arguments[0];\n\t898:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t936:  *     query.where('path').intersects().geometry({\n\t941:  *     query.where('path').intersects({\n\t953:   this._ensurePath('intersects');\n\t996:  * The most recent path passed to `where()` is used.\n\t1014:   var val, path;\n\t1017:     this._ensurePath('geometry');\n\t1018:     path = this._path;\n\t1028:   var conds = this._conditions[path] || (this._conditions[path] = {});\n\t1041:  * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.\n\t1102:  * Specifies a $slice condition for a `path`\n\t1112:  * @param {String} [path]\n\t1125:   var path, val;\n\t1128:     this._ensurePath('slice');\n\t1129:     path = this._path;\n\t1133:       this._ensurePath('slice');\n\t1134:       path = this._path;\n\t1137:       path = arguments[0];\n\t1141:     path = arguments[0];\n\t1146:   myFields[path] = { '$slice': val };\n\t1155:  * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n\t1798:  * _All paths passed that are not $atomic operations will become $set ops._\n\t2381:  * Make sure _path is set.\n\t2386: Query.prototype._ensurePath = function (method) {\n\t2387:   if (!this._path) {\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mquery/test/index.js:\n\t61:       var path = 'street';\n\t67:       q.where(path);\n\t78:       assert.equal(path, m._path);\n\t143:       }, /path must be a string or object/);\n\t160:         assert.equal('name', m._path);\n\t167:       assert.equal('name', m._path);\n\t186:     it('sets value of path set with where()', function(){\n\t287:       it('uses previously set `where` path if 1 arg passed', function(){\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/ms/test/support/jquery.js:\n\t1665: \t\t\t// the code to shortcut on the same path as a DOM node with no cache\n\t3047: \t\t\tcache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;\n\t3117: \t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t3119: \t\teventPath = [[ elem, special.bindType || type ]];\n\t3126: \t\t\t\teventPath.push([ cur, bubbleType ]);\n\t3132: \t\t\t\teventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);\n\t3136: \t\t// Fire handlers on the event path\n\t3137: \t\tfor ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {\n\t3139: \t\t\tcur = eventPath[i][0];\n\t3140: \t\t\tevent.type = eventPath[i][1];\n\t6667: \t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...\n\n/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/muri/lib/index.js:\n\t44:   var path = match[2];\n\t75:   var parts = path.split('?');\n\n/node_modules/acute-mongoose-models/node_modules/util/test/node/debug.js:\n\t49:   var child = spawn(process.execPath, [__filename, 'child'], {\n\n/node_modules/acute-mongoose-models/tests/testconfig.js:\n\t4:         packagePath: \"../../acute-express-data\",\n\n/node_modules/acute-mongoose-models/tests/testModels.js:\n\t2:     path = require('path'),\n\t10:         var configPath = path.join(__dirname, \"testconfig.js\");\n\t11:         var config = architect.loadConfig(configPath);\n\n/node_modules/acute-utils/lib/index.js:\n\t3: exports.loadApp = function(configPath, cb) {\n\t4:     architect.loadConfig(configPath, function(err, conf) {\n\n/node_modules/acute-utils/test/testIndex.js:\n\t2:     path = require('path'),\n\t3:     configPath = path.join(__dirname, \"testConfig.js\");\n\t8:             var config = utils.loadApp(configPath, function(err, arch) {\n\n/node_modules/architect/architect.js:\n\t13:     var dirname = require('path').dirname;\n\t14:     var resolve = require('path').resolve;\n\t15:     var existsSync = require('fs').existsSync || require('path').existsSync;\n\t16:     var realpathSync = require('fs').realpathSync;\n\t17:     var exists = require('fs').exists || require('path').exists;\n\t18:     var realpath = require('fs').realpath;\n\t19:     var packagePathCache = {};\n\t26:     function loadConfig(configPath, callback) {\n\t27:       var config = require(configPath);\n\t28:       var base = dirname(configPath);\n\t44:                 plugin = config[index] = { packagePath: plugin };\n\t47:             if (plugin.hasOwnProperty(\"packagePath\") && !plugin.hasOwnProperty(\"setup\")) {\n\t48:                 var defaults = resolveModuleSync(base, plugin.packagePath);\n\t54:                 plugin.packagePath = defaults.packagePath;\n\t55:                 plugin.setup = require(plugin.packagePath);\n\t71:                 plugin = config[i] = { packagePath: plugin };\n\t74:             if (plugin.hasOwnProperty(\"packagePath\") && !plugin.hasOwnProperty(\"setup\")) {\n\t75:                 resolveModule(base, plugin.packagePath, function(err, defaults) {\n\t83:                     plugin.packagePath = defaults.packagePath;\n\t85:                         plugin.setup = require(plugin.packagePath);\n\t103:     function resolveModuleSync(base, modulePath) {\n\t104:         var packagePath;\n\t106:             packagePath = resolvePackageSync(base, modulePath + \"/package.json\");\n\t111:         var metadata = packagePath && require(packagePath).plugin || {};\n\t112:         if (packagePath) {\n\t113:             modulePath = dirname(packagePath);\n\t115:             modulePath = resolvePackageSync(base, modulePath);\n\t117:         var module = require(modulePath);\n\t120:         metadata.packagePath = modulePath;\n\t126:     function resolveModule(base, modulePath, callback) {\n\t127:         resolvePackage(base, modulePath + \"/package.json\", function(err, packagePath) {\n\t133:                     metadata = packagePath && require(packagePath).plugin || {};\n\t142:                     resolvePackage(base, modulePath + \".js\", next);\n\t144:                 else if (packagePath) {\n\t145:                     next(null, dirname(packagePath));\n\t148:                     resolvePackage(base, modulePath, next);\n\t150:             })(function(err, modulePath) {\n\t155:                     module = require(modulePath);\n\t162:                 metadata.packagePath = modulePath;\n\t171:     function resolvePackageSync(base, packagePath) {\n\t173:         if (!(base in packagePathCache)) {\n\t174:             packagePathCache[base] = {};\n\t176:         var cache = packagePathCache[base];\n\t177:         if (packagePath in cache) {\n\t178:             return cache[packagePath];\n\t180:         var newPath;\n\t181:         if (packagePath[0] === \".\" || packagePath[0] === \"/\") {\n\t182:             newPath = resolve(base, packagePath);\n\t183:             if (existsSync(newPath)) {\n\t184:                 newPath = realpathSync(newPath);\n\t185:                 cache[packagePath] = newPath;\n\t186:                 return newPath;\n\t191:                 newPath = resolve(base, \"node_modules\", packagePath);\n\t192:                 if (existsSync(newPath)) {\n\t193:                     newPath = realpathSync(newPath);\n\t194:                     cache[packagePath] = newPath;\n\t195:                     return newPath;\n\t200:         var err = new Error(\"Can't find '\" + packagePath + \"' relative to '\" + originalBase + \"'\");\n\t205:     function resolvePackage(base, packagePath, callback) {\n\t207:         if (!packagePathCache.hasOwnProperty(base)) {\n\t208:             packagePathCache[base] = {};\n\t210:         var cache = packagePathCache[base];\n\t211:         if (cache.hasOwnProperty(packagePath)) {\n\t212:             return callback(null, cache[packagePath]);\n\t214:         if (packagePath[0] === \".\" || packagePath[0] === \"/\") {\n\t215:             var newPath = resolve(base, packagePath);\n\t216:             exists(newPath, function(exists) {\n\t218:                     realpath(newPath, function(err, newPath) {\n\t221:                         cache[packagePath] = newPath;\n\t222:                         return callback(null, newPath);\n\t225:                     var err = new Error(\"Can't find '\" + packagePath + \"' relative to '\" + originalBase + \"'\");\n\t237:                 var err = new Error(\"Can't find '\" + packagePath + \"' relative to '\" + originalBase + \"'\");\n\t242:             var newPath = resolve(base, \"node_modules\", packagePath);\n\t243:             exists(newPath, function(exists) {\n\t245:                     realpath(newPath, function(err, newPath) {\n\t248:                         cache[packagePath] = newPath;\n\t249:                         return callback(null, newPath);\n\t270:     function loadConfig(path, callback) {\n\t271:         require([path], function (config) {\n\t282:         var paths = [], pluginIndexes = {};\n\t286:                 plugin = config[index] = { packagePath: plugin };\n\t289:             if (plugin.hasOwnProperty(\"packagePath\") && !plugin.hasOwnProperty(\"setup\")) {\n\t290:                 paths.push((base || \"\") + plugin.packagePath);\n\t291:                 pluginIndexes[plugin.packagePath] = index;\n\t294:         // Mass-Load path-based plugins using amd's require\n\t295:         require(paths, function () {\n\t297:             paths.forEach(function (name, i) {\n\t336:             packagePath: pluginConfig.packagePath,\n\t386:                 unresolved[name].push(plugin.packagePath);\n\n/node_modules/architect/README.markdown:\n\t67:   { packagePath: \"architect-http\", port: 8080 },\n\t68:   { packagePath: \"architect-http-static\", root: \"www\" },\n\t75: Notice that the config is a list of plugin config options.  If the only option in the config is `packagePath`, then a string can be used in place of the object.  If you want to pass other options to the plugin when it's being created, you can put arbitrary properties here.\n\t87: ### loadConfig(configPath)\n\t89: This is a sync function that loads a config file and parses all the plugins into a proper config object for use with `createApp`.  While this uses sync I/O all steps along the way are memoized and I/O only occurs on the first invocation.  It's safe to call this in an event loop provided a small set of configPaths are used.\n\n/node_modules/body-parser/index.js:\n\t13: var path = require('path')\n\t33:  * Path to the parser modules.\n\t36: var parsersDir = path.join(__dirname, 'lib', 'types')\n\t45:   var loc = path.resolve(parsersDir, filename)\n\t47:   var name = path.basename(filename, '.js')\n\n/node_modules/body-parser/node_modules/debug/History.md:\n\t48:   * Makefile: find node path using shell/which (#109, @timoxley)\n\n/node_modules/body-parser/node_modules/debug/Makefile:\n\t3: THIS_MAKEFILE_PATH:=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))\n\t4: THIS_DIR:=$(shell cd $(dir $(THIS_MAKEFILE_PATH));pwd)\n\n/node_modules/body-parser/node_modules/depd/index.js:\n\t13: var relative = require('path').relative\n\t22:  * Get the path to base files on.\n\t25: var basePath = process.cwd()\n\t357:   return relative(basePath, callSite[0])\n\n/node_modules/body-parser/node_modules/iconv-lite/lib/extend-node.js:\n\t29:             // Fastpath empty strings\n\n/node_modules/body-parser/node_modules/type-is/node_modules/mime-types/index.js:\n\t21:   // remove any leading paths, though we should just use path.basename\n\n/node_modules/body-parser/node_modules/type-is/node_modules/mime-types/README.md:\n\t40: ### mime.lookup(path)\n\n/node_modules/body-parser/node_modules/type-is/node_modules/mime-types/node_modules/mime-db/db.json:\n\t785:   \"application/pkix-pkipath\": {\n\t787:     \"extensions\": [\"pkipath\"]\n\t2113:   \"application/vnd.innopath.wamp.notification\": {\n\n/node_modules/express-session/index.js:\n\t148:     // pathname mismatch\n\t149:     var originalPath = parseUrl.original(req).pathname;\n\t150:     if (0 != originalPath.indexOf(cookie.path || '/')) return next();\n\n/node_modules/express-session/README.md:\n\t37: The default value is `{ path: '/', httpOnly: true, secure: false, maxAge: null }`.\n\t312:   // get the url pathname\n\t313:   var pathname = parseurl(req).pathname\n\t316:   views[pathname] = (views[pathname] || 0) + 1\n\n/node_modules/express-session/node_modules/cookie/index.js:\n\t24:     if (opt.path) pairs.push('Path=' + opt.path);\n\n/node_modules/express-session/node_modules/cookie/README.md:\n\t27: ### path\n\t28: > cookie path\n\n/node_modules/express-session/node_modules/debug/History.md:\n\t48:   * Makefile: find node path using shell/which (#109, @timoxley)\n\n/node_modules/express-session/node_modules/debug/Makefile:\n\t3: THIS_MAKEFILE_PATH:=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))\n\t4: THIS_DIR:=$(shell cd $(dir $(THIS_MAKEFILE_PATH));pwd)\n\n/node_modules/express-session/node_modules/depd/index.js:\n\t13: var relative = require('path').relative\n\t22:  * Get the path to base files on.\n\t25: var basePath = process.cwd()\n\t357:   return relative(basePath, callSite[0])\n\n/node_modules/express-session/node_modules/parseurl/HISTORY.md:\n\t12:   * Simplify the \"fast-path\" `RegExp`\n\t32:   * Incorporate URL href-only parse fast-path\n\n/node_modules/express-session/node_modules/parseurl/index.js:\n\t17:  * Pattern for a simple path case.\n\t21: var simplePathRegExp = /^(\\/\\/?(?!\\/)[^\\?#\\s]*)(\\?[^#\\s]*)?$/\n\t91:  * Parse the `str` url with fast-path short-cut.\n\t99:   // Try fast path regexp\n\t101:   var simplePath = typeof str === 'string' && simplePathRegExp.exec(str)\n\t104:   if (simplePath) {\n\t105:     var pathname = simplePath[1]\n\t106:     var search = simplePath[2] || null\n\t110:     url.path = str\n\t112:     url.pathname = pathname\n\n/node_modules/express-session/node_modules/parseurl/README.md:\n\t56: > node benchmark/pathquery.js\n\t80: > node benchmark/simplepath.js\n\n/node_modules/express-session/session/cookie.js:\n\t25:   this.path = '/';\n\t103:       , path: this.path\n\n/node_modules/express/History.md:\n\t24:   * Fix handling of URLs containing `://` in the path\n\t38:   * Use `path.resolve` in view lookup\n\t73:   * Fix using same param name in array of paths\n\t113:   * Fix regression for empty string `path` in `app.use`\n\t114:   * Fix `router.use` to accept array of middleware without path\n\t120:   * Fix `app.use` to accept array of middleware without path\n\t171:     - Fix a path traversal issue when using `root`\n\t172:     - Fix malicious path detection for empty string path\n\t235:     - accepts a file system path instead of a URL\n\t236:     - requires an absolute path or `root` option specified\n\t311:     - Simplify the \"fast-path\" `RegExp`\n\t325:   * fix `subapp.mountpath` regression for `app.use(subapp)`\n\t337:   * support non-string `path` in `app.use(path, fn)`\n\t338:     - supports array of paths\n\t351:   * deps: path-to-regexp@0.1.3\n\t480:  * revert \"fix behavior of multiple `app.VERB` for the same path\"\n\t486:  * add `req.baseUrl` to access the path stripped from `req.url` in routes\n\t487:  * fix behavior of multiple `app.VERB` for the same path\n\t551:    - Include file path in etag\n\t556:    - Support multiple index paths\n\t560:    - Resolve relative paths at middleware setup\n\t583:    - `app.route` -> `app.mountpath` when mounting an express app in another express app\n\t592:    - [path-to-regexp](https://github.com/component/path-to-regexp)\n\t602:     - Fix handling of URLs containing `://` in the path\n\t767:     - Fix a path traversal issue when using `root`\n\t768:     - Fix malicious path detection for empty string path\n\t932:     - Simplify the \"fast-path\" `RegExp`\n\t1217:  * throw 400 in case of malformed paths @rlidwka\n\t1352:   * add app.VERB() paths array deprecation warning\n\t1444:   * change `res.redirect()` to utilize a pathname-relative Location again. Closes #1382\n\t1621:   * Added `req.path`\n\t1643:   * Added `app.path()`\n\t1722:   * Added  shorthand for the parsed request's pathname via `req.path`\n\t1726:   * Fixed absolute path checking on windows. Closes #829 [reported by andrewpmckenzie]\n\t1738:   * Added \"basepath\" setting to work in conjunction with reverse proxies etc.\n\t1757:   * Fixed `options.filename`, exposing the view path to template engines\n\t1772:   * Changed: when cookie `path === null` don't default it\n\t1773:   * Changed; default cookie path to \"home\" setting. Closes #731\n\t1893:   * Added `layout(path)` helper to change the layout within a view. Closes #610\n\t1909:   * Added `app.VERB(path)` as alias of `app.lookup.VERB()`.\n\t1933:   * Fixed up index view path alternative.\n\t2086:   * Performance; caching view path derived partial object names\n\t2123:   * Fixed `res.sendfile()` responding with 403 on malicious path\n\t2158:     Use _req.params_ for path captures, _req.query_ for GET params.\n\t2171:   * Added support for absolute view paths\n\t2355:   * Added Request#pass() support (finds the next matching route, or the given path)\n\t2381:   * Removed extname() / basename() utils. Use path module\n\n/node_modules/express/package.json:\n\t70:     \"path-to-regexp\": \"0.1.3\",\n\n/node_modules/express/lib/application.js:\n\t16: var resolve = require('path').resolve;\n\t90:   this.mountpath = '/';\n\t154:   var path = '/';\n\t156:   // default path to '/'\n\t165:     // first arg is the path\n\t168:       path = fn;\n\t184:       return router.use(path, fn);\n\t187:     debug('.use app under %s', path);\n\t188:     fn.mountpath = path;\n\t192:     router.use(path, function mounted_app(req, res, next) {\n\t210:  * Returns a new `Route` instance for the _path_.\n\t212:  * Routes are isolated middleware stacks for specific paths.\n\t218: app.route = function route(path) {\n\t219:   return this.router.route(path);\n\t240:  * the same signature that Express expects: `(path, options, callback)`,\n\t331:  * Return the app's absolute pathname\n\t344: app.path = function(){\n\t346:     ? this.parent.path() + this.mountpath\n\t417:   app[method] = function(path){\n\t418:     if ('get' == method && 1 == arguments.length) return this.set(path);\n\t420:     var route = this.route(path);\n\t427:  * Special-cased \"all\" method, applying the given route `path`,\n\t430:  * @param {String} path\n\t436: app.all = function(path){\n\t437:   var route = this.route(path);\n\t501:     if (!view.path) {\n\n/node_modules/express/lib/request.js:\n\t362:  * Short-hand for `url.parse(req.url).pathname`.\n\t368: defineGetter(req, 'path', function path() {\n\t369:   return parse(this).pathname;\n\n/node_modules/express/lib/response.js:\n\t11: var path = require('path');\n\t20: var extname = path.extname;\n\t22: var resolve = path.resolve;\n\t301:  * Transfer the file at the given `path`.\n\t341: res.sendFile = function sendFile(path, options, fn) {\n\t346:   if (!path) {\n\t347:     throw new TypeError('path argument is required to res.sendFile');\n\t358:   if (!options.root && !isAbsolute(path)) {\n\t359:     throw new TypeError('path must be absolute or specify root to res.sendFile');\n\t363:   var pathname = encodeURI(path);\n\t364:   var file = send(req, pathname, options);\n\t379:  * Transfer the file at the given `path` as an attachment.\n\t391: res.download = function download(path, filename, fn) {\n\t398:   filename = filename || path;\n\t405:   // Resolve the full path for sendFile\n\t406:   var fullPath = resolve(path);\n\t408:   return this.sendFile(fullPath, { headers: headers }, fn);\n\t595:   var opts = { expires: new Date(1), path: '/' };\n\t608:  *    - `path`     defaults to \"/\"\n\t637:   if (null == options.path) options.path = '/';\n\t687:  * it will play nicely with mounted apps, relative paths,\n\n/node_modules/express/lib/utils.js:\n\t47:  * Check if `path` looks absolute.\n\t49:  * @param {String} path\n\t54: exports.isAbsolute = function(path){\n\t55:   if ('/' == path[0]) return true;\n\t56:   if (':' == path[1] && '\\\\' == path[2]) return true;\n\t57:   if ('\\\\\\\\' == path.substring(0, 2)) return true; // Microsoft Azure absolute path\n\n/node_modules/express/lib/view.js:\n\t6: var path = require('path');\n\t15: var dirname = path.dirname;\n\t16: var basename = path.basename;\n\t17: var extname = path.extname;\n\t18: var join = path.join;\n\t19: var resolve = path.resolve;\n\t34:  *   - `root` root path for view lookup\n\t51:   this.path = this.lookup(name);\n\t63:   var path;\n\t68:   for (var i = 0; i < roots.length && !path; i++) {\n\t71:     // resolve the path\n\t77:     path = this.resolve(dir, file);\n\t80:   return path;\n\t92:   debug('render \"%s\"', this.path);\n\t93:   this.engine(this.path, options, fn);\n\t106:   var path;\n\t109:   // <path>.<ext>\n\t110:   path = join(dir, file);\n\t111:   stat = tryStat(path);\n\t114:     return path;\n\t117:   // <path>/index.<ext>\n\t118:   path = join(dir, basename(file, ext), 'index' + ext);\n\t119:   stat = tryStat(path);\n\t122:     return path;\n\t129:  * @param {string} path\n\t134: function tryStat(path) {\n\t135:   debug('stat \"%s\"', path);\n\t138:     return fs.statSync(path);\n\n/node_modules/express/lib/router/index.js:\n\t128:   var pathlength = search ? search - 1 : req.url.length;\n\t129:   var fqdn = req.url[0] !== '/' && 1 + req.url.substr(0, pathlength).indexOf('://');\n\t189:     self.match_layer(layer, req, res, function (err, path) {\n\t190:       if (err || path === undefined) {\n\t225:       var layerPath = layer.path;\n\t237:         trim_prefix(layer, layerError, layerPath, path);\n\t242:   function trim_prefix(layer, layerError, layerPath, path) {\n\t243:     var c = path[layerPath.length];\n\t247:      // middleware (.use stuff) needs to have the path stripped\n\t248:     if (layerPath.length !== 0) {\n\t249:       debug('trim prefix (%s) from url %s', layerPath, req.url);\n\t250:       removed = layerPath;\n\t265:     debug('%s %s : %s', layer.name, layerPath, req.originalUrl);\n\t283:   var path;\n\t286:     path = parseUrl(req).pathname;\n\t288:     if (!layer.match(path)) {\n\t289:       path = undefined;\n\t295:   done(error, path);\n\t395:  * Use the given middleware function, with optional path, defaulting to \"/\".\n\t401:  * The other difference is that _route_ path is stripped and not visible\n\t404:  * pathname.\n\t411:   var path = '/';\n\t413:   // default path to '/'\n\t422:     // first arg is the path\n\t425:       path = fn;\n\t441:     debug('use %s %s', path, fn.name || '<anonymous>');\n\t443:     var layer = new Layer(path, {\n\t458:  * Create a new Route for the given path.\n\t465:  * @param {String} path\n\t470: proto.route = function(path){\n\t471:   var route = new Route(path);\n\t473:   var layer = new Layer(path, {\n\t487:   proto[method] = function(path){\n\t488:     var route = this.route(path)\n\n/node_modules/express/lib/router/layer.js:\n\t5: var pathRegexp = require('path-to-regexp');\n\t20: function Layer(path, options, fn) {\n\t22:     return new Layer(path, options, fn);\n\t25:   debug('new %s', path);\n\t31:   this.path = undefined;\n\t32:   this.regexp = pathRegexp(path, this.keys = [], options);\n\t34:   if (path === '/' && options.end === false) {\n\t89:  * Check if this route matches `path`, if so\n\t92:  * @param {String} path\n\t97: Layer.prototype.match = function match(path) {\n\t98:   if (path == null) {\n\t99:     // no path, nothing matches\n\t101:     this.path = undefined;\n\t106:     // fast path non-ending match for / (everything matches)\n\t108:     this.path = '';\n\t112:   var m = this.regexp.exec(path);\n\t116:     this.path = undefined;\n\t122:   this.path = m[0];\n\n/node_modules/express/lib/router/match.js:\n\t8: function Match(layer, path, params) {\n\t11:   this.path = path || '';\n\n/node_modules/express/lib/router/route.js:\n\t17:  * Initialize `Route` with the given `path`,\n\t19:  * @param {String} path\n\t23: function Route(path) {\n\t24:   debug('new %s', path);\n\t25:   this.path = path;\n\t163:       debug('%s %s', method, this.path);\n\n/node_modules/express/node_modules/accepts/node_modules/mime-types/index.js:\n\t21:   // remove any leading paths, though we should just use path.basename\n\n/node_modules/express/node_modules/accepts/node_modules/mime-types/README.md:\n\t40: ### mime.lookup(path)\n\n/node_modules/express/node_modules/accepts/node_modules/mime-types/node_modules/mime-db/db.json:\n\t785:   \"application/pkix-pkipath\": {\n\t787:     \"extensions\": [\"pkipath\"]\n\t2113:   \"application/vnd.innopath.wamp.notification\": {\n\n/node_modules/express/node_modules/content-disposition/index.js:\n\t18: var basename = require('path').basename\n\n/node_modules/express/node_modules/content-disposition/README.md:\n\t94: var filePath = '/path/to/public/plans.pdf'\n\t99:   res.setHeader('Content-Disposition', contentDisposition(filePath))\n\t102:   var stream = fs.createReadStream(filePath)\n\n/node_modules/express/node_modules/cookie/index.js:\n\t24:     if (opt.path) pairs.push('Path=' + opt.path);\n\n/node_modules/express/node_modules/cookie/README.md:\n\t27: ### path\n\t28: > cookie path\n\n/node_modules/express/node_modules/debug/History.md:\n\t48:   * Makefile: find node path using shell/which (#109, @timoxley)\n\n/node_modules/express/node_modules/debug/Makefile:\n\t3: THIS_MAKEFILE_PATH:=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))\n\t4: THIS_DIR:=$(shell cd $(dir $(THIS_MAKEFILE_PATH));pwd)\n\n/node_modules/express/node_modules/depd/index.js:\n\t13: var relative = require('path').relative\n\t22:  * Get the path to base files on.\n\t25: var basePath = process.cwd()\n\t357:   return relative(basePath, callSite[0])\n\n/node_modules/express/node_modules/etag/HISTORY.md:\n\t43:   * Add fast-path for empty entity\n\n/node_modules/express/node_modules/etag/index.js:\n\t132:     // fast-path empty\n\t152:     // fast-path empty\n\n/node_modules/express/node_modules/parseurl/HISTORY.md:\n\t12:   * Simplify the \"fast-path\" `RegExp`\n\t32:   * Incorporate URL href-only parse fast-path\n\n/node_modules/express/node_modules/parseurl/index.js:\n\t17:  * Pattern for a simple path case.\n\t21: var simplePathRegExp = /^(\\/\\/?(?!\\/)[^\\?#\\s]*)(\\?[^#\\s]*)?$/\n\t91:  * Parse the `str` url with fast-path short-cut.\n\t99:   // Try fast path regexp\n\t101:   var simplePath = typeof str === 'string' && simplePathRegExp.exec(str)\n\t104:   if (simplePath) {\n\t105:     var pathname = simplePath[1]\n\t106:     var search = simplePath[2] || null\n\t110:     url.path = str\n\t112:     url.pathname = pathname\n\n/node_modules/express/node_modules/parseurl/README.md:\n\t56: > node benchmark/pathquery.js\n\t80: > node benchmark/simplepath.js\n\n/node_modules/express/node_modules/path-to-regexp/component.json:\n\t2:   \"name\": \"path-to-regexp\",\n\t3:   \"description\": \"Express style path to RegExp utility\",\n\n/node_modules/express/node_modules/path-to-regexp/index.js:\n\t2:  * Expose `pathtoRegexp`.\n\t5: module.exports = pathtoRegexp;\n\t8:  * Normalize the given path string,\n\t16:  * @param  {String|RegExp|Array} path\n\t23: function pathtoRegexp(path, keys, options) {\n\t30:   if (path instanceof RegExp) {\n\t31:     return path;\n\t34:   if (Array.isArray(path)) {\n\t38:     path = path.map(function (value) {\n\t39:       return pathtoRegexp(value, keys, options).source;\n\t42:     return new RegExp('(?:' + path.join('|') + ')', flags);\n\t45:   path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))\n\t66:   // If the path is non-ending, match until the end or a slash.\n\t67:   path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\\\/|$)'));\n\t69:   return new RegExp(path, flags);\n\n/node_modules/express/node_modules/path-to-regexp/package.json:\n\t2:   \"name\": \"path-to-regexp\",\n\t3:   \"description\": \"Express style path to RegExp utility\",\n\t14:       \"path-to-regexp\": \"index.js\"\n\t19:     \"url\": \"https://github.com/component/path-to-regexp.git\"\n\t26:     \"url\": \"https://github.com/component/path-to-regexp/issues\"\n\t28:   \"homepage\": \"https://github.com/component/path-to-regexp\",\n\t29:   \"_id\": \"path-to-regexp@0.1.3\",\n\t31:   \"_from\": \"path-to-regexp@0.1.3\",\n\t157:     \"tarball\": \"http://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.3.tgz\"\n\t160:   \"_resolved\": \"https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.3.tgz\",\n\n/node_modules/express/node_modules/path-to-regexp/Readme.md:\n\t2: # Path-to-RegExp\n\t4:   Turn an Express-style path string such as `/user/:name` into a regular expression.\n\t9: var pathToRegexp = require('path-to-regexp');\n\t11: ### pathToRegexp(path, keys, options)\n\t13:  - **path** A string in the express format, an array of such strings, or a regular expression\n\t22: var exp = pathToRegexp('/foo/:bar', keys);\n\n/node_modules/express/node_modules/path-to-regexp/test.js:\n\t1: var pathToRegExp = require('./');\n\t4: describe('path-to-regexp', function () {\n\t6:     it('should match simple paths', function () {\n\t8:       var m = pathToRegExp('/test', params).exec('/test');\n\t18:       var m = pathToRegExp('/:test', params).exec('/pathname');\n\t25:       assert.equal(m[0], '/pathname');\n\t26:       assert.equal(m[1], 'pathname');\n\t31:       var re = pathToRegExp('/:test', params, { strict: true });\n\t51:       var re = pathToRegExp('/:test/', params, { strict: true });\n\t75:       var re = pathToRegExp('/:test?', params);\n\t97:       var m = pathToRegExp('/:page(\\\\d+)', params).exec('/56');\n\t110:       var m = pathToRegExp(':test', params).exec('string');\n\t123:       var m = pathToRegExp('/:test.json', params).exec('/route.json');\n\t136:       var re = pathToRegExp('/:test.:format', params);\n\t159:       var m = pathToRegExp('/:test.json', params).exec('/route.json');\n\t172:       var m = pathToRegExp('/test*', params).exec('/test/route');\n\t183:       var re = pathToRegExp('/:test*', params);\n\t207:       var re = pathToRegExp('/test*.json', params);\n\t233:       var re = pathToRegExp('/:test*.json', params);\n\t261:       var re = pathToRegExp('/:test*.:format', params);\n\t297:       var re = pathToRegExp('/:test*.:format?', params);\n\t337:       var re = pathToRegExp('/:test*?', params);\n\t367:       var m = pathToRegExp('/test').exec('/TEST');\n\t373:       var re = pathToRegExp('/test', null, { sensitive: true });\n\t388:       var m = pathToRegExp('/:test', params, { end: false }).exec('/test/route');\n\t401:       var re = pathToRegExp('/:test', params, { end: false });\n\t417:       var re = pathToRegExp('/route/', params, { end: false });\n\t445:       var re = pathToRegExp('/route/', params, { end: false, strict: true });\n\t471:       var re = pathToRegExp('/route', params, { end: false, strict: true });\n\t488:       var re = pathToRegExp('/(:test)route', params);\n\t511:       var re = pathToRegExp('/(:test?)route', params);\n\t537:       var re = pathToRegExp('/:test.:format?', params);\n\t561:     it('should match full paths with format by default', function () {\n\t563:       var m = pathToRegExp('/:test', params).exec('/test.json');\n\t577:       assert.deepEqual(pathToRegExp(/.*/), /.*/);\n\t583:       var re = pathToRegExp(['/test', '/route']);\n\t592:       var re = pathToRegExp(['/:test', '/test/:route'], params);\n\t608:       m = re.exec('/test/path');\n\t611:       assert.equal(m[0], '/test/path');\n\t613:       assert.equal(m[2], 'path');\n\n/node_modules/express/node_modules/send/History.md:\n\t45:   * Fix malicious path detection for empty string path\n\t50:   * Fix a path traversal issue when using `root`\n\t169:  * Include file path in etag\n\t173:  * Support multiple index paths\n\n/node_modules/express/node_modules/send/index.js:\n\t14:   , path = require('path')\n\t17:   , normalize = path.normalize\n\t18:   , join = path.join\n\t27: var extname = path.extname\n\t29: var resolve = path.resolve\n\t30: var sep = path.sep\n\t32: var upPathRegexp = /(?:^|[\\\\\\/])\\.\\.(?:[\\\\\\/]|$)/\n\t55:  * Return a `SendStream` for `req` and `path`.\n\t58:  * @param {String} path\n\t64: function send(req, path, options) {\n\t65:   return new SendStream(req, path, options);\n\t69:  * Initialize a `SendStream` with the given `path`.\n\t72:  * @param {String} path\n\t77: function SendStream(req, path, options) {\n\t81:   this.path = path;\n\t160:  * @param {Boolean} path\n\t174:  * Set index `paths`, set to a falsy\n\t177:  * @param {String|Boolean|Array} paths\n\t182: SendStream.prototype.index = deprecate.function(function index(paths) {\n\t183:   var index = !paths ? [] : normalizeList(paths);\n\t184:   debug('index %o', paths);\n\t190:  * Set root `path`.\n\t192:  * @param {String} path\n\t197: SendStream.prototype.root = function(path){\n\t198:   path = String(path);\n\t199:   this._root = resolve(path)\n\t255:  * Check if the pathname ends with \"/\".\n\t262:   return '/' == this.path[this.path.length - 1];\n\t373:  * Redirect to `path`.\n\t375:  * @param {String} path\n\t379: SendStream.prototype.redirect = function(path){\n\t386:   path += '/';\n\t389:   res.setHeader('Location', path);\n\t390:   res.end('Redirecting to <a href=\"' + escapeHtml(path) + '\">' + escapeHtml(path) + '</a>\\n');\n\t409:   // decode the path\n\t410:   var path = decode(this.path)\n\t411:   if (path === -1) return this.error(400)\n\t414:   if (~path.indexOf('\\0')) return this.error(400);\n\t419:     path = normalize(join(root, path))\n\t422:     // malicious path\n\t423:     if ((path + sep).substr(0, root.length) !== root) {\n\t424:       debug('malicious path \"%s\"', path)\n\t428:     // explode path parts\n\t429:     parts = path.substr(root.length).split(sep)\n\t432:     if (upPathRegexp.test(path)) {\n\t433:       debug('malicious path \"%s\"', path)\n\t437:     // explode path parts\n\t438:     parts = normalize(path).split(sep)\n\t440:     // resolve the path\n\t441:     path = resolve(path)\n\t455:     debug('%s dotfile \"%s\"', access, path)\n\t468:   if (this._index.length && this.path[this.path.length - 1] === '/') {\n\t469:     this.sendIndex(path);\n\t473:   this.sendFile(path);\n\t478:  * Transfer `path`.\n\t480:  * @param {String} path\n\t484: SendStream.prototype.send = function(path, stat){\n\t497:   debug('pipe \"%s\"', path)\n\t500:   this.setHeader(path, stat);\n\t503:   this.type(path);\n\t561:   this.stream(path, options);\n\t565:  * Transfer file for `path`.\n\t567:  * @param {String} path\n\t570: SendStream.prototype.sendFile = function sendFile(path) {\n\t574:   debug('stat \"%s\"', path);\n\t575:   fs.stat(path, function onstat(err, stat) {\n\t577:       && !extname(path)\n\t578:       && path[path.length - 1] !== sep) {\n\t583:     if (stat.isDirectory()) return self.redirect(self.path)\n\t584:     self.emit('file', path, stat)\n\t585:     self.send(path, stat)\n\t595:     var p = path + '.' + self._extensions[i++]\n\t608:  * Transfer index for `path`.\n\t610:  * @param {String} path\n\t613: SendStream.prototype.sendIndex = function sendIndex(path){\n\t623:     var p = join(path, self._index[i]);\n\t638:  * Stream `path` to the response.\n\t640:  * @param {String} path\n\t645: SendStream.prototype.stream = function(path, options){\n\t653:   var stream = fs.createReadStream(path, options);\n\t683:  * Set content-type based on `path`\n\t686:  * @param {String} path\n\t690: SendStream.prototype.type = function(path){\n\t693:   var type = mime.lookup(path);\n\t703:  * @param {String} path\n\t708: SendStream.prototype.setHeader = function setHeader(path, stat){\n\t711:   this.emit('headers', res, path, stat);\n\t731:  * Determine if path parts contain a dotfile.\n\t752:  * @param {String} path\n\t756: function decode(path) {\n\t758:     return decodeURIComponent(path)\n\n/node_modules/express/node_modules/send/Readme.md:\n\t24: ### send(req, path, [options])\n\t26: Create a new `SendStream` for the given path to send to a `res`. The `req` is\n\t27: the Node.js HTTP request and the `path` is a urlencoded path to send (urlencoded,\n\t28: not the actual file-system path).\n\t36:   the path itself without checking if the path actually exists on the\n\t77:   Serve files relative to `path`.\n\t85:   - `file` a file was requested `(path, stat)`\n\t86:   - `headers` the headers are about to be set on a file `(res, path, stat)`\n\t93: object, typically `send(req, path, options).pipe(res)`.\n\t147:   function headers(res, path, stat) {\n\t161:   send(req, url.parse(req.url).pathname, {root: '/www/example.com/public'})\n\n/node_modules/express/node_modules/send/node_modules/mime/mime.js:\n\t1: var path = require('path');\n\t47:  * @param file (String) path of file to load.\n\t71: Mime.prototype.lookup = function(path, fallback) {\n\t72:   var ext = path.replace(/.*[\\.\\/\\\\]/, '').toLowerCase();\n\t90: mime.load(path.join(__dirname, 'types/mime.types'));\n\t93: mime.load(path.join(__dirname, 'types/node.types'));\n\n/node_modules/express/node_modules/send/node_modules/mime/README.md:\n\t13: ### mime.lookup(path)\n\t14: Get the mime type associated with a file, if no mime type is found `application/octet-stream` is returned. Performs a case-insensitive lookup using the extension in `path` (the substring after the last '/' or '.').  E.g.\n\t18:     mime.lookup('/path/to/file.txt');         // => 'text/plain'\n\t60: ### mime.load(filepath)\n\n/node_modules/express/node_modules/send/node_modules/mime/test.js:\n\t7: var path = require('path');\n\t70: apacheTypes.load(path.join(__dirname, 'types/mime.types'));\n\t71: nodeTypes.load(path.join(__dirname, 'types/node.types'));\n\n/node_modules/express/node_modules/send/node_modules/mime/types/mime.types:\n\t177: application/pkix-pkipath\t\t\tpkipath\n\t490: # application/vnd.innopath.wamp.notification\n\n/node_modules/express/node_modules/serve-static/HISTORY.md:\n\t57:     - Fix a path traversal issue when using `root`\n\t58:     - Fix malicious path detection for empty string path\n\t114:     - Simplify the \"fast-path\" `RegExp`\n\t185:   * Resolve relative paths at middleware setup\n\n/node_modules/express/node_modules/serve-static/index.js:\n\t16: var resolve = require('path').resolve;\n\t29:     throw new TypeError('root path required')\n\t33:     throw new TypeError('root path must be a string')\n\t64:     var path = parseurl(req).pathname\n\t65:     var hasTrailingSlash = originalUrl.pathname[originalUrl.pathname.length - 1] === '/'\n\t67:     if (path === '/' && !hasTrailingSlash) {\n\t69:       path = ''\n\t73:     var stream = send(req, path, opts)\n\t83:         originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/')\n\n/node_modules/express/node_modules/serve-static/README.md:\n\t35: the path itself without checking if the path actually exists on the\n\t77: Redirect to trailing \"/\" when the pathname is a dir. Defaults to `true`.\n\t82: occur synchronously. The function is called as `fn(res, path, stat)`, where\n\t86:   - `path` the file path that is being sent\n\t126: function setHeaders(res, path) {\n\t127:   res.setHeader('Content-Disposition', contentDisposition(path))\n\n/node_modules/express/node_modules/type-is/node_modules/mime-types/index.js:\n\t21:   // remove any leading paths, though we should just use path.basename\n\n/node_modules/express/node_modules/type-is/node_modules/mime-types/README.md:\n\t40: ### mime.lookup(path)\n\n/node_modules/express/node_modules/type-is/node_modules/mime-types/node_modules/mime-db/db.json:\n\t785:   \"application/pkix-pkipath\": {\n\t787:     \"extensions\": [\"pkipath\"]\n\t2113:   \"application/vnd.innopath.wamp.notification\": {\n\n/node_modules/jade/History.md:\n\t16:   * Clean up path/fs functions in CLI as we no longer support node@0.6 ([@TimothyGu](https://github.com/TimothyGu))\n\t281:   * add support for 'include' and 'extends' to use paths relative to basedir\n\t527:   * Added  -p, --path <path> flag to jade(1)\n\n/node_modules/jade/jade.js:\n\t1050:  * @param {String} path\n\t1055: exports.compileFile = function (path, options) {\n\t1057:   options.filename = path;\n\t1102:  * Render a Jade file at the given `path`.\n\t1104:  * @param {String} path\n\t1111: exports.renderFile = function(path, options, fn){\n\t1119:       res = exports.renderFile(path, options);\n\t1128:   options.filename = path;\n\t1134:  * Compile a Jade file at the given `path` for use on the client.\n\t1136:  * @param {String} path\n\t1142: exports.compileFileClient = function(path, options){\n\t1143:   var key = path + ':client';\n\t1146:   options.filename = path;\n\t1596:         throw new Error('missing path for include:filter');\n\t1599:       var path = captures[1];\n\t1600:       var tok = this.tok('include', path);\n\t2749: var path = require('path');\n\t2752: var extname = path.extname;\n\t3191:    * Resolves a path relative to the template for use in\n\t3194:    * @param {String}  path\n\t3200:   resolvePath: function (path, purpose) {\n\t3201:     var p = require('path');\n\t3206:     if (path[0] !== '/' && !this.filename)\n\t3207:       throw new Error('the \"filename\" option is required to use \"' + purpose + '\" with \"relative\" paths');\n\t3209:     if (path[0] === '/' && !this.options.basedir)\n\t3210:       throw new Error('the \"basedir\" option is required to use \"' + purpose + '\" with \"absolute\" paths');\n\t3212:     path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename), path);\n\t3214:     if (basename(path).indexOf('.') === -1) path += '.jade';\n\t3216:     return path;\n\t3226:     var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');\n\t3227:     if ('.jade' != path.substr(-5)) path += '.jade';\n\t3229:     this.dependencies.push(path);\n\t3230:     var str = fs.readFileSync(path, 'utf8');\n\t3231:     var parser = new this.constructor(str, path, this.options);\n\t3306:     var path = this.resolvePath(tok.val.trim(), 'include');\n\t3307:     this.dependencies.push(path);\n\t3310:       var str = fs.readFileSync(path, 'utf8').replace(/\\r/g, '');\n\t3311:       var options = {filename: path};\n\t3322:     if ('.jade' != path.substr(-5)) {\n\t3323:       var str = fs.readFileSync(path, 'utf8').replace(/\\r/g, '');\n\t3327:     var str = fs.readFileSync(path, 'utf8');\n\t3328:     var parser = new this.constructor(str, path, this.options);\n\t3339:     ast.filename = path;\n\t3569: },{\"./filters\":3,\"./lexer\":6,\"./nodes\":16,\"./utils\":25,\"character-parser\":29,\"constantinople\":30,\"fs\":26,\"path\":27}],24:[function(require,module,exports){\n\t3797:   err.path = filename;\n\t3883: // resolves . and .. elements in a path array with directory names there\n\t3886: // relative and absolute paths)\n\t3888:   // if the path tries to go above the root, `up` ends up > 0\n\t3903:   // if the path is allowed to go above the root, restore leading ..s\n\t3915: var splitPathRe =\n\t3917: var splitPath = function(filename) {\n\t3918:   return splitPathRe.exec(filename).slice(1);\n\t3921: // path.resolve([from ...], to)\n\t3924:   var resolvedPath = '',\n\t3928:     var path = (i >= 0) ? arguments[i] : process.cwd();\n\t3931:     if (typeof path !== 'string') {\n\t3932:       throw new TypeError('Arguments to path.resolve must be strings');\n\t3933:     } else if (!path) {\n\t3937:     resolvedPath = path + '/' + resolvedPath;\n\t3938:     resolvedAbsolute = path.charAt(0) === '/';\n\t3941:   // At this point the path should be resolved to a full absolute path, but\n\t3942:   // handle relative paths to be safe (might happen when process.cwd() fails)\n\t3944:   // Normalize the path\n\t3945:   resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n\t3949:   return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n\t3952: // path.normalize(path)\n\t3954: exports.normalize = function(path) {\n\t3955:   var isAbsolute = exports.isAbsolute(path),\n\t3956:       trailingSlash = substr(path, -1) === '/';\n\t3958:   // Normalize the path\n\t3959:   path = normalizeArray(filter(path.split('/'), function(p) {\n\t3963:   if (!path && !isAbsolute) {\n\t3964:     path = '.';\n\t3966:   if (path && trailingSlash) {\n\t3967:     path += '/';\n\t3970:   return (isAbsolute ? '/' : '') + path;\n\t3974: exports.isAbsolute = function(path) {\n\t3975:   return path.charAt(0) === '/';\n\t3980:   var paths = Array.prototype.slice.call(arguments, 0);\n\t3981:   return exports.normalize(filter(paths, function(p, index) {\n\t3983:       throw new TypeError('Arguments to path.join must be strings');\n\t3990: // path.relative(from, to)\n\t4036: exports.dirname = function(path) {\n\t4037:   var result = splitPath(path),\n\t4055: exports.basename = function(path, ext) {\n\t4056:   var f = splitPath(path)[2];\n\t4065: exports.extname = function(path) {\n\t4066:   return splitPath(path)[3];\n\n/node_modules/jade/Readme_zh-cn.md:\n\t1197: \tjade < $< --path $< > $@\n\t1224:   -p, --path <path>  在处理 stdio 时，查找包含文件时的查找路径\n\n/node_modules/jade/release.js:\n\t22:       path: info.path.replace(/^\\.\\//, ''),\n\t23:       content: fs.readFileSync(info.fullPath)\n\n/node_modules/jade/runtime.js:\n\t229:   err.path = filename;\n\n/node_modules/jade/bin/jade.js:\n\t9:   , path = require('path')\n\t10:   , basename = path.basename\n\t11:   , dirname = path.dirname\n\t12:   , resolve = path.resolve\n\t13:   , normalize = path.normalize\n\t14:   , join = path.join\n\t27:   .option('-O, --obj <str|path>', 'JavaScript options object or JSON file containing it')\n\t29:   .option('-p, --path <path>', 'filename used to resolve includes')\n\t36:   .option('--name-after-file', 'Name the template after the last section of the file path (requires --client and overriden by --name)')\n\t84: // --path\n\t86: if (program.path) options.filename = program.path;\n\t114: // left-over args are file paths\n\t118: // array of paths that are being watched\n\t143:  * Watch for changes on path\n\t145:  * Renders `base` if specified, otherwise renders `path`.\n\t147: function watchFile(path, base) {\n\t148:   path = normalize(path);\n\t149:   if (watchList.indexOf(path) !== -1) return;\n\t150:   console.log(\"  \\033[90mwatching \\033[36m%s\\033[0m\", path);\n\t151:   fs.watchFile(path, {persistent: true, interval: 200},\n\t157:     tryRender(base || path);\n\t159:   watchList.push(path);\n\t170:  * Try to render `path`; if an exception is thrown it is printed to stderr and\n\t175: function tryRender(path) {\n\t177:     renderFile(path);\n\t212:  * Process the given path, compiling the jade files found.\n\t216: function renderFile(path) {\n\t218:   var stat = fs.lstatSync(path);\n\t220:   if (stat.isFile() && re.test(path)) {\n\t221:     if (options.watch) watchFile(path);\n\t222:     var str = fs.readFileSync(path, 'utf8');\n\t223:     options.filename = path;\n\t225:       options.name = getNameFromFileName(path);\n\t231:         watchFile(dep, path);\n\t240:     path = path.replace(re, extname);\n\t241:     if (program.out) path = join(program.out, basename(path));\n\t242:     var dir = resolve(dirname(path));\n\t245:     fs.writeFileSync(path, output);\n\t246:     console.log('  \\033[90mrendered \\033[36m%s\\033[0m', normalize(path));\n\t249:     var files = fs.readdirSync(path);\n\t251:       return path + '/' + filename;\n\t257:  * Get a sensible name for a template function from a file path\n\n/node_modules/jade/lib/index.js:\n\t301:  * @param {String} path\n\t306: exports.compileFile = function (path, options) {\n\t308:   options.filename = path;\n\t353:  * Render a Jade file at the given `path`.\n\t355:  * @param {String} path\n\t362: exports.renderFile = function(path, options, fn){\n\t370:       res = exports.renderFile(path, options);\n\t379:   options.filename = path;\n\t385:  * Compile a Jade file at the given `path` for use on the client.\n\t387:  * @param {String} path\n\t393: exports.compileFileClient = function(path, options){\n\t394:   var key = path + ':client';\n\t397:   options.filename = path;\n\n/node_modules/jade/lib/lexer.js:\n\t408:         throw new Error('missing path for include:filter');\n\t411:       var path = captures[1];\n\t412:       var tok = this.tok('include', path);\n\n/node_modules/jade/lib/parser.js:\n\t7: var path = require('path');\n\t10: var extname = path.extname;\n\t449:    * Resolves a path relative to the template for use in\n\t452:    * @param {String}  path\n\t458:   resolvePath: function (path, purpose) {\n\t459:     var p = require('path');\n\t464:     if (path[0] !== '/' && !this.filename)\n\t465:       throw new Error('the \"filename\" option is required to use \"' + purpose + '\" with \"relative\" paths');\n\t467:     if (path[0] === '/' && !this.options.basedir)\n\t468:       throw new Error('the \"basedir\" option is required to use \"' + purpose + '\" with \"absolute\" paths');\n\t470:     path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename), path);\n\t472:     if (basename(path).indexOf('.') === -1) path += '.jade';\n\t474:     return path;\n\t484:     var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');\n\t485:     if ('.jade' != path.substr(-5)) path += '.jade';\n\t487:     this.dependencies.push(path);\n\t488:     var str = fs.readFileSync(path, 'utf8');\n\t489:     var parser = new this.constructor(str, path, this.options);\n\t564:     var path = this.resolvePath(tok.val.trim(), 'include');\n\t565:     this.dependencies.push(path);\n\t568:       var str = fs.readFileSync(path, 'utf8').replace(/\\r/g, '');\n\t569:       var options = {filename: path};\n\t580:     if ('.jade' != path.substr(-5)) {\n\t581:       var str = fs.readFileSync(path, 'utf8').replace(/\\r/g, '');\n\t585:     var str = fs.readFileSync(path, 'utf8');\n\t586:     var parser = new this.constructor(str, path, this.options);\n\t597:     ast.filename = path;\n\n/node_modules/jade/lib/runtime.js:\n\t228:   err.path = filename;\n\n/node_modules/jade/node_modules/commander/index.js:\n\t8: var path = require('path');\n\t9: var dirname = path.dirname;\n\t10: var basename = path.basename;\n\t112:  *        .option('-C, --chdir <path>', 'change the working directory')\n\t113:  *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')\n\t326:  *     program.option('-C, --chdir <path>', 'change the working directory');\n\t464:   var local = path.join(dir, bin);\n\n/node_modules/jade/node_modules/commander/Readme.md:\n\t237:   .option('-C, --chdir <path>', 'change the working directory')\n\t238:   .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')\n\n/node_modules/jade/node_modules/constantinople/node_modules/acorn-globals/node_modules/acorn/bin/acorn:\n\t3: var path = require(\"path\");\n\t11:   print(\"usage: \" + path.basename(process.argv[1]) + \" [--ecma3|--ecma5|--ecma6] [--strictSemicolons]\");\n\n/node_modules/jade/node_modules/constantinople/node_modules/acorn-globals/node_modules/acorn/test/driver.js:\n\t70:   function addPath(str, pt) {\n\t84:         if (mis) return addPath(mis, i);\n\t89:         if (mis) return addPath(mis, prop);\n\n/node_modules/jade/node_modules/constantinople/node_modules/acorn-globals/node_modules/acorn/test/jquery-string.js:\n\t835: \\t\\t// QSA path\\n\\\n\t3699: \\t\\t// the code to shortcut on the same path as a DOM node with no cache\\n\\\n\t3817: \\t\\t\\t\\t// This will only penalize the array argument path.\\n\\\n\t4468: \\t\\t\\teventPath = [ elem || document ],\\n\\\n\t4521: \\t\\t// Determine event propagation path in advance, per W3C events spec (#9951)\\n\\\n\t4530: \\t\\t\\t\\teventPath.push( cur );\\n\\\n\t4536: \\t\\t\\t\\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\\n\\\n\t4540: \\t\\t// Fire handlers on the event path\\n\\\n\t4542: \\t\\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\\n\\\n\t4568: \\t\\t\\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\\n\\\n\t5451: \\t\\t// This path appears unavoidable for IE9. When cloning an object\\n\\\n\t6792: \\t\\t\\t\\t// style.removeAttribute is IE Only, but so apparently is this code path...\\n\\\n\n/node_modules/jade/node_modules/constantinople/node_modules/acorn-globals/node_modules/acorn/test/compare/esprima.js:\n\t5052:                 // Try first to convert to a string. This is good as fast path\n\t5157:                 // Try first to convert to a string. This is good as fast path\n\n/node_modules/jade/node_modules/constantinople/node_modules/acorn-globals/node_modules/acorn/test/compare/traceur.js:\n\t602:   function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n\t617:     if (opt_path) {\n\t618:       out.push(opt_path);\n\t635:     PATH: 5,\n\t642:   function removeDotSegments(path) {\n\t643:     if (path === '/')\n\t645:     var leadingSlash = path[0] === '/' ? '/' : '';\n\t646:     var trailingSlash = path.slice(-1) === '/' ? '/' : '';\n\t647:     var segments = path.split('/');\n\t675:   function joinAndCanonicalizePath(parts) {\n\t676:     var path = parts[ComponentIndex.PATH] || '';\n\t677:     path = removeDotSegments(path);\n\t678:     parts[ComponentIndex.PATH] = path;\n\t679:     return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);\n\t683:     return joinAndCanonicalizePath(parts);\n\t689:       return joinAndCanonicalizePath(parts);\n\t698:     if (parts[ComponentIndex.PATH][0] == '/') {\n\t699:       return joinAndCanonicalizePath(parts);\n\t701:     var path = baseParts[ComponentIndex.PATH];\n\t702:     var index = path.lastIndexOf('/');\n\t703:     path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];\n\t704:     parts[ComponentIndex.PATH] = path;\n\t705:     return joinAndCanonicalizePath(parts);\n\t2432:     flags.option('--type-assertion-module <path>', 'Absolute path to the type assertion module.', (function(path) {\n\t2433:       commandOptions.setOption('type-assertion-module', path);\n\t2434:       return path;\n\t13475:       var depPaths = this.dependencies.map((function(dep) {\n\t13476:         return dep.path;\n\t13486:         return parseStatements($__247, this.moduleName, depPaths, func);\n\t13488:         return parseStatements($__248, depPaths, func);\n\t13494:         path: tree.token,\n\t19113:         path: match[5]\n\t19132:       if (aParsedUrl.path) {\n\t19133:         url += aParsedUrl.path;\n\t19138:     function normalize(aPath) {\n\t19139:       var path = aPath;\n\t19140:       var url = urlParse(aPath);\n\t19142:         if (!url.path) {\n\t19143:           return aPath;\n\t19145:         path = url.path;\n\t19147:       var isAbsolute = (path.charAt(0) === '/');\n\t19148:       var parts = path.split(/\\/+/);\n\t19167:       path = parts.join('/');\n\t19168:       if (path === '') {\n\t19169:         path = isAbsolute ? '/' : '.';\n\t19172:         url.path = path;\n\t19175:       return path;\n\t19178:     function join(aRoot, aPath) {\n\t19179:       var aPathUrl = urlParse(aPath);\n\t19182:         aRoot = aRootUrl.path || '/';\n\t19184:       if (aPathUrl && !aPathUrl.scheme) {\n\t19186:           aPathUrl.scheme = aRootUrl.scheme;\n\t19188:         return urlGenerate(aPathUrl);\n\t19190:       if (aPathUrl || aPath.match(dataUrlRegexp)) {\n\t19191:         return aPath;\n\t19193:       if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n\t19194:         aRootUrl.host = aPath;\n\t19197:       var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\t19199:         aRootUrl.path = joined;\n\t19213:     function relative(aRoot, aPath) {\n\t19216:       if (aPath.charAt(0) == \"/\" && url && url.path == \"/\") {\n\t19217:         return aPath.slice(1);\n\t19219:       return aPath.indexOf(aRoot + '/') === 0 ? aPath.substr(aRoot.length + 1) : aPath;\n\t19525:     SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n\t19546:             if (aSourceMapPath) {\n\t19547:               mapping.source = util.join(aSourceMapPath, mapping.source);\n\t19573:           if (aSourceMapPath) {\n\t19574:             sourceFile = util.join(aSourceMapPath, sourceFile);\n\t19847:         var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n\t19848:         if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n\t19849:           return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n\t19851:         if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + aSource)) {\n\t22386:           var subPath = name.split('/').splice(curMatchLength).join('/');\n\t22387:           mappedName = map[curParent][curMatch] + (subPath ? '/' + subPath : '');\n\t22405:     var subPath = name.split('/').splice(curMatchLength).join('/');\n\t22406:     return map[curMatch] + (subPath ? '/' + subPath : '');\n\t23076:       var path = normalizedName || String(uniqueNameCount++);\n\t23077:       return resolveUrl(importerAddress, path);\n\n/node_modules/jade/node_modules/mkdirp/index.js:\n\t1: var path = require('path');\n\t24:     p = path.resolve(p);\n\t33:                 mkdirP(path.dirname(p), opts, function (er, made) {\n\t67:     p = path.resolve(p);\n\t76:                 made = sync(path.dirname(p), opts, made);\n\n/node_modules/jade/node_modules/mkdirp/readme.markdown:\n\t46: `opts.fs`. Your implementation should have `opts.fs.mkdir(path, mode, cb)` and\n\t47: `opts.fs.stat(path, cb)`.\n\t60: `opts.fs`. Your implementation should have `opts.fs.mkdirSync(path, mode)` and\n\t61: `opts.fs.statSync(path)`.\n\n/node_modules/jade/node_modules/mkdirp/bin/cmd.js:\n\t16: var paths = argv._.slice();\n\t20:     if (paths.length === 0) return;\n\t21:     var p = paths.shift();\n\n/node_modules/jade/node_modules/mkdirp/test/chmod.js:\n\t2: var path = require('path');\n\n/node_modules/jade/node_modules/mkdirp/test/clobber.js:\n\t2: var path = require('path');\n\n/node_modules/jade/node_modules/mkdirp/test/mkdirp.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/jade/node_modules/mkdirp/test/opts_fs.js:\n\t2: var path = require('path');\n\n/node_modules/jade/node_modules/mkdirp/test/opts_fs_sync.js:\n\t2: var path = require('path');\n\n/node_modules/jade/node_modules/mkdirp/test/perm.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/jade/node_modules/mkdirp/test/perm_sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/jade/node_modules/mkdirp/test/race.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/jade/node_modules/mkdirp/test/rel.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/jade/node_modules/mkdirp/test/return.js:\n\t2: var path = require('path');\n\n/node_modules/jade/node_modules/mkdirp/test/return_sync.js:\n\t2: var path = require('path');\n\n/node_modules/jade/node_modules/mkdirp/test/root.js:\n\t2: var path = require('path');\n\t8:     var file = path.resolve('/');\n\n/node_modules/jade/node_modules/mkdirp/test/sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/jade/node_modules/mkdirp/test/umask.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/jade/node_modules/mkdirp/test/umask_sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/jade/node_modules/transformers/history.md:\n\t30:  - FIX lookup paths for **component** weren't set so you couldn't build components with dependancies\n\n/node_modules/jade/node_modules/transformers/lib/shared.js:\n\t3: var path = require('path');\n\t4: var normalize = path.normalize;\n\t115: Transformer.prototype.renderFile = function (path, options, cb) {\n\t119:     options.filename = (path = normalize(path));\n\t120:     if (self._cache[path])\n\t123:       fs.readFile(path, function (err, data) {\n\t133: Transformer.prototype.renderFileSync = function (path, options) {\n\t135:   options.filename = (path = normalize(path));\n\t136:   return this.renderSync((this._cache[path] ? null : fs.readFileSync(path)), options);\n\n/node_modules/jade/node_modules/transformers/lib/transformers.js:\n\t1: var dirname = require('path').dirname;\n\t66:         delete options.filename; //atpl can't handle absolute windows file paths properly\n\t300:     this.engine.onLoad = function(path, callback){\n\t301:       if ('' == extname(path)) path += '.' + ext;\n\t302:       if ('/' !== path[0]) path = views + '/' + path;\n\t303:       read(path, options, callback);\n\t353:       options.paths = options.paths || [dirname(options.filename)];\n\t391:       options.paths = options.paths || [dirname(options.filename)];\n\t508:     var path = require('path');\n\t509:     builder.paths = (options.paths || ['components']).map(function (p) {\n\t510:       if (path.resolve(p) === p) {\n\t513:         return path.join(dirname(options.filename), p);\n\t537:     var path = require('path');\n\t538:     builder.paths = (options.paths || ['components']).map(function (p) {\n\t539:       if (path.resolve(p) === p) {\n\t542:         return path.join(dirname(options.filename), p);\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/README.md:\n\t50:     --source-map-root  The path to the original source to be included in the\n\t52:     --source-map-url   The path to the source map to be added in //@\n\t59:                        names and ensure they are relative paths.\n\t102: `--source-map output.js.map` (full path to the file where you want the\n\t106: original files can be found.  In case you are passing full paths to input\n\t108: directories to drop from the path prefix when declaring files in the source\n\t138: /path/to/input/source.map`.  Normally the input source map should also point\n\t338:     var result = UglifyJS.minify(\"/path/to/file.js\");\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/bin/uglifyjs:\n\t21:     .describe(\"source-map-root\", \"The path to the original source to be included in the source map.\")\n\t22:     .describe(\"source-map-url\", \"The path to the source map to be added in //@ sourceMappingURL.  Defaults to the value passed with --source-map.\")\n\t25: For example -p 3 will drop 3 directories from file names and ensure they are relative paths.\")\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/optimist/index.js:\n\t1: var path = require('path');\n\t36:             path.dirname(process.execPath) + '/', ''\n\t445: // rebase an absolute path to a relative one with respect to a base directory\n\t449:     var ds = path.normalize(dir).split('/').slice(1);\n\t450:     var bs = path.normalize(base).split('/').slice(1);\n\t455:     var p = path.normalize(\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/optimist/readme.markdown:\n\t460: When you use dots (`.`s) in argument names, an implicit object path is assumed.\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/optimist/node_modules/wordwrap/test/idleness.txt:\n\t55: In the past, there was a small leisure class and a larger working class. The leisure class enjoyed advantages for which there was no basis in social justice; this necessarily made it oppressive, limited its sympathies, and caused it to invent theories by which to justify its privileges. These facts greatly diminished its excellence, but in spite of this drawback it contributed nearly the whole of what we call civilization. It cultivated the arts and discovered the sciences; it wrote the books, invented the philosophies, and refined social relations. Even the liberation of the oppressed has usually been inaugurated from above. Without the leisure class, mankind would never have emerged from barbarism.\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/optimist/test/parse.js:\n\t2: var path = require('path');\n\t5: var $0 = 'node ./' + path.relative(process.cwd(), __filename);\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/CHANGELOG.md:\n\t35: * Fix a bug where finding relative paths from an empty path were creating\n\t36:   absolute paths. See issue #129.\n\t40: * Fix a bug where if the source root was an empty string, relative source paths\n\t41:   would turn into absolute source paths. Issue #124.\n\t50:   to specify a path that relative sources in the second parameter should be\n\t69: * Fix some edge cases surrounding path joining and URL resolution.\n\t71: * Add a third parameter for relative path to\n\t133: * Fix issue with absolute paths and `file://` URIs. See\n\t138: * Fix issue with absolute paths and sourcesContent, github issue 64.\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/Makefile.dryice.js:\n\t7: var path = require('path');\n\t33:     roots: [ path.join(__dirname, 'lib') ]\n\t69:     roots: [ path.join(__dirname, 'lib') ]\n\t95:     roots: [ __dirname, path.join(__dirname, 'lib') ]\n\t120:   var testFiles = fs.readdirSync(path.join(__dirname, 'test', 'source-map')).filter(isTestFile);\n\t123:     console.log('\\nCreating', path.join('dist', 'test', testFile.replace(/\\-/g, '_')));\n\t128:         path.join('test', 'source-map', testFile),\n\t137:                                + path.join('test', 'source-map', testFile.replace(/\\.js$/, ''))\n\t146:       dest: path.join('dist', 'test', testFile.replace(/\\-/g, '_'))\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/README.md:\n\t310: #### SourceMapGenerator.prototype.applySourceMap(sourceMapConsumer[, sourceFile[, sourceMapPath]])\n\t323: * `sourceMapPath`: Optional. The dirname of the path to the SourceMap\n\t328:   paths. If so, those relative source paths need to be rewritten\n\t361: #### SourceNode.fromStringWithSourceMap(code, sourceMapConsumer[, relativePath])\n\t369: * `relativePath` The optional path that relative sources in `sourceMapConsumer`\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/build/mini-require.js:\n\t80:   function normalize(path) {\n\t81:     var bits = path.split('/');\n\t105:   function dirname(path) {\n\t106:     var bits = path.split('/');\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/lib/source-map/source-map-consumer.js:\n\t69:     // Some source maps produce relative source paths like \"./foo.js\" instead of\n\t141:   //       source: The path to the original source file that generated this\n\t399:         // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n\t403:         var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n\t405:             && this._sources.has(fileUriAbsPath)) {\n\t406:           return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n\t409:         if ((!url.path || url.path == \"/\")\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/lib/source-map/source-map-generator.js:\n\t162:    * @param aSourceMapPath Optional. The dirname of the path to the source map\n\t166:    *        paths. If so, those relative source paths need to be rewritten\n\t170:     function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n\t203:             if (aSourceMapPath != null) {\n\t204:               mapping.source = util.join(aSourceMapPath, mapping.source)\n\t235:           if (aSourceMapPath != null) {\n\t236:             sourceFile = util.join(aSourceMapPath, sourceFile);\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/lib/source-map/source-node.js:\n\t55:    * @param aRelativePath Optional. The path that relative sources in the\n\t59:     function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n\t140:           if (aRelativePath != null) {\n\t141:             sourceFile = util.join(aRelativePath, sourceFile);\n\t153:           var source = aRelativePath\n\t154:             ? util.join(aRelativePath, mapping.source)\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/lib/source-map/util.js:\n\t46:       path: match[5]\n\t66:     if (aParsedUrl.path) {\n\t67:       url += aParsedUrl.path;\n\t74:    * Normalizes a path, or the path portion of a URL:\n\t80:    * Based on code in the Node.js 'path' core module.\n\t82:    * @param aPath The path or url to normalize.\n\t84:   function normalize(aPath) {\n\t85:     var path = aPath;\n\t86:     var url = urlParse(aPath);\n\t88:       if (!url.path) {\n\t89:         return aPath;\n\t91:       path = url.path;\n\t93:     var isAbsolute = (path.charAt(0) === '/');\n\t95:     var parts = path.split(/\\/+/);\n\t104:           // The first part is blank if the path is absolute. Trying to go\n\t115:     path = parts.join('/');\n\t117:     if (path === '') {\n\t118:       path = isAbsolute ? '/' : '.';\n\t122:       url.path = path;\n\t125:     return path;\n\t130:    * Joins two paths/URLs.\n\t132:    * @param aRoot The root path or URL.\n\t133:    * @param aPath The path or URL to be joined with the root.\n\t135:    * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n\t138:    * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n\t141:    *   - If aPath is absolute, the result is aPath.\n\t142:    *   - Otherwise the two paths are joined with a slash.\n\t145:   function join(aRoot, aPath) {\n\t149:     if (aPath === \"\") {\n\t150:       aPath = \".\";\n\t152:     var aPathUrl = urlParse(aPath);\n\t155:       aRoot = aRootUrl.path || '/';\n\t159:     if (aPathUrl && !aPathUrl.scheme) {\n\t161:         aPathUrl.scheme = aRootUrl.scheme;\n\t163:       return urlGenerate(aPathUrl);\n\t166:     if (aPathUrl || aPath.match(dataUrlRegexp)) {\n\t167:       return aPath;\n\t171:     if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n\t172:       aRootUrl.host = aPath;\n\t176:     var joined = aPath.charAt(0) === '/'\n\t177:       ? aPath\n\t178:       : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\t181:       aRootUrl.path = joined;\n\t189:    * Make a path relative to a URL or another path.\n\t191:    * @param aRoot The root path or URL.\n\t192:    * @param aPath The path or URL to be made relative to aRoot.\n\t194:   function relative(aRoot, aPath) {\n\t203:     if (aPath.charAt(0) == \"/\" && url && url.path == \"/\") {\n\t204:       return aPath.slice(1);\n\t207:     return aPath.indexOf(aRoot + '/') === 0\n\t208:       ? aPath.substr(aRoot.length + 1)\n\t209:       : aPath;\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/node_modules/amdefine/amdefine.js:\n\t26:         path = require('path'),\n\t30:      * Trims the . and .. from an array of path segments.\n\t31:      * It will keep a leading path segment if a .. will become\n\t32:      * the first path segment, to help with module name lookups,\n\t33:      * which act like paths, but can be remapped. But the end result,\n\t34:      * all paths that use this function should look normalized.\n\t36:      * @param {Array} ary the array of path segments.\n\t48:                     //path segment at the front so it can be mapped\n\t50:                     //no path mapping for a path starting with '..'.\n\t65:         //Adjust any relative paths.\n\t99:             //define, and any relative paths and requires should be relative\n\t129:         amdRequire.toUrl = function (filePath) {\n\t130:             if (filePath.indexOf('.') === 0) {\n\t131:                 return normalize(filePath, path.dirname(module.filename));\n\t133:                 return filePath;\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/node_modules/amdefine/package.json:\n\t29:   \"readme\": \"# amdefine\\n\\nA module that can be used to implement AMD's define() in Node. This allows you\\nto code to the AMD API and have the module work in node programs without\\nrequiring those other programs to use AMD.\\n\\n## Usage\\n\\n**1)** Update your package.json to indicate amdefine as a dependency:\\n\\n```javascript\\n    \\\"dependencies\\\": {\\n        \\\"amdefine\\\": \\\">=0.1.0\\\"\\n    }\\n```\\n\\nThen run `npm install` to get amdefine into your project.\\n\\n**2)** At the top of each module that uses define(), place this code:\\n\\n```javascript\\nif (typeof define !== 'function') { var define = require('amdefine')(module) }\\n```\\n\\n**Only use these snippets** when loading amdefine. If you preserve the basic structure,\\nwith the braces, it will be stripped out when using the [RequireJS optimizer](#optimizer).\\n\\nYou can add spaces, line breaks and even require amdefine with a local path, but\\nkeep the rest of the structure to get the stripping behavior.\\n\\nAs you may know, because `if` statements in JavaScript don't have their own scope, the var\\ndeclaration in the above snippet is made whether the `if` expression is truthy or not. If\\nRequireJS is loaded then the declaration is superfluous because `define` is already already\\ndeclared in the same scope in RequireJS. Fortunately JavaScript handles multiple `var`\\ndeclarations of the same variable in the same scope gracefully.\\n\\nIf you want to deliver amdefine.js with your code rather than specifying it as a dependency\\nwith npm, then just download the latest release and refer to it using a relative path:\\n\\n[Latest Version](https://github.com/jrburke/amdefine/raw/latest/amdefine.js)\\n\\n### amdefine/intercept\\n\\nConsider this very experimental.\\n\\nInstead of pasting the piece of text for the amdefine setup of a `define`\\nvariable in each module you create or consume, you can use `amdefine/intercept`\\ninstead. It will automatically insert the above snippet in each .js file loaded\\nby Node.\\n\\n**Warning**: you should only use this if you are creating an application that\\nis consuming AMD style defined()'d modules that are distributed via npm and want\\nto run that code in Node.\\n\\nFor library code where you are not sure if it will be used by others in Node or\\nin the browser, then explicitly depending on amdefine and placing the code\\nsnippet above is suggested path, instead of using `amdefine/intercept`. The\\nintercept module affects all .js files loaded in the Node app, and it is\\ninconsiderate to modify global state like that unless you are also controlling\\nthe top level app.\\n\\n#### Why distribute AMD-style nodes via npm?\\n\\nnpm has a lot of weaknesses for front-end use (installed layout is not great,\\nshould have better support for the `baseUrl + moduleID + '.js' style of loading,\\nsingle file JS installs), but some people want a JS package manager and are\\nwilling to live with those constraints. If that is you, but still want to author\\nin AMD style modules to get dynamic require([]), better direct source usage and\\npowerful loader plugin support in the browser, then this tool can help.\\n\\n#### amdefine/intercept usage\\n\\nJust require it in your top level app module (for example index.js, server.js):\\n\\n```javascript\\nrequire('amdefine/intercept');\\n```\\n\\nThe module does not return a value, so no need to assign the result to a local\\nvariable.\\n\\nThen just require() code as you normally would with Node's require(). Any .js\\nloaded after the intercept require will have the amdefine check injected in\\nthe .js source as it is loaded. It does not modify the source on disk, just\\nprepends some content to the text of the module as it is loaded by Node.\\n\\n#### How amdefine/intercept works\\n\\nIt overrides the `Module._extensions['.js']` in Node to automatically prepend\\nthe amdefine snippet above. So, it will affect any .js file loaded by your\\napp.\\n\\n## define() usage\\n\\nIt is best if you use the anonymous forms of define() in your module:\\n\\n```javascript\\ndefine(function (require) {\\n    var dependency = require('dependency');\\n});\\n```\\n\\nor\\n\\n```javascript\\ndefine(['dependency'], function (dependency) {\\n\\n});\\n```\\n\\n## RequireJS optimizer integration. <a name=\\\"optimizer\\\"></name>\\n\\nVersion 1.0.3 of the [RequireJS optimizer](http://requirejs.org/docs/optimization.html)\\nwill have support for stripping the `if (typeof define !== 'function')` check\\nmentioned above, so you can include this snippet for code that runs in the\\nbrowser, but avoid taking the cost of the if() statement once the code is\\noptimized for deployment.\\n\\n## Node 0.4 Support\\n\\nIf you want to support Node 0.4, then add `require` as the second parameter to amdefine:\\n\\n```javascript\\n//Only if you want Node 0.4. If using 0.5 or later, use the above snippet.\\nif (typeof define !== 'function') { var define = require('amdefine')(module, require) }\\n```\\n\\n## Limitations\\n\\n### Synchronous vs Asynchronous\\n\\namdefine creates a define() function that is callable by your code. It will\\nexecute and trace dependencies and call the factory function *synchronously*,\\nto keep the behavior in line with Node's synchronous dependency tracing.\\n\\nThe exception: calling AMD's callback-style require() from inside a factory\\nfunction. The require callback is called on process.nextTick():\\n\\n```javascript\\ndefine(function (require) {\\n    require(['a'], function(a) {\\n        //'a' is loaded synchronously, but\\n        //this callback is called on process.nextTick().\\n    });\\n});\\n```\\n\\n### Loader Plugins\\n\\nLoader plugins are supported as long as they call their load() callbacks\\nsynchronously. So ones that do network requests will not work. However plugins\\nlike [text](http://requirejs.org/docs/api.html#text) can load text files locally.\\n\\nThe plugin API's `load.fromText()` is **not supported** in amdefine, so this means\\ntranspiler plugins like the [CoffeeScript loader plugin](https://github.com/jrburke/require-cs)\\nwill not work. This may be fixable, but it is a bit complex, and I do not have\\nenough node-fu to figure it out yet. See the source for amdefine.js if you want\\nto get an idea of the issues involved.\\n\\n## Tests\\n\\nTo run the tests, cd to **tests** and run:\\n\\n```\\nnode all.js\\nnode all-intercept.js\\n```\\n\\n## License\\n\\nNew BSD and MIT. Check the LICENSE file for all the details.\\n\",\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/node_modules/amdefine/README.md:\n\t28: You can add spaces, line breaks and even require amdefine with a local path, but\n\t38: with npm, then just download the latest release and refer to it using a relative path:\n\t57: snippet above is suggested path, instead of using `amdefine/intercept`. The\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/test/run-tests.js:\n\t10: var path = require('path');\n\t43:     ? path.basename(testToRun) === f\n\t51: var requires = fs.readdirSync(path.join(__dirname, 'source-map'))\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/test/source-map/test-source-map-consumer.js:\n\t255:   exports['test that we can get the original source content with relative source paths'] = function (assert, util) {\n\t523:   exports['test absolute path, but same host sources'] = function (assert, util) {\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/test/source-map/test-source-map-generator.js:\n\t417:     var actualMap = function (aSourceMapPath) {\n\t421:       map.applySourceMap(bundleMap, '../temp/bundle.js', aSourceMapPath);\n\t444:     // directory we get incorrect source paths:\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/test/source-map/test-source-node.js:\n\t311:     var test = function(relativePath, expectedSources) {\n\t316:                                 relativePath));\n\t337:     // directory we get incorrect source paths:\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/test/run-tests.js:\n\t4: var path = require(\"path\");\n\t9: var tests_dir = path.dirname(module.filename);\n\t50:     return path.resolve(tests_dir, dir);\n\t88:         var tests = parse_test(path.resolve(dir, file));\n\n/node_modules/jade/node_modules/transformers/node_modules/uglify-js/tools/node.js:\n\t1: var path = require(\"path\");\n\t13:     file = path.resolve(path.dirname(module.filename), file);\n\t36:     return path.join(path.dirname(fs.realpathSync(__filename)), file);\n\n/node_modules/jade/node_modules/with/node_modules/acorn/bin/acorn:\n\t3: var path = require(\"path\");\n\t11:   print(\"usage: \" + path.basename(process.argv[1]) + \" [--ecma3|--ecma5|--ecma6] [--strictSemicolons]\");\n\n/node_modules/jade/node_modules/with/node_modules/acorn/test/driver.js:\n\t70:   function addPath(str, pt) {\n\t84:         if (mis) return addPath(mis, i);\n\t89:         if (mis) return addPath(mis, prop);\n\n/node_modules/jade/node_modules/with/node_modules/acorn/test/jquery-string.js:\n\t835: \\t\\t// QSA path\\n\\\n\t3699: \\t\\t// the code to shortcut on the same path as a DOM node with no cache\\n\\\n\t3817: \\t\\t\\t\\t// This will only penalize the array argument path.\\n\\\n\t4468: \\t\\t\\teventPath = [ elem || document ],\\n\\\n\t4521: \\t\\t// Determine event propagation path in advance, per W3C events spec (#9951)\\n\\\n\t4530: \\t\\t\\t\\teventPath.push( cur );\\n\\\n\t4536: \\t\\t\\t\\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\\n\\\n\t4540: \\t\\t// Fire handlers on the event path\\n\\\n\t4542: \\t\\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\\n\\\n\t4568: \\t\\t\\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\\n\\\n\t5451: \\t\\t// This path appears unavoidable for IE9. When cloning an object\\n\\\n\t6792: \\t\\t\\t\\t// style.removeAttribute is IE Only, but so apparently is this code path...\\n\\\n\n/node_modules/jade/node_modules/with/node_modules/acorn/test/compare/esprima.js:\n\t5052:                 // Try first to convert to a string. This is good as fast path\n\t5157:                 // Try first to convert to a string. This is good as fast path\n\n/node_modules/jade/node_modules/with/node_modules/acorn/test/compare/traceur.js:\n\t602:   function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n\t617:     if (opt_path) {\n\t618:       out.push(opt_path);\n\t635:     PATH: 5,\n\t642:   function removeDotSegments(path) {\n\t643:     if (path === '/')\n\t645:     var leadingSlash = path[0] === '/' ? '/' : '';\n\t646:     var trailingSlash = path.slice(-1) === '/' ? '/' : '';\n\t647:     var segments = path.split('/');\n\t675:   function joinAndCanonicalizePath(parts) {\n\t676:     var path = parts[ComponentIndex.PATH] || '';\n\t677:     path = removeDotSegments(path);\n\t678:     parts[ComponentIndex.PATH] = path;\n\t679:     return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);\n\t683:     return joinAndCanonicalizePath(parts);\n\t689:       return joinAndCanonicalizePath(parts);\n\t698:     if (parts[ComponentIndex.PATH][0] == '/') {\n\t699:       return joinAndCanonicalizePath(parts);\n\t701:     var path = baseParts[ComponentIndex.PATH];\n\t702:     var index = path.lastIndexOf('/');\n\t703:     path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];\n\t704:     parts[ComponentIndex.PATH] = path;\n\t705:     return joinAndCanonicalizePath(parts);\n\t2432:     flags.option('--type-assertion-module <path>', 'Absolute path to the type assertion module.', (function(path) {\n\t2433:       commandOptions.setOption('type-assertion-module', path);\n\t2434:       return path;\n\t13475:       var depPaths = this.dependencies.map((function(dep) {\n\t13476:         return dep.path;\n\t13486:         return parseStatements($__247, this.moduleName, depPaths, func);\n\t13488:         return parseStatements($__248, depPaths, func);\n\t13494:         path: tree.token,\n\t19113:         path: match[5]\n\t19132:       if (aParsedUrl.path) {\n\t19133:         url += aParsedUrl.path;\n\t19138:     function normalize(aPath) {\n\t19139:       var path = aPath;\n\t19140:       var url = urlParse(aPath);\n\t19142:         if (!url.path) {\n\t19143:           return aPath;\n\t19145:         path = url.path;\n\t19147:       var isAbsolute = (path.charAt(0) === '/');\n\t19148:       var parts = path.split(/\\/+/);\n\t19167:       path = parts.join('/');\n\t19168:       if (path === '') {\n\t19169:         path = isAbsolute ? '/' : '.';\n\t19172:         url.path = path;\n\t19175:       return path;\n\t19178:     function join(aRoot, aPath) {\n\t19179:       var aPathUrl = urlParse(aPath);\n\t19182:         aRoot = aRootUrl.path || '/';\n\t19184:       if (aPathUrl && !aPathUrl.scheme) {\n\t19186:           aPathUrl.scheme = aRootUrl.scheme;\n\t19188:         return urlGenerate(aPathUrl);\n\t19190:       if (aPathUrl || aPath.match(dataUrlRegexp)) {\n\t19191:         return aPath;\n\t19193:       if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n\t19194:         aRootUrl.host = aPath;\n\t19197:       var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\t19199:         aRootUrl.path = joined;\n\t19213:     function relative(aRoot, aPath) {\n\t19216:       if (aPath.charAt(0) == \"/\" && url && url.path == \"/\") {\n\t19217:         return aPath.slice(1);\n\t19219:       return aPath.indexOf(aRoot + '/') === 0 ? aPath.substr(aRoot.length + 1) : aPath;\n\t19525:     SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n\t19546:             if (aSourceMapPath) {\n\t19547:               mapping.source = util.join(aSourceMapPath, mapping.source);\n\t19573:           if (aSourceMapPath) {\n\t19574:             sourceFile = util.join(aSourceMapPath, sourceFile);\n\t19847:         var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n\t19848:         if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n\t19849:           return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n\t19851:         if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + aSource)) {\n\t22386:           var subPath = name.split('/').splice(curMatchLength).join('/');\n\t22387:           mappedName = map[curParent][curMatch] + (subPath ? '/' + subPath : '');\n\t22405:     var subPath = name.split('/').splice(curMatchLength).join('/');\n\t22406:     return map[curMatch] + (subPath ? '/' + subPath : '');\n\t23076:       var path = normalizedName || String(uniqueNameCount++);\n\t23077:       return resolveUrl(importerAddress, path);\n\n/node_modules/mocha/mocha.js:\n\t6:     var path = require.resolve(p)\n\t7:       , mod = require.modules[path];\n\t11:       mod.call(mod.exports, mod, mod.exports, require.relative(path));\n\t18: require.resolve = function (path){\n\t19:     var orig = path\n\t20:       , reg = path + '.js'\n\t21:       , index = path + '/index.js';\n\t27: require.register = function (path, fn){\n\t28:     require.modules[path] = fn;\n\t35:       var path = parent.split('/')\n\t37:       path.pop();\n\t41:         if ('..' == seg) path.pop();\n\t42:         else if ('.' != seg) path.push(seg);\n\t45:       return require(path.join('/'));\n\t77:   function clonePath(path) {\n\t78:     return { newPos: path.newPos, components: path.components.slice(0) };\n\t120:         var bestPath = [{ newPos: -1, components: [] }];\n\t123:         var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\t124:         if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {\n\t125:           return bestPath[0].components;\n\t129:           for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {\n\t130:             var basePath;\n\t131:             var addPath = bestPath[diagonalPath-1],\n\t132:                 removePath = bestPath[diagonalPath+1];\n\t133:             oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\t134:             if (addPath) {\n\t136:               bestPath[diagonalPath-1] = undefined;\n\t139:             var canAdd = addPath && addPath.newPos+1 < newLen;\n\t140:             var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n\t142:               bestPath[diagonalPath] = undefined;\n\t147:             // path whose position in the new string is the farthest from the origin\n\t149:             if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n\t150:               basePath = clonePath(removePath);\n\t151:               this.pushComponent(basePath.components, oldString[oldPos], undefined, true);\n\t153:               basePath = clonePath(addPath);\n\t154:               basePath.newPos++;\n\t155:               this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);\n\t158:             var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);\n\t160:             if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {\n\t161:               return basePath.components;\n\t163:               bestPath[diagonalPath] = basePath;\n\t180:       extractCommon: function(basePath, newString, oldString, diagonalPath) {\n\t183:             newPos = basePath.newPos,\n\t184:             oldPos = newPos - diagonalPath;\n\t189:           this.pushComponent(basePath.components, newString[newPos], undefined, undefined);\n\t191:         basePath.newPos = newPos;\n\t635: require.register(\"browser/path.js\", function(module, exports, require){\n\t637: }); // module: browser/path.js\n\t744:     ctx.beginPath();\n\t750:     ctx.beginPath();\n\t1426: var path = require('browser/path')\n\t1441:   var join = path.join\n\t1443:   module.paths.push(cwd, join(cwd, 'node_modules'));\n\t1461:  * Return image `name` path.\n\t1598:     file = path.resolve(file);\n\t2788:   return window.location.pathname + (search ? search + '&' : '?' ) + 'grep=' + encodeURIComponent(s);\n\t5594:   , path = require('browser/path')\n\t5595:   , basename = path.basename\n\t5596:   , exists = fs.existsSync || path.existsSync\n\t5598:   , join = path.join\n\t5752: function ignored(path){\n\t5753:   return !~ignore.indexOf(path);\n\t5771:   .forEach(function(path){\n\t5772:     path = join(dir, path);\n\t5773:     if (fs.statSync(path).isDirectory()) {\n\t5774:       exports.files(path, ext, ret);\n\t5775:     } else if (path.match(re)) {\n\t5776:       ret.push(path);\n\t6071:  * Lookup file names at the given `path`.\n\t6073: exports.lookupFiles = function lookupFiles(path, extensions, recursive) {\n\t6077:   if (!exists(path)) {\n\t6078:     if (exists(path + '.js')) {\n\t6079:       path += '.js';\n\t6081:       files = glob.sync(path);\n\t6082:       if (!files.length) throw new Error(\"cannot resolve path (or pattern) '\" + path + \"'\");\n\t6088:     var stat = fs.statSync(path);\n\t6089:     if (stat.isFile()) return path;\n\t6095:   fs.readdirSync(path).forEach(function(file){\n\t6096:     file = join(path, file);\n\n/node_modules/mocha/bin/_mocha:\n\t8:   , path = require('path')\n\t10:   , resolve = path.resolve\n\t11:   , exists = fs.existsSync || path.existsSync\n\t14:   , join = path.join\n\t90:   .option('--opts <path>', 'specify opts path', 'test/mocha.opts')\n\t104:   .command('init <path>')\n\t105:   .description('initialize a client-side mocha setup at <path>')\n\t106:   .action(function(path){\n\t108:     mkdir.sync(path);\n\t112:     fs.writeFileSync(join(path, 'mocha.css'), css);\n\t113:     fs.writeFileSync(join(path, 'mocha.js'), js);\n\t114:     fs.writeFileSync(join(path, 'tests.js'), '');\n\t115:     fs.writeFileSync(join(path, 'index.html'), tmpl);\n\t162: module.paths.push(cwd, join(cwd, 'node_modules'));\n\t172: var optsPath = process.argv.indexOf('--opts') !== -1\n\t177:   var opts = fs.readFileSync(optsPath, 'utf8')\n\t321: files = files.map(function(path){\n\t322:   return resolve(path);\n\n/node_modules/mocha/lib/mocha.js:\n\t11: var path = require('path')\n\t26:   var join = path.join\n\t28:   module.paths.push(cwd, join(cwd, 'node_modules'));\n\t46:  * Return image `name` path.\n\t183:     file = path.resolve(file);\n\n/node_modules/mocha/lib/utils.js:\n\t6:   , path = require('path')\n\t7:   , basename = path.basename\n\t8:   , exists = fs.existsSync || path.existsSync\n\t10:   , join = path.join\n\t164: function ignored(path){\n\t165:   return !~ignore.indexOf(path);\n\t183:   .forEach(function(path){\n\t184:     path = join(dir, path);\n\t185:     if (fs.statSync(path).isDirectory()) {\n\t186:       exports.files(path, ext, ret);\n\t187:     } else if (path.match(re)) {\n\t188:       ret.push(path);\n\t483:  * Lookup file names at the given `path`.\n\t485: exports.lookupFiles = function lookupFiles(path, extensions, recursive) {\n\t489:   if (!exists(path)) {\n\t490:     if (exists(path + '.js')) {\n\t491:       path += '.js';\n\t493:       files = glob.sync(path);\n\t494:       if (!files.length) throw new Error(\"cannot resolve path (or pattern) '\" + path + \"'\");\n\t500:     var stat = fs.statSync(path);\n\t501:     if (stat.isFile()) return path;\n\t507:   fs.readdirSync(path).forEach(function(file){\n\t508:     file = join(path, file);\n\n/node_modules/mocha/lib/browser/diff.js:\n\t19:   function clonePath(path) {\n\t20:     return { newPos: path.newPos, components: path.components.slice(0) };\n\t62:         var bestPath = [{ newPos: -1, components: [] }];\n\t65:         var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\t66:         if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {\n\t67:           return bestPath[0].components;\n\t71:           for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {\n\t72:             var basePath;\n\t73:             var addPath = bestPath[diagonalPath-1],\n\t74:                 removePath = bestPath[diagonalPath+1];\n\t75:             oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\t76:             if (addPath) {\n\t78:               bestPath[diagonalPath-1] = undefined;\n\t81:             var canAdd = addPath && addPath.newPos+1 < newLen;\n\t82:             var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n\t84:               bestPath[diagonalPath] = undefined;\n\t89:             // path whose position in the new string is the farthest from the origin\n\t91:             if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n\t92:               basePath = clonePath(removePath);\n\t93:               this.pushComponent(basePath.components, oldString[oldPos], undefined, true);\n\t95:               basePath = clonePath(addPath);\n\t96:               basePath.newPos++;\n\t97:               this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);\n\t100:             var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);\n\t102:             if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {\n\t103:               return basePath.components;\n\t105:               bestPath[diagonalPath] = basePath;\n\t122:       extractCommon: function(basePath, newString, oldString, diagonalPath) {\n\t125:             newPos = basePath.newPos,\n\t126:             oldPos = newPos - diagonalPath;\n\t131:           this.pushComponent(basePath.components, newString[newPos], undefined, undefined);\n\t133:         basePath.newPos = newPos;\n\n/node_modules/mocha/lib/browser/progress.js:\n\t105:     ctx.beginPath();\n\t111:     ctx.beginPath();\n\n/node_modules/mocha/lib/reporters/html.js:\n\t186:   return window.location.pathname + (search ? search + '&' : '?' ) + 'grep=' + encodeURIComponent(s);\n\n/node_modules/mocha/node_modules/commander/index.js:\n\t8: var path = require('path');\n\t9: var dirname = path.dirname;\n\t10: var basename = path.basename;\n\t112:  *        .option('-C, --chdir <path>', 'change the working directory')\n\t113:  *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')\n\t288:  *     program.option('-C, --chdir <path>', 'change the working directory');\n\t407:   var local = path.join(dir, bin);\n\n/node_modules/mocha/node_modules/debug/History.md:\n\t32:   * Makefile: find node path using shell/which (#109, @timoxley)\n\n/node_modules/mocha/node_modules/debug/Makefile:\n\t3: THIS_MAKEFILE_PATH:=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))\n\t4: THIS_DIR:=$(shell cd $(dir $(THIS_MAKEFILE_PATH));pwd)\n\n/node_modules/mocha/node_modules/diff/diff.js:\n\t19:   function clonePath(path) {\n\t20:     return { newPos: path.newPos, components: path.components.slice(0) };\n\t62:         var bestPath = [{ newPos: -1, components: [] }];\n\t65:         var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\t66:         if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {\n\t67:           return bestPath[0].components;\n\t71:           for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {\n\t72:             var basePath;\n\t73:             var addPath = bestPath[diagonalPath-1],\n\t74:                 removePath = bestPath[diagonalPath+1];\n\t75:             oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\t76:             if (addPath) {\n\t78:               bestPath[diagonalPath-1] = undefined;\n\t81:             var canAdd = addPath && addPath.newPos+1 < newLen;\n\t82:             var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n\t84:               bestPath[diagonalPath] = undefined;\n\t89:             // path whose position in the new string is the farthest from the origin\n\t91:             if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n\t92:               basePath = clonePath(removePath);\n\t93:               this.pushComponent(basePath.components, oldString[oldPos], undefined, true);\n\t95:               basePath = clonePath(addPath);\n\t96:               basePath.newPos++;\n\t97:               this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);\n\t100:             var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);\n\t102:             if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {\n\t103:               return basePath.components;\n\t105:               bestPath[diagonalPath] = basePath;\n\t122:       extractCommon: function(basePath, newString, oldString, diagonalPath) {\n\t125:             newPos = basePath.newPos,\n\t126:             oldPos = newPos - diagonalPath;\n\t131:           this.pushComponent(basePath.components, newString[newPos], undefined, undefined);\n\t133:         basePath.newPos = newPos;\n\n/node_modules/mocha/node_modules/glob/glob.js:\n\t44: , path = require(\"path\")\n\t109:     this.changedCwd = path.resolve(options.cwd) !== cwd\n\t112:   this.root = options.root || path.resolve(this.cwd, \"/\")\n\t113:   this.root = path.resolve(this.root)\n\t342:               prefix = path.join(this.root, prefix)\n\t344:               prefix = path.resolve(this.root, prefix)\n\t379:       prefix = path.join(\"/\", prefix)\n\t381:     read = prefix = path.resolve(prefix)\n\t461:           e = path.join(this.root, e)\n\t502:     abs = path.join(this.root, f)\n\t504:     abs = path.resolve(this.cwd, f)\n\t508:     var er = new Error(\"Path name too long\")\n\t510:     er.path = f\n\t545:     er.path = abs\n\t568:     abs = path.join(this.root, f)\n\t572:     abs = path.resolve(this.cwd, f)\n\t576:     var er = new Error(\"Path name too long\")\n\t578:     er.path = f\n\t594:       er.path = f\n\t661:   // pull off the device/UNC bit from a windows path.\n\t662:   // from node's lib/path.js\n\t668:     , isAbsolute = !!result[2] || isUnc // UNC paths are always absolute\n\n/node_modules/mocha/node_modules/glob/README.md:\n\t106:   * `false` - Path does not exist\n\t107:   * `true` - Path exists\n\t108:   * `1` - Path exists, and is not a directory\n\t109:   * `2` - Path exists, and is a directory\n\t110:   * `[file, entries, ...]` - Path exists, is a directory, and the\n\t141:   onto.  Defaults to `path.resolve(options.cwd, \"/\")` (`/` on Unix\n\t147:   \"mounted\" onto the root setting, so that a valid filesystem path is\n\t205: thing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\n\t225: Though windows uses either `/` or `\\` as its path separator, only `/`\n\t228: be interpreted as escape characters, not path separators.\n\t231: root setting using `path.join`.  On windows, this will by default result\n\n/node_modules/mocha/node_modules/glob/node_modules/graceful-fs/graceful-fs.js:\n\t38: function open(path, flags, mode, cb) {\n\t41:   new OpenReq(path, flags, mode, cb)\n\t44: function OpenReq(path, flags, mode, cb) {\n\t45:   this.path = path\n\t55:   originalOpen.call(fs, this.path, this.flags, this.mode, this.done)\n\t62:     fds['fd' + fd] = this.path\n\t70: function readdir(path, cb) {\n\t72:   new ReaddirReq(path, cb)\n\t75: function ReaddirReq(path, cb) {\n\t76:   this.path = path\n\t84:   originalReaddir.call(fs, this.path, this.done)\n\n/node_modules/mocha/node_modules/glob/node_modules/graceful-fs/polyfills.js:\n\t23:   fs.lchmod = function (path, mode, callback) {\n\t25:     fs.open( path\n\t43:   fs.lchmodSync = function (path, mode) {\n\t44:     var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\t68:     fs.lutimes = function (path, at, mt, cb) {\n\t69:       fs.open(path, constants.O_SYMLINK, function (er, fd) {\n\t80:     fs.lutimesSync = function (path, at, mt) {\n\t81:       var fd = fs.openSync(path, constants.O_SYMLINK)\n\t102:     fs.lutimes = function (path, at, mt, cb) {\n\t103:       fs.utimensat(path, at, mt, constants.AT_SYMLINK_NOFOLLOW, cb)\n\t106:     fs.lutimesSync = function (path, at, mt) {\n\t107:       return fs.utimensatSync(path, at, mt, constants.AT_SYMLINK_NOFOLLOW)\n\t163:   fs.lchmod = function (path, mode, cb) {\n\t169:   fs.lchown = function (path, uid, gid, cb) {\n\n/node_modules/mocha/node_modules/glob/node_modules/graceful-fs/test/readdir-sort.js:\n\t5: fs.readdir = function(path, cb) {\n\n/node_modules/mocha/node_modules/glob/node_modules/minimatch/minimatch.js:\n\t12:       case \"path\": return { basename: function (f) {\n\t40: var path = require(\"path\")\n\t200:   // step 3: now we have a set, so turn each one into a series of path-portion\n\t464: // when it is the *only* thing in a path portion.  Otherwise, any series\n\t532:         // Should already be path-split by now.\n\t742:   // it doesn't match against an empty path part.\n\t844:   // treat the test path as a set of pathparts.\n\t856:   var splitFile = path.basename(f.join(\"/\")).split(\"/\")\n\n/node_modules/mocha/node_modules/glob/node_modules/minimatch/README.md:\n\t56:   corresponds to a single path-part.  For example, the pattern\n\t69:   to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.\n\t94: ### minimatch(path, pattern, options)\n\t96: Main export.  Tests a path against the pattern using the options.\n\t166: against the basename of the path if it contains slashes.  For example,\n\t167: `a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.\n\t204: thing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but\n\n/node_modules/mocha/node_modules/glob/test/00-setup.js:\n\t5: var path = require(\"path\")\n\t21: var symlinkTo = path.resolve(__dirname, \"a/symlink/a/b/c\")\n\t25:   return path.resolve(__dirname, f)\n\t29:   rimraf(path.resolve(__dirname, \"a\"), function (er) {\n\t37:     var d = path.dirname(f)\n\t53:     var d = path.dirname(symlinkTo)\n\t115:     var cp = spawn(\"bash\", [\"-c\", cmd], { cwd: path.dirname(__dirname) })\n\t136:   var fname = path.resolve(__dirname, \"bash-results.json\")\n\n/node_modules/mocha/node_modules/glob/test/bash-comparison.js:\n\t8: , path = require(\"path\")\n\t12: process.chdir(path.resolve(__dirname, \"..\"))\n\n/node_modules/mocha/node_modules/glob/test/cwd-test.js:\n\t8:   var path = require('path')\n\t18:     glob('**/d', {cwd:path.resolve('a')}, function (er, matches) {\n\t26:     glob('**/d', {cwd:path.resolve('a/b')}, function (er, matches) {\n\t34:     glob('**/d', {cwd:path.resolve('a/b/')}, function (er, matches) {\n\n/node_modules/mocha/node_modules/glob/test/nocase-nomagic.js:\n\t11:   function fakeStat(path) {\n\t13:     switch (path.toLowerCase()) {\n\t24:   fs.stat = function(path, cb) {\n\t25:     var f = fakeStat(path);\n\t31:       stat.call(fs, path, cb)\n\t35:   fs.statSync = function(path) {\n\t36:     return fakeStat(path) || statSync.call(fs, path)\n\t39:   function fakeReaddir(path) {\n\t41:     switch (path.toLowerCase()) {\n\t51:   fs.readdir = function(path, cb) {\n\t52:     var f = fakeReaddir(path)\n\t58:       readdir.call(fs, path, cb)\n\t61:   fs.readdirSync = function(path) {\n\t62:     return fakeReaddir(path) || readdirSync.call(fs, path)\n\n/node_modules/mocha/node_modules/glob/test/pause-resume.js:\n\t10: , path = require(\"path\")\n\t14: process.chdir(path.resolve(__dirname, \"..\"))\n\n/node_modules/mocha/node_modules/glob/test/root-nomount.js:\n\t8:   var path = require('path')\n\t18:     glob('/b*/**', { globDebug: true, root: path.resolve('a'), nomount: true }, function (er, matches) {\n\t26:     glob('/b*/**', { globDebug: true, root: 'a', cwd: path.resolve('a/b'), nomount: true }, function (er, matches) {\n\n/node_modules/mocha/node_modules/glob/test/root.js:\n\t7: var path = require('path')\n\t19:   console.error(\"root=\" + path.resolve('a'))\n\t20:   glob('/b*/**', { globDebug: true, root: path.resolve('a') }, function (er, matches) {\n\t25:         return path.join(path.resolve('a'), m).replace(/\\\\/g, '/')\n\t34:   glob('/b*/**', { globDebug: true, root: 'a', cwd: path.resolve('a/b') }, function (er, matches) {\n\t37:       return path.join(path.resolve('a'), m).replace(/\\\\/g, '/')\n\n/node_modules/mocha/node_modules/glob/test/stat.js:\n\t3: var path = require('path')\n\t23:       return path.relative(__dirname, f)\n\n/node_modules/mocha/node_modules/glob/test/zz-cleanup.js:\n\t4: , path = require(\"path\")\n\t7:   rimraf(path.resolve(__dirname, \"a\"), function (er) {\n\n/node_modules/mocha/node_modules/growl/Readme.md:\n\t33:   Download [growlnotify](http://www.growlforwindows.com/gfw/help/growlnotify.aspx) - **IMPORTANT :** Unpack growlnotify to a folder that is present in your path!\n\t50:     growl('Show icon', { image: 'path/to/icon.icns' })\n\t51:     growl('Show image', { image: 'path/to/my.image.png' })\n\t70:       - path to an icon sets --iconpath\n\t71:       - path to an image sets --image\n\n/node_modules/mocha/node_modules/growl/test.js:\n\t10: growl('Show icon', { image: 'path/to/icon.icns' })\n\t11: growl('Show image', { image: 'path/to/my.image.png' })\n\n/node_modules/mocha/node_modules/growl/lib/growl.js:\n\t9:   , path = require('path')\n\t10:   , exists = fs.existsSync || path.existsSync\n\t16:   var paths = process.env.PATH.split(':');\n\t19:   for (var i = 0, len = paths.length; i < len; ++i) {\n\t20:     loc = path.join(paths[i], name);\n\t124:  *    - path to an icon sets --iconpath\n\t125:  *    - path to an image sets --image\n\t158:         var flag, ext = path.extname(image).substr(1)\n\t159:         flag = flag || ext == 'icns' && 'iconpath'\n\n/node_modules/mocha/node_modules/jade/jade.js:\n\t6:     var path = require.resolve(p)\n\t7:       , mod = require.modules[path];\n\t11:       mod.call(mod.exports, mod, mod.exports, require.relative(path));\n\t18: require.resolve = function (path){\n\t19:     var orig = path\n\t20:       , reg = path + '.js'\n\t21:       , index = path + '/index.js';\n\t27: require.register = function (path, fn){\n\t28:     require.modules[path] = fn;\n\t35:       var path = parent.split('/')\n\t37:       path.pop();\n\t41:         if ('..' == seg) path.pop();\n\t42:         else if ('.' != seg) path.push(seg);\n\t45:       return require(path.join('/'));\n\t1035:     var path = options.filename;\n\t1037:       ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))\n\t1046:  * Render a Jade file at the given `path` and callback `fn(err, str)`.\n\t1048:  * @param {String} path\n\t1054: exports.renderFile = function(path, options, fn){\n\t1055:   var key = path + ':string';\n\t1062:     options.filename = path;\n\t1064:       ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))\n\t1065:       : fs.readFileSync(path, 'utf8');\n\t3015:     var path = require('path')\n\t3017:       , dirname = path.dirname\n\t3018:       , basename = path.basename\n\t3019:       , join = path.join;\n\t3024:     var path = this.expect('extends').val.trim()\n\t3027:     var path = join(dir, path + '.jade')\n\t3028:       , str = fs.readFileSync(path, 'utf8')\n\t3029:       , parser = new Parser(str, path, this.options);\n\t3076:     var path = require('path')\n\t3078:       , dirname = path.dirname\n\t3079:       , basename = path.basename\n\t3080:       , join = path.join;\n\t3082:     var path = this.expect('include').val.trim()\n\t3089:     if (!~basename(path).indexOf('.')) {\n\t3090:       path += '.jade';\n\t3094:     if ('.jade' != path.substr(-5)) {\n\t3095:       var path = join(dir, path)\n\t3096:         , str = fs.readFileSync(path, 'utf8');\n\t3100:     var path = join(dir, path)\n\t3101:       , str = fs.readFileSync(path, 'utf8')\n\t3102:      , parser = new Parser(str, path, this.options);\n\t3109:     ast.filename = path;\n\t3503:   err.path = filename;\n\n/node_modules/mocha/node_modules/jade/jade.md:\n\t9:          [-O|--out DIR] [-p|--path PATH] [-P|--pretty]\n\n/node_modules/mocha/node_modules/jade/runtime.js:\n\t171:   err.path = filename;\n\n/node_modules/mocha/node_modules/jade/bin/jade:\n\t9:   , path = require('path')\n\t10:   , basename = path.basename\n\t11:   , dirname = path.dirname\n\t12:   , resolve = path.resolve\n\t13:   , join = path.join\n\t28:   .option('-p, --path <path>', 'filename used to resolve includes')\n\t61: if (program.path) options.filename = program.path;\n\t75: // left-over args are file paths\n\t108:  * Process the given path, compiling the jade files found.\n\t112: function renderFile(path) {\n\t114:   fs.lstat(path, function(err, stat) {\n\t117:     if (stat.isFile() && re.test(path)) {\n\t118:       fs.readFile(path, 'utf8', function(err, str){\n\t120:         options.filename = path;\n\t123:         path = path.replace(re, extname);\n\t124:         if (program.out) path = join(program.out, basename(path));\n\t125:         var dir = resolve(dirname(path));\n\t131:           fs.writeFile(path, output, function(err){\n\t133:             console.log('  \\033[90mrendered \\033[36m%s\\033[0m', path);\n\t139:       fs.readdir(path, function(err, files) {\n\t142:           return path + '/' + filename;\n\n/node_modules/mocha/node_modules/jade/lib/jade.js:\n\t196:     var path = options.filename;\n\t198:       ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))\n\t207:  * Render a Jade file at the given `path` and callback `fn(err, str)`.\n\t209:  * @param {String} path\n\t215: exports.renderFile = function(path, options, fn){\n\t216:   var key = path + ':string';\n\t223:     options.filename = path;\n\t225:       ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))\n\t226:       : fs.readFileSync(path, 'utf8');\n\n/node_modules/mocha/node_modules/jade/lib/parser.js:\n\t396:     var path = require('path')\n\t398:       , dirname = path.dirname\n\t399:       , basename = path.basename\n\t400:       , join = path.join;\n\t405:     var path = this.expect('extends').val.trim()\n\t408:     var path = join(dir, path + '.jade')\n\t409:       , str = fs.readFileSync(path, 'utf8')\n\t410:       , parser = new Parser(str, path, this.options);\n\t457:     var path = require('path')\n\t459:       , dirname = path.dirname\n\t460:       , basename = path.basename\n\t461:       , join = path.join;\n\t463:     var path = this.expect('include').val.trim()\n\t470:     if (!~basename(path).indexOf('.')) {\n\t471:       path += '.jade';\n\t475:     if ('.jade' != path.substr(-5)) {\n\t476:       var path = join(dir, path)\n\t477:         , str = fs.readFileSync(path, 'utf8');\n\t481:     var path = join(dir, path)\n\t482:       , str = fs.readFileSync(path, 'utf8')\n\t483:      , parser = new Parser(str, path, this.options);\n\t490:     ast.filename = path;\n\n/node_modules/mocha/node_modules/jade/lib/runtime.js:\n\t170:   err.path = filename;\n\n/node_modules/mocha/node_modules/jade/node_modules/commander/lib/commander.js:\n\t13:   , path = require('path')\n\t15:   , basename = path.basename;\n\t116:  *        .option('-C, --chdir <path>', 'change the working directory')\n\t117:  *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')\n\t269:  *     program.option('-C, --chdir <path>', 'change the working directory');\n\n/node_modules/mocha/node_modules/jade/node_modules/mkdirp/index.js:\n\t1: var path = require('path');\n\t14:     p = path.resolve(p);\n\t20:                 mkdirP(path.dirname(p), mode, function (er) {\n\t48:     p = path.resolve(p);\n\t56:                 var err1 = sync(path.dirname(p), mode)\n\n/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/chmod.js:\n\t2: var path = require('path');\n\n/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/clobber.js:\n\t2: var path = require('path');\n\n/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/mkdirp.js:\n\t2: var path = require('path');\n\t16:         else path.exists(file, function (ex) {\n\n/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/perm.js:\n\t2: var path = require('path');\n\t12:         else path.exists(file, function (ex) {\n\n/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/perm_sync.js:\n\t2: var path = require('path');\n\t11:     path.exists(file, function (ex) {\n\t29:     path.exists(file, function (ex) {\n\n/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/race.js:\n\t2: var path = require('path');\n\t28:             else path.exists(file, function (ex) {\n\n/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/rel.js:\n\t2: var path = require('path');\n\t19:         else path.exists(file, function (ex) {\n\n/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/sync.js:\n\t2: var path = require('path');\n\t16:     else path.exists(file, function (ex) {\n\n/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/umask.js:\n\t2: var path = require('path');\n\t16:         else path.exists(file, function (ex) {\n\n/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/umask_sync.js:\n\t2: var path = require('path');\n\t16:     else path.exists(file, function (ex) {\n\n/node_modules/mocha/node_modules/mkdirp/index.js:\n\t1: var path = require('path');\n\t24:     p = path.resolve(p);\n\t33:                 mkdirP(path.dirname(p), opts, function (er, made) {\n\t67:     p = path.resolve(p);\n\t76:                 made = sync(path.dirname(p), opts, made);\n\n/node_modules/mocha/node_modules/mkdirp/readme.markdown:\n\t46: `opts.fs`. Your implementation should have `opts.fs.mkdir(path, mode, cb)` and\n\t47: `opts.fs.stat(path, cb)`.\n\t60: `opts.fs`. Your implementation should have `opts.fs.mkdirSync(path, mode)` and\n\t61: `opts.fs.statSync(path)`.\n\n/node_modules/mocha/node_modules/mkdirp/bin/cmd.js:\n\t16: var paths = argv._.slice();\n\t20:     if (paths.length === 0) return;\n\t21:     var p = paths.shift();\n\n/node_modules/mocha/node_modules/mkdirp/test/chmod.js:\n\t2: var path = require('path');\n\n/node_modules/mocha/node_modules/mkdirp/test/clobber.js:\n\t2: var path = require('path');\n\n/node_modules/mocha/node_modules/mkdirp/test/mkdirp.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/mocha/node_modules/mkdirp/test/opts_fs.js:\n\t2: var path = require('path');\n\n/node_modules/mocha/node_modules/mkdirp/test/opts_fs_sync.js:\n\t2: var path = require('path');\n\n/node_modules/mocha/node_modules/mkdirp/test/perm.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/mocha/node_modules/mkdirp/test/perm_sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/mocha/node_modules/mkdirp/test/race.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/mocha/node_modules/mkdirp/test/rel.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/mocha/node_modules/mkdirp/test/return.js:\n\t2: var path = require('path');\n\n/node_modules/mocha/node_modules/mkdirp/test/return_sync.js:\n\t2: var path = require('path');\n\n/node_modules/mocha/node_modules/mkdirp/test/root.js:\n\t2: var path = require('path');\n\t8:     var file = path.resolve('/');\n\n/node_modules/mocha/node_modules/mkdirp/test/sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/mocha/node_modules/mkdirp/test/umask.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/mocha/node_modules/mkdirp/test/umask_sync.js:\n\t2: var path = require('path');\n\t4: var exists = fs.exists || path.exists;\n\n/node_modules/morgan/node_modules/debug/History.md:\n\t48:   * Makefile: find node path using shell/which (#109, @timoxley)\n\n/node_modules/morgan/node_modules/debug/Makefile:\n\t3: THIS_MAKEFILE_PATH:=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))\n\t4: THIS_DIR:=$(shell cd $(dir $(THIS_MAKEFILE_PATH));pwd)\n\n/node_modules/morgan/node_modules/depd/index.js:\n\t13: var relative = require('path').relative\n\t22:  * Get the path to base files on.\n\t25: var basePath = process.cwd()\n\t357:   return relative(basePath, callSite[0])\n\n/node_modules/path/package.json:\n\t6:   \"name\": \"path\",\n\t7:   \"description\": \"Node.JS path module\",\n\t10:     \"path\"\n\t14:   \"homepage\": \"http://nodejs.org/docs/latest/api/path.html\",\n\t17:     \"url\": \"git://github.com/jinder/path.git\"\n\t19:   \"main\": \"./path.js\",\n\t22:     \"url\": \"https://github.com/jinder/path/issues\"\n\t24:   \"_id\": \"path@0.11.14\",\n\t27:   \"_from\": \"path@*\",\n\t49:     \"tarball\": \"http://registry.npmjs.org/path/-/path-0.11.14.tgz\"\n\t52:   \"_resolved\": \"https://registry.npmjs.org/path/-/path-0.11.14.tgz\"\n\n/node_modules/path/path.js:\n\t31: // resolves . and .. elements in a path array with directory names there\n\t34: // relative and absolute paths)\n\t36:   // if the path tries to go above the root, `up` ends up > 0\n\t51:   // if the path is allowed to go above the root, restore leading ..s\n\t63:   // Regex to split a windows path into three parts: [*, device, slash,\n\t74:   var splitPath = function(filename) {\n\t91:   // path.resolve([from ...], to)\n\t99:       var path;\n\t101:         path = arguments[i];\n\t103:         path = process.cwd();\n\t107:         // absolute path, get cwd for that drive. We're sure the device is not\n\t108:         // an unc path at this points, because unc paths are always absolute.\n\t109:         path = process.env['=' + resolvedDevice];\n\t112:         if (!path || path.substr(0, 3).toLowerCase() !==\n\t114:           path = resolvedDevice + '\\\\';\n\t119:       if (!util.isString(path)) {\n\t120:         throw new TypeError('Arguments to path.resolve must be strings');\n\t121:       } else if (!path) {\n\t125:       var result = splitDeviceRe.exec(path),\n\t128:           isAbsolute = exports.isAbsolute(path),\n\t134:         // This path points to another device so it is not applicable\n\t157:     // At this point the path should be resolved to a full absolute path,\n\t158:     // but handle relative paths to be safe (might happen when process.cwd()\n\t161:     // Normalize the tail path\n\t175:   exports.normalize = function(path) {\n\t176:     var result = splitDeviceRe.exec(path),\n\t179:         isAbsolute = exports.isAbsolute(path),\n\t188:     // Normalize the tail path\n\t210:   exports.isAbsolute = function(path) {\n\t211:     var result = splitDeviceRe.exec(path),\n\t214:     // UNC paths are always absolute\n\t222:         throw new TypeError('Arguments to path.join must be strings');\n\t227:     var paths = Array.prototype.filter.call(arguments, f);\n\t228:     var joined = paths.join('\\\\');\n\t230:     // Make sure that the joined path doesn't start with two slashes, because\n\t231:     // normalize() will mistake it for an UNC path then.\n\t234:     // intended to point at an UNC path. This is assumed when the first\n\t238:     // Note that for normalize() to treat a path as an UNC path it needs to\n\t240:     // This means that the user can use join to construct UNC paths from\n\t242:     //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\n\t243:     if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\n\t250:   // path.relative(from, to)\n\t251:   // it will solve the relative path from 'from' to 'to', for instance:\n\t314:   var splitPathRe =\n\t316:   var splitPath = function(filename) {\n\t317:     return splitPathRe.exec(filename).slice(1);\n\t320:   // path.resolve([from ...], to)\n\t323:     var resolvedPath = '',\n\t327:       var path = (i >= 0) ? arguments[i] : process.cwd();\n\t330:       if (!util.isString(path)) {\n\t331:         throw new TypeError('Arguments to path.resolve must be strings');\n\t332:       } else if (!path) {\n\t336:       resolvedPath = path + '/' + resolvedPath;\n\t337:       resolvedAbsolute = path.charAt(0) === '/';\n\t340:     // At this point the path should be resolved to a full absolute path, but\n\t341:     // handle relative paths to be safe (might happen when process.cwd() fails)\n\t343:     // Normalize the path\n\t344:     resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {\n\t348:     return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n\t351:   // path.normalize(path)\n\t353:   exports.normalize = function(path) {\n\t354:     var isAbsolute = exports.isAbsolute(path),\n\t355:         trailingSlash = path[path.length - 1] === '/',\n\t356:         segments = path.split('/'),\n\t359:     // Normalize the path\n\t365:     path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');\n\t367:     if (!path && !isAbsolute) {\n\t368:       path = '.';\n\t370:     if (path && trailingSlash) {\n\t371:       path += '/';\n\t374:     return (isAbsolute ? '/' : '') + path;\n\t378:   exports.isAbsolute = function(path) {\n\t379:     return path.charAt(0) === '/';\n\t384:     var path = '';\n\t388:         throw new TypeError('Arguments to path.join must be strings');\n\t391:         if (!path) {\n\t392:           path += segment;\n\t394:           path += '/' + segment;\n\t398:     return exports.normalize(path);\n\t402:   // path.relative(from, to)\n\t449: exports.dirname = function(path) {\n\t450:   var result = splitPath(path),\n\t468: exports.basename = function(path, ext) {\n\t469:   var f = splitPath(path)[2];\n\t478: exports.extname = function(path) {\n\t479:   return splitPath(path)[3];\n\t483: exports.exists = util.deprecate(function(path, callback) {\n\t484:   require('fs').exists(path, callback);\n\t485: }, 'path.exists is now called `fs.exists`.');\n\t488: exports.existsSync = util.deprecate(function(path) {\n\t489:   return require('fs').existsSync(path);\n\t490: }, 'path.existsSync is now called `fs.existsSync`.');\n\t494:   exports._makeLong = function(path) {\n\t496:     if (!util.isString(path))\n\t497:       return path;\n\t499:     if (!path) {\n\t503:     var resolvedPath = exports.resolve(path);\n\t505:     if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\n\t506:       // path is local filesystem path, which needs to be converted\n\t507:       // to long UNC path.\n\t508:       return '\\\\\\\\?\\\\' + resolvedPath;\n\t509:     } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\n\t510:       // path is network UNC path, which needs to be converted\n\t511:       // to long UNC path.\n\t512:       return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\n\t515:     return path;\n\t518:   exports._makeLong = function(path) {\n\t519:     return path;\n\n/node_modules/path/README.md:\n\t1: # path\n\t3: This is an exact copy of the NodeJS ’path’ module published to the NPM registry. \n\t5: [Documentation](http://nodejs.org/docs/latest/api/path.html)\n\t10: $ npm install --save path\n\n/node_modules/q/README.md:\n\t829:     at explode (/path/to/test.js:3:11)\n\t830:     at _fulfilled (/path/to/test.js:q:54)\n\t831:     at resolvedValue.promiseDispatch.done (/path/to/q.js:823:30)\n\t832:     at makePromise.promise.promiseDispatch (/path/to/q.js:496:13)\n\t833:     at pending (/path/to/q.js:397:39)\n\t847:     at explode (/path/to/test.js:3:11)\n\t849:     at theDepthsOfMyProgram (/path/to/test.js:2:16)\n\t850:     at Object.<anonymous> (/path/to/test.js:7:1)\n\n/plugins/acute-user-base/package.json:\n\t18:     \"path\": \"*\",\n\n/plugins/acute-user-base/app/app.js:\n\t6:     path = require('path'),\n\t7:     configPath = path.join(__dirname, \"config.js\"),\n\t17: acute_utils.loadApp(configPath, function(err, arch) {\n\n/plugins/acute-user-base/app/config.js:\n\t6:         packagePath: \"acute-express-app\",\n\t25:         packagePath: \"acute-express-data\",\n\t55:         packagePath: \"acute-express-controllers\",\n\n/plugins/acute-user-base/app/index.js:\n\t7:     configPath = path.join(__dirname, \"config.js\");\n\t20:     acute_utils.loadApp(configPath, function(err, arch) {\n\n/plugins/acute-user-base/app/swagger.yml:\n\t9: # Describe your paths here\n\t11:   # This is a path endpoint. Change it.\n\t75:           in: path\n\t110:           in: path\n\n/plugins/acute-user-base/app/controllers/index.js:\n\t41:            // base_path: \"/test\"\n\nFound 6653 matches in 490 files \n\n","undoManager":{"mark":-1,"position":91,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":0,"column":1},"action":"insert","lines":[" "]},{"start":{"row":0,"column":0},"end":{"row":0,"column":1},"action":"remove","lines":[" "]},{"start":{"row":0,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["Searching for \u0001acute-utils\u0001 in\u0001/app\u0001","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2,"column":0},"end":{"row":3,"column":0},"action":"insert","lines":["/app/app.js:",""]},{"start":{"row":3,"column":0},"end":{"row":5,"column":0},"action":"insert","lines":["\t8:     acute_utils = require('acute-utils'),","",""]},{"start":{"row":5,"column":0},"end":{"row":8,"column":0},"action":"insert","lines":["/app/index.js:","\t7:     acute_utils = require('acute-utils'),","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":8,"column":0},"end":{"row":9,"column":0},"action":"insert","lines":["Found 2 matches in 2 files ",""]}]}],[{"group":"doc","deltas":[{"start":{"row":9,"column":0},"end":{"row":10,"column":0},"action":"insert","lines":["",""]},{"start":{"row":0,"column":36},"end":{"row":0,"column":65},"action":"insert","lines":[" (Found 2 matches in 2 files)"]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":10,"column":0},"action":"remove","lines":["Searching for \u0001acute-utils\u0001 in\u0001/app\u0001 (Found 2 matches in 2 files)","","/app/app.js:","\t8:     acute_utils = require('acute-utils'),","","/app/index.js:","\t7:     acute_utils = require('acute-utils'),","","Found 2 matches in 2 files ","",""]},{"start":{"row":0,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["Searching for \u0001acute-utils\u0001 in\u0001/\u0001","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2,"column":0},"end":{"row":3,"column":0},"action":"insert","lines":["/package.json:",""]},{"start":{"row":3,"column":0},"end":{"row":6,"column":0},"action":"insert","lines":["\t33:     \"acute-utils\": \"*\",","\t36:     \"acute-utils\": \"*\",","",""]},{"start":{"row":6,"column":0},"end":{"row":9,"column":0},"action":"insert","lines":["/app/app.js:","\t8:     acute_utils = require('acute-utils'),","",""]},{"start":{"row":9,"column":0},"end":{"row":12,"column":0},"action":"insert","lines":["/app/index.js:","\t7:     acute_utils = require('acute-utils'),","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":12,"column":0},"end":{"row":19,"column":0},"action":"insert","lines":["/node_modules/acute-utils/package.json:","\t2:   \"name\": \"acute-utils\",","\t23:   \"_id\": \"acute-utils@0.0.2\",","\t25:   \"_from\": \"acute-utils@*\",","\t39:     \"tarball\": \"http://registry.npmjs.org/acute-utils/-/acute-utils-0.0.2.tgz\"","\t42:   \"_resolved\": \"https://registry.npmjs.org/acute-utils/-/acute-utils-0.0.2.tgz\"","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":19,"column":0},"end":{"row":22,"column":0},"action":"insert","lines":["/plugins/acute-user-base/package.json:","\t29:     \"acute-utils\": \"*\",","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":22,"column":0},"end":{"row":28,"column":0},"action":"insert","lines":["/plugins/acute-user-base/app/app.js:","\t9:     acute_utils = require('acute-utils');","","/plugins/acute-user-base/app/index.js:","\t6:     acute_utils = require('../plugins/acute-utils'),","",""]},{"start":{"row":28,"column":0},"end":{"row":29,"column":0},"action":"insert","lines":["Found 14 matches in 7 files ",""]},{"start":{"row":29,"column":0},"end":{"row":30,"column":0},"action":"insert","lines":["",""]},{"start":{"row":0,"column":33},"end":{"row":0,"column":63},"action":"insert","lines":[" (Found 14 matches in 7 files)"]}]}],[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":30,"column":0},"action":"remove","lines":["Searching for \u0001acute-utils\u0001 in\u0001/\u0001 (Found 14 matches in 7 files)","","/package.json:","\t33:     \"acute-utils\": \"*\",","\t36:     \"acute-utils\": \"*\",","","/app/app.js:","\t8:     acute_utils = require('acute-utils'),","","/app/index.js:","\t7:     acute_utils = require('acute-utils'),","","/node_modules/acute-utils/package.json:","\t2:   \"name\": \"acute-utils\",","\t23:   \"_id\": \"acute-utils@0.0.2\",","\t25:   \"_from\": \"acute-utils@*\",","\t39:     \"tarball\": \"http://registry.npmjs.org/acute-utils/-/acute-utils-0.0.2.tgz\"","\t42:   \"_resolved\": \"https://registry.npmjs.org/acute-utils/-/acute-utils-0.0.2.tgz\"","","/plugins/acute-user-base/package.json:","\t29:     \"acute-utils\": \"*\",","","/plugins/acute-user-base/app/app.js:","\t9:     acute_utils = require('acute-utils');","","/plugins/acute-user-base/app/index.js:","\t6:     acute_utils = require('../plugins/acute-utils'),","","Found 14 matches in 7 files ","",""]},{"start":{"row":0,"column":0},"end":{"row":2,"column":0},"action":"insert","lines":["Searching for \u0001path\u0001 in\u0001/\u0001","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2,"column":0},"end":{"row":3,"column":0},"action":"insert","lines":["/package.json:",""]},{"start":{"row":3,"column":0},"end":{"row":5,"column":0},"action":"insert","lines":["\t22:     \"path\": \"*\",","",""]},{"start":{"row":5,"column":0},"end":{"row":10,"column":0},"action":"insert","lines":["/app/app.js:","\t6:     path = require('path'),","\t7:     configPath = path.join(__dirname, \"config.js\"),","\t18: acute_utils.loadApp(configPath, function(err, arch) {","",""]},{"start":{"row":10,"column":0},"end":{"row":15,"column":0},"action":"insert","lines":["/app/config.js:","\t6:         packagePath: \"acute-express-app\",","\t25:         packagePath: \"acute-express-data\",","\t55:         packagePath: \"acute-express-controllers\",","",""]},{"start":{"row":15,"column":0},"end":{"row":20,"column":0},"action":"insert","lines":["/app/index.js:","\t6:     path = require('path'),","\t8:     configPath = path.join(__dirname, \"config.js\");","\t17:     acute_utils.loadApp(configPath, function(err, arch) {","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":20,"column":0},"end":{"row":23,"column":0},"action":"insert","lines":["/app/controllers/index.js:","\t39:            // base_path: \"/test\"","",""]},{"start":{"row":23,"column":0},"end":{"row":26,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/package.json:","\t28:     \"path\": \"*\"","",""]},{"start":{"row":26,"column":0},"end":{"row":31,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/HISTORY.md:","\t23: - Optimized query path for performance, moving Object.defineProperty outside of constructors.","\t949: * Cleanup of bson.js to remove duplicated code paths","\t951: * Removing require.paths to make tests work with the 0.5.X branch","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":31,"column":0},"end":{"row":35,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/README.md:","\t97: Let's boot up a MongoDB server instance. Download the right MongoDB version from [MongoDB](http://www.mongodb.org), open a new shell or command line and ensure the **mongod** command is in the shell or command line path. Now let's create a database directory (in our case under **/data**).","\t100: mongod --dbpath=/data --port 27017","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":35,"column":0},"end":{"row":39,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/README.md:","\t85: Let's boot up a MongoDB server instance. Download the right MongoDB version from [MongoDB](http://www.mongodb.org), open a new shell or command line and ensure the **mongod** command is in the shell or command line path. Now let's create a database directory (in our case under **/data**).","\t88: mongod --dbpath=/data --port 27017","",""]},{"start":{"row":39,"column":0},"end":{"row":42,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/TESTING.md:","\t6: mongod --dbpath=./db","",""]},{"start":{"row":42,"column":0},"end":{"row":45,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/lib/cursor.js:","\t205:     // Otherwise fall back to regular find path","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":45,"column":0},"end":{"row":57,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/browser_build/bson.js:","\t30: function normalize(path) {","\t31:   var ret = [], parts = path.split('/'), cur, prev;","\t52: function dirname(path) {","\t53:   return path && path.substr(0, path.lastIndexOf(\"/\")) || \".\";","\t2705:   , './long'].forEach(function (path) {","\t2706:   \tvar module = require('./' + path);","\t2728: ].forEach(function (path) {","\t2729:     \tvar module = require('./' + path);","\t2753:     , '././bson'].forEach(function (path) {","\t2754:     \tvar module = require('./' + path);","",""]},{"start":{"row":57,"column":0},"end":{"row":60,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/build/bson.target.mk:","\t118: # Copy this to the executable output path.","",""]},{"start":{"row":60,"column":0},"end":{"row":72,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/build/Makefile:","\t11: abs_srcdir := $(abspath $(srcdir))","\t28: # as they reach into the src/ directory for data with relative paths.","\t30: abs_builddir := $(abspath $(builddir))","\t35: abs_obj := $(abspath $(obj))","\t79: # http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces","\t93: # ccache or distcc lose the path to the target, so we convert a rule of","\t97: #   path/to/foobar.o: DEP1 DEP2","\t114: # Fixup path as in (1).","\t171: # the local, absolute paths used on the link command-line.","\t186: # $LD_LIBRARY_PATH), without triggering make substitution.","",""]},{"start":{"row":72,"column":0},"end":{"row":76,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/ext/wscript:","\t3: from os.path import exists ","\t24:   # conf.check(lib='node', libpath=['/usr/lib', '/usr/local/lib'], uselib_store='NODE')","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":76,"column":0},"end":{"row":84,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/lib/bson/index.js:","\t18:   , './long'].forEach(function (path) {","\t19:   \tvar module = require('./' + path);","\t41: ].forEach(function (path) {","\t42:     \tvar module = require('./' + path);","\t66:     , '././bson'].forEach(function (path) {","\t67:     \tvar module = require('./' + path);","",""]},{"start":{"row":84,"column":0},"end":{"row":87,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/appveyor.yml:","\t19:   - IF NOT %nodejs_version% == 1 set PATH=%APPDATA%\\npm;%PATH%","",""]},{"start":{"row":87,"column":0},"end":{"row":88,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/CHANGELOG.md:",""]},{"start":{"row":88,"column":0},"end":{"row":93,"column":0},"action":"insert","lines":["\t209:  - fix \"not all control paths return a value\" compile warning on some platforms","","/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/include_dirs.js:","\t1: console.log(require('path').relative('.', __dirname));","",""]},{"start":{"row":93,"column":0},"end":{"row":96,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/build/kerberos.target.mk:","\t133: # Copy this to the executable output path.","",""]},{"start":{"row":96,"column":0},"end":{"row":108,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/build/Makefile:","\t11: abs_srcdir := $(abspath $(srcdir))","\t28: # as they reach into the src/ directory for data with relative paths.","\t30: abs_builddir := $(abspath $(builddir))","\t35: abs_obj := $(abspath $(obj))","\t79: # http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces","\t93: # ccache or distcc lose the path to the target, so we convert a rule of","\t97: #   path/to/foobar.o: DEP1 DEP2","\t114: # Fixup path as in (1).","\t171: # the local, absolute paths used on the link command-line.","\t186: # $LD_LIBRARY_PATH), without triggering make substitution.","",""]},{"start":{"row":108,"column":0},"end":{"row":111,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/appveyor.yml:","\t19:   - IF NOT %nodejs_version% == 1 set PATH=%APPDATA%\\npm;%PATH%","",""]},{"start":{"row":111,"column":0},"end":{"row":114,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/CHANGELOG.md:","\t209:  - fix \"not all control paths return a value\" compile warning on some platforms","",""]},{"start":{"row":114,"column":0},"end":{"row":117,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/include_dirs.js:","\t1: console.log(require('path').relative('.', __dirname));","",""]},{"start":{"row":117,"column":0},"end":{"row":124,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/index.js:","\t1: var path = require('path');","\t24:     p = path.resolve(p);","\t33:                 mkdirP(path.dirname(p), opts, function (er, made) {","\t67:     p = path.resolve(p);","\t76:                 made = sync(path.dirname(p), opts, made);","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":124,"column":0},"end":{"row":130,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/readme.markdown:","\t46: `opts.fs`. Your implementation should have `opts.fs.mkdir(path, mode, cb)` and","\t47: `opts.fs.stat(path, cb)`.","\t60: `opts.fs`. Your implementation should have `opts.fs.mkdirSync(path, mode)` and","\t61: `opts.fs.statSync(path)`.","",""]},{"start":{"row":130,"column":0},"end":{"row":135,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/bin/cmd.js:","\t16: var paths = argv._.slice();","\t20:     if (paths.length === 0) return;","\t21:     var p = paths.shift();","",""]},{"start":{"row":135,"column":0},"end":{"row":138,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/chmod.js:","\t2: var path = require('path');","",""]},{"start":{"row":138,"column":0},"end":{"row":141,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/clobber.js:","\t2: var path = require('path');","",""]},{"start":{"row":141,"column":0},"end":{"row":145,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/mkdirp.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":145,"column":0},"end":{"row":146,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/opts_fs.js:",""]},{"start":{"row":146,"column":0},"end":{"row":148,"column":0},"action":"insert","lines":["\t2: var path = require('path');","",""]},{"start":{"row":148,"column":0},"end":{"row":151,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/opts_fs_sync.js:","\t2: var path = require('path');","",""]},{"start":{"row":151,"column":0},"end":{"row":155,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/perm.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":155,"column":0},"end":{"row":159,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/perm_sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":159,"column":0},"end":{"row":163,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/race.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":163,"column":0},"end":{"row":167,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/rel.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":167,"column":0},"end":{"row":168,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/return.js:",""]},{"start":{"row":168,"column":0},"end":{"row":171,"column":0},"action":"insert","lines":["\t2: var path = require('path');","","/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/return_sync.js:",""]},{"start":{"row":171,"column":0},"end":{"row":173,"column":0},"action":"insert","lines":["\t2: var path = require('path');","",""]},{"start":{"row":173,"column":0},"end":{"row":177,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/root.js:","\t2: var path = require('path');","\t8:     var file = path.resolve('/');","",""]},{"start":{"row":177,"column":0},"end":{"row":181,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":181,"column":0},"end":{"row":185,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/umask.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":185,"column":0},"end":{"row":189,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/umask_sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":189,"column":0},"end":{"row":190,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/bin.js:",""]},{"start":{"row":190,"column":0},"end":{"row":193,"column":0},"action":"insert","lines":["\t21:   log('Usage: rimraf <path>')","\t23:   log('  Deletes all files and folders at \"path\" recursively.')","",""]},{"start":{"row":193,"column":0},"end":{"row":196,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/README.md:","\t25: command `rimraf <path>` which is useful for cross platform support.","",""]},{"start":{"row":196,"column":0},"end":{"row":201,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/rimraf.js:","\t4: var path = require(\"path\")","\t131:       rimraf(path.join(p, f), function (er) {","\t175:     rimrafSync(path.join(p, f))","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":201,"column":0},"end":{"row":205,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/test/test-async.js:","\t2:   , path = require(\"path\")","\t3: rimraf(path.join(__dirname, \"target\"), function (er) {","",""]},{"start":{"row":205,"column":0},"end":{"row":209,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/test/test-sync.js:","\t2:   , path = require(\"path\")","\t3: rimraf.sync(path.join(__dirname, \"target\"))","",""]},{"start":{"row":209,"column":0},"end":{"row":210,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/readable-stream/lib/_stream_transform.js:",""]},{"start":{"row":210,"column":0},"end":{"row":214,"column":0},"action":"insert","lines":["\t51: // a pathological inflate type of transform can cause excessive buffering","\t57: // such a pathological inflating mechanism, there'd be no way to tell","\t61: // However, even in such a pathological case, only a single written chunk","",""]},{"start":{"row":214,"column":0},"end":{"row":215,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongodb/node_modules/readable-stream/node_modules/isarray/build/build.js:",""]},{"start":{"row":215,"column":0},"end":{"row":266,"column":0},"action":"insert","lines":["\t3:  * Require the given path.","\t5:  * @param {String} path","\t10: function require(path, parent, orig) {","\t11:   var resolved = require.resolve(path);","\t15:     orig = orig || path;","\t18:     err.path = orig;","\t51:  * Resolve `path`.","\t55:  *   - PATH/index.js","\t56:  *   - PATH.js","\t57:  *   - PATH","\t59:  * @param {String} path","\t60:  * @return {String} path or null","\t64: require.resolve = function(path) {","\t65:   if (path.charAt(0) === '/') path = path.slice(1);","\t66:   var index = path + '/index.js';","\t68:   var paths = [","\t69:     path,","\t70:     path + '.js',","\t71:     path + '.json',","\t72:     path + '/index.js',","\t73:     path + '/index.json'","\t76:   for (var i = 0; i < paths.length; i++) {","\t77:     var path = paths[i];","\t78:     if (require.modules.hasOwnProperty(path)) return path;","\t87:  * Normalize `path` relative to the current path.","\t90:  * @param {String} path","\t95: require.normalize = function(curr, path) {","\t98:   if ('.' != path.charAt(0)) return path;","\t101:   path = path.split('/');","\t103:   for (var i = 0; i < path.length; ++i) {","\t104:     if ('..' == path[i]) {","\t106:     } else if ('.' != path[i] && '' != path[i]) {","\t107:       segs.push(path[i]);","\t115:  * Register module at `path` with callback `definition`.","\t117:  * @param {String} path","\t122: require.register = function(path, definition) {","\t123:   require.modules[path] = definition;","\t142:  * Return a require function relative to the `parent` path.","\t168:   function localRequire(path) {","\t169:     var resolved = localRequire.resolve(path);","\t170:     return require(resolved, parent, path);","\t177:   localRequire.resolve = function(path) {","\t178:     var c = path.charAt(0);","\t179:     if ('/' == c) return path.slice(1);","\t180:     if ('.' == c) return require.normalize(p, path);","\t188:     path = segs.slice(0, i + 1).join('/') + '/deps/' + path;","\t189:     return path;","\t193:    * Check if module is defined at `path`.","\t196:   localRequire.exists = function(path) {","\t197:     return require.modules.hasOwnProperty(localRequire.resolve(path));","",""]},{"start":{"row":266,"column":0},"end":{"row":267,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/History.md:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":267,"column":0},"end":{"row":330,"column":0},"action":"insert","lines":["\t5:  * added; dynamic refpaths #2640 [chetvernikov](https://github.com/chetvernikov)","\t14:  * fixed; array saved as object when path is object in array #2442","\t33:  * added; can explicitly exclude paths from versioning #2576 [csabapalfi](https://github.com/csabapalfi)","\t107:  * added; ability to set single populated paths to documents #1530","\t136:  * fixed; properly remove modified array paths if array has been overwritten #1638","\t190:  * fixed; custom getter might cause mongoose to mistakenly think a path is dirty #2100 [pgherveou](https://github.com/pgherveou)","\t235:  * updated; added get / set to reserved path list #1903 [tstrimple](https://github.com/tstrimple)","\t337:  * fixed; repopulating modified populated paths #1697","\t414:  * fixed; repopulating modified populated paths #1697","\t535:  * fixed; repopulating modified populated paths #1697","\t677:   * fixed; strict:throw edge case using .set(path, val)","\t678:   * fixed; schema.pathType() on some numbericAlpha paths","\t679:   * fixed; numbericAlpha path versioning","\t680:   * fixed; setting nested mixed paths #1418","\t725:   * fixed; use of `setMaxListeners` as path","\t757:   * added; doc#populated(path) stores original populated _ids","\t762:   * added; support for rich nested path population","\t775:   * fixed; setting populated paths #570","\t787:   * fixed; add EventEmitter props to reserved paths #1338","\t791:   * fixed; specifying schema type edge case { path: [{type: \"String\" }] }","\t797:   * updated; mpath to 0.1.1","\t840:   * fixed; setting populated paths #570","\t852:   * fixed; add EventEmitter props to reserved paths #1338","\t871:   * fixed; specifying schema type edge case { path: [{type: \"String\" }] }","\t877:   * added; doc#populated(path) stores original populated _ids","\t882:   * added; support for rich nested path population","\t890:   * updated; mpath to 0.1.1","\t979:   * fixed; add EventEmitter props to reserved paths #1338","\t1009:   * changed; \"_pres\" & \"_posts\" are now reserved pathnames #1261","\t1031:   * fixed; regression when using subdoc with `path` as pathname #1245 [daeq](https://github.com/daeq)","\t1042:   * added; paths to CastErrors #1239","\t1083:   * changed; adding invalid nested paths to non-objects throws 4216f14","\t1188:   * fixed; use of nested paths beginning w/ numbers #1062","\t1202:   * fixed; compat with non-schema path props using positional notation (#1048)","\t1227:   * fixed; allow subdoc literal declarations containing \"type\" pathname (#993)","\t1230:   * fixed; allow use of `options` as a pathname (#529)","\t1231:   * fixed; `model` is again a permitted schema path name","\t1250:   * fixed; provide helpful error msgs when reserved schema path is used (#928)","\t1276:   * changed; doc#modifiedPaths is now a method (#950)","\t1292:   * fixed; setting invalid paths in strict mode (#916)","\t1299:   * fixed; subdoc paths reported in validation errors (#725)","\t1306:   * fixed; set/updating nested objects by parent pathname (#843)","\t1318:   * added; inclusion of deselected schema path (#786)","\t1372:   * fixed; edge case when using 'options' as a path name (#961)","\t1378:   * fixed; selection of _id w/ another excluded path (#954)","\t1393:   * fixed; setting invalid paths in strict mode (#916)","\t1435:   * fixed; doc.isSelected(otherpath) when only _id is selected (#730)","\t1441:   * fixed; failing validation of unselected required paths (#730,#713)","\t1469:   * added; default path selection to SchemaTypes","\t1508:   * added; doc#isSelected(path)","\t1512:   * added; document.modifiedPaths (#709) [ljharb]","\t1566:   * fixed; bug in 2.4.6 with path setting","\t1611:   * added; $unset is now used when setting a path to undefined (#519)","\t1638:   * fixed; model.update casting for nested paths works (#542)","\t1782:   * fixed; reset modified paths and atomics after saved (#459)","\t1934:   * fixed; 'path' is now a valid Schema pathname","\t1938:   * fixed; modifying subdoc property sets modified paths for subdoc and parent doc","\t1939:   * fixed; marking subdoc path as modified properly persists the value to the db","\t2041:   * Fixed; no longer using $set on paths to an unexisting fields","\t2112:   * Only doValidate when path exists in Schema [aheckmann]","\t2226:   * Fixed; it's now possible to instantiate a model even when one of the paths maps","","/node_modules/acute-data-mongodb/node_modules/mongoose/package.json:",""]},{"start":{"row":330,"column":0},"end":{"row":333,"column":0},"action":"insert","lines":["\t31:     \"mpath\": \"0.1.1\",","","/node_modules/acute-data-mongodb/node_modules/mongoose/README.md:",""]},{"start":{"row":333,"column":0},"end":{"row":338,"column":0},"action":"insert","lines":["\t104: Comment.path('name').set(function (v) {","\t219: For example, this would allow you to broadcast changes about your Documents every time someone `set`s a path in your Document to a new value:","\t222: schema.pre('set', function (next, path, val, typel) {","\t224:   this.emit('set', path, val);","",""]},{"start":{"row":338,"column":0},"end":{"row":341,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/examples/population/population-across-three-collections.js:","\t113:           path: 'author.friends',","",""]},{"start":{"row":341,"column":0},"end":{"row":342,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/examples/population/population-of-multiple-existing-docs.js:",""]},{"start":{"row":342,"column":0},"end":{"row":345,"column":0},"action":"insert","lines":["\t88:     var options = { path: 'consoles', select: 'name released -_id' };","","/node_modules/acute-data-mongodb/node_modules/mongoose/examples/population/population-options.js:",""]},{"start":{"row":345,"column":0},"end":{"row":347,"column":0},"action":"insert","lines":["\t93:       path: 'consoles'","",""]},{"start":{"row":347,"column":0},"end":{"row":351,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/examples/schema/schema.js:","\t46: BlogPost.path('date')","\t88:     schema.path(key).set(function(v){","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":351,"column":0},"end":{"row":354,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/aggregate.js:","\t280:  * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.","",""]},{"start":{"row":354,"column":0},"end":{"row":359,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/browserDocument.js:","\t30:  * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data","\t80:   var required = this.schema.requiredPaths();","\t82:     this.$__.activePaths.require(required[i]);","",""]},{"start":{"row":359,"column":0},"end":{"row":383,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/cast.js:","\t18:   var paths = Object.keys(obj)","\t19:     , i = paths.length","\t23:     , path","\t28:     path = paths[i];","\t29:     val = obj[path];","\t31:     if ('$or' === path || '$nor' === path || '$and' === path) {","\t39:     } else if (path === '$where') {","\t47:         obj[path] = val.toString();","\t59:       schematype = schema.path(path);","\t63:         var split = path.split('.')","\t65:           , pathFirstHalf","\t66:           , pathLastHalf","\t70:         // Find the part of the var path that is a path of the Schema","\t72:           pathFirstHalf = split.slice(0, j).join('.');","\t73:           schematype = schema.path(pathFirstHalf);","\t77:         // If a substring of the input path resolves to an actual real path...","\t82:             pathLastHalf = split.slice(j).join('.');","\t83:             remainingConds[pathLastHalf] = val;","\t84:             obj[path] = cast(schematype.caster.schema, remainingConds)[pathLastHalf];","\t86:             obj[path] = val;","\t169:           obj[path] = schematype.castForQuery(val);","\t202:         obj[path] = schematype.castForQuery(val);","",""]},{"start":{"row":383,"column":0},"end":{"row":386,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/connection.js:","\t8:   , driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native'","",""]},{"start":{"row":386,"column":0},"end":{"row":387,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/document.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":387,"column":0},"end":{"row":663,"column":0},"action":"insert","lines":["\t29:  * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data","\t53:   var required = schema.requiredPaths();","\t55:     this.$__.activePaths.require(required[i]);","\t171:   var paths = Object.keys(this.schema.paths)","\t172:     , plen = paths.length","\t176:     var p = paths[ii];","\t183:     var type = this.schema.paths[p]","\t184:       , path = p.split('.')","\t185:       , len = path.length","\t187:       , curPath = ''","\t192:       var piece = path[i]","\t197:         curPath += piece;","\t198:         if (curPath in fields) break;","\t199:         curPath += '.';","\t211:               self.$__.activePaths.default(p);","\t219:               self.$__.activePaths.default(p);","\t226:             self.$__.activePaths.default(p);","\t259:   // handle docs with populated paths","\t265:       this.populated(item.path, item._docs[id], item);","\t292:     , path","\t297:     path = prefix + i;","\t298:     schema = self.schema.path(path);","\t304:       init(self, obj[i], doc[i], path + '.');","\t313:             self.invalidate(e.path, new ValidatorError({","\t314:               path: e.path,","\t325:       if (!self.isModified(path)) {","\t326:         self.$__.activePaths.init(path);","\t350:     , paths = Object.keys(key)","\t351:     , len = paths.length","\t355:     val = this.getValue(paths[i]);","\t357:       orig[paths[i]] = val.toObject({ depopulate: true })","\t362:       orig[paths[i]] = val.valueOf();","\t364:       orig[paths[i]] = val;","\t403:  * Sets the value of a path, or many paths.","\t407:  *     // path, value","\t408:  *     doc.set(path, value)","\t412:  *         path  : value","\t413:  *       , path2 : {","\t414:  *            path  : value","\t419:  *     doc.set(path, value, Number)","\t422:  *     doc.set(path, value, String)","\t425:  *     doc.set(path, value, { strict: false });","\t427:  * @param {String|Object} path path or object of key/vals to set","\t434: Document.prototype.set = function (path, val, type, options) {","\t450:     adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});","\t451:     adhocs[path] = Schema.interpretAsType(path, type);","\t454:   if ('string' !== typeof path) {","\t457:     if (null === path || undefined === path) {","\t458:       var _ = path;","\t459:       path = val;","\t467:       if (path instanceof Document) path = path._doc;","\t469:       var keys = Object.keys(path)","\t471:         , pathtype","\t476:         pathtype = this.schema.pathType(prefix + key);","\t477:         if (null != path[key]","\t479:             && utils.isObject(path[key])","\t480:             && (!path[key].constructor || 'Object' == utils.getFunctionName(path[key].constructor))","\t481:             && 'virtual' != pathtype","\t482:             && !(this.$__path(prefix + key) instanceof MixedSchema)","\t483:             && !(this.schema.paths[key] && this.schema.paths[key].options.ref)","\t485:           this.set(path[key], prefix + key, constructing);","\t487:           if ('real' === pathtype || 'virtual' === pathtype) {","\t488:             this.set(prefix + key, path[key], constructing);","\t492:         } else if (undefined !== path[key]) {","\t493:           this.set(prefix + key, path[key], constructing);","\t502:   // docschema = new Schema({ path: { nest: 'string' }})","\t503:   // doc.set('path', obj);","\t504:   var pathType = this.schema.pathType(path);","\t505:   if ('nested' == pathType && val && utils.isObject(val) &&","\t507:     if (!merge) this.setValue(path, null);","\t508:     this.set(val, path, constructing);","\t513:   var parts = path.split('.');","\t515:   if ('adhocOrUndefined' == pathType && strict) {","\t521:       var subpath = parts.slice(0, i+1).join('.');","\t522:       schema = this.schema.path(subpath);","\t524:         // allow changes to sub paths of mixed types","\t532:         throw new Error(\"Field `\" + path + \"` is not in schema.\");","\t537:   } else if ('virtual' == pathType) {","\t538:     schema = this.schema.virtualpath(path);","\t542:     schema = this.$__path(path);","\t545:   var pathToMark;","\t547:   // When using the $set operator the path to the field must already exist.","\t551:     pathToMark = path;","\t554:       var subpath = parts.slice(0, i+1).join('.');","\t555:       if (this.isDirectModified(subpath) // earlier prefixes that are already","\t557:           || this.get(subpath) === null) {","\t558:         pathToMark = subpath;","\t563:     if (!pathToMark) pathToMark = path;","\t569:     : this.getValue(path);","\t572:     this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);","\t579:     // If the user is trying to set a ref path to a document with","\t585:       this.populated(path, val);","\t589:     this.invalidate(e.path, new ValidatorError({","\t590:       path: e.path,","\t599:     this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);","\t615:     pathToMark, path, constructing, parts, schema, val, priorVal) {","\t619:   if (undefined === val && !this.isSelected(path)) {","\t620:     // when a path is not selected in a query, its initial","\t625:   if (undefined === val && path in this.$__.activePaths.states.default) {","\t630:   if (!deepEqual(val, priorVal || this.get(path))) {","\t636:       path in this.$__.activePaths.states.default &&","\t638:     // a path with a default was $unset on the server","\t646:  * Handles the actual setting of the value and marking the path modified if appropriate.","\t654:     pathToMark, path, constructing, parts, schema, val, priorVal) {","\t661:     this.markModified(pathToMark, val);","\t669:       // paths that were modified before the array overwrite","\t670:       this.$__.activePaths.forEach(function(modifiedPath) {","\t671:         if (modifiedPath.indexOf(path + '.') === 0) {","\t672:           _this.$__.activePaths.ignore(modifiedPath);","\t703:  * Gets a raw value from a path (no getters)","\t705:  * @param {String} path","\t709: Document.prototype.getValue = function (path) {","\t710:   return utils.getValue(path, this._doc);","\t714:  * Sets a raw value for a path (no casting, setters, transformations)","\t716:  * @param {String} path","\t721: Document.prototype.setValue = function (path, val) {","\t722:   utils.setValue(path, val, this._doc);","\t727:  * Returns the value of a path.","\t731:  *     // path","\t737:  * @param {String} path","\t742: Document.prototype.get = function (path, type) {","\t745:     adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});","\t746:     adhocs[path] = Schema.interpretAsType(path, type);","\t749:   var schema = this.$__path(path) || this.schema.virtualpath(path)","\t750:     , pieces = path.split('.')","\t767:  * Returns the schematype for the given `path`.","\t769:  * @param {String} path","\t771:  * @method $__path","\t775: Document.prototype.$__path = function (path) {","\t776:   var adhocs = this.$__.adhocPaths","\t777:     , adhocType = adhocs && adhocs[path];","\t782:     return this.schema.path(path);","\t787:  * Marks the path as having pending changes to write to the db.","\t797:  * @param {String} path the path to mark modified","\t801: Document.prototype.markModified = function (path) {","\t802:   this.$__.activePaths.modify(path);","\t806:  * Returns the list of paths that have been modified.","\t812: Document.prototype.modifiedPaths = function () {","\t813:   var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);","\t815:   return directModifiedPaths.reduce(function (list, path) {","\t816:     var parts = path.split('.');","\t826:  * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.","\t836:  * @param {String} [path] optional","\t841: Document.prototype.isModified = function (path) {","\t842:   return path","\t843:     ? !!~this.modifiedPaths().indexOf(path)","\t844:     : this.$__.activePaths.some('modify');","\t848:  * Returns true if `path` was directly set and modified, else false.","\t856:  * @param {String} path","\t861: Document.prototype.isDirectModified = function (path) {","\t862:   return (path in this.$__.activePaths.states.modify);","\t866:  * Checks if `path` was initialized.","\t868:  * @param {String} path","\t873: Document.prototype.isInit = function (path) {","\t874:   return (path in this.$__.activePaths.states.init);","\t878:  * Checks if `path` was selected in the source query which initialized this document.","\t887:  * @param {String} path","\t892: Document.prototype.isSelected = function isSelected (path) {","\t895:     if ('_id' === path) {","\t899:     var paths = Object.keys(this.$__.selected)","\t900:       , i = paths.length","\t904:     if (1 === i && '_id' === paths[0]) {","\t910:       cur = paths[i];","\t916:     if (path in this.$__.selected) {","\t920:     i = paths.length;","\t921:     var pathDot = path + '.';","\t924:       cur = paths[i];","\t927:       if (0 === cur.indexOf(pathDot)) {","\t931:       if (0 === pathDot.indexOf(cur + '.')) {","\t972:   var paths = Object.keys(this.$__.activePaths.states.require).filter(function (path) {","\t973:     if (!self.isSelected(path) && !self.isModified(path)) return false;","\t977:   paths = paths.concat(Object.keys(this.$__.activePaths.states.init));","\t978:   paths = paths.concat(Object.keys(this.$__.activePaths.states.modify));","\t979:   paths = paths.concat(Object.keys(this.$__.activePaths.states.default));","\t981:   if (0 === paths.length) {","\t993:   for (var i = 0; i < paths.length; ++i) {","\t994:     var path = paths[i];","\t995:     var val = self.getValue(path);","\t1000:         paths.push(path + '.' + j);","\t1004:   paths.forEach(validatePath);","\t1007:   function validatePath (path) {","\t1008:     if (validating[path]) return;","\t1010:     validating[path] = true;","\t1014:       var p = self.schema.path(path);","\t1017:       var val = self.getValue(path);","\t1020:           self.invalidate(path, err, undefined, true);","\t1063:   var paths = Object.keys(this.$__.activePaths.states.require).filter(function (path) {","\t1064:     if (!self.isSelected(path) && !self.isModified(path)) return false;","\t1068:   paths = paths.concat(Object.keys(this.$__.activePaths.states.init));","\t1069:   paths = paths.concat(Object.keys(this.$__.activePaths.states.modify));","\t1070:   paths = paths.concat(Object.keys(this.$__.activePaths.states.default));","\t1074:   paths.forEach(function (path) {","\t1075:     if (validating[path]) return;","\t1077:     validating[path] = true;","\t1079:     var p = self.schema.path(path);","\t1082:     var val = self.getValue(path);","\t1085:       self.invalidate(path, err, undefined, true);","\t1097:  * Marks a path as invalid, causing validation to fail.","\t1114:  *               path: 'size',","\t1119:  * @param {String} path the field to invalidate","\t1120:  * @param {String|Error} errorMsg the error which states the reason `path` was invalid","\t1125: Document.prototype.invalidate = function (path, err, val) {","\t1130:   if (this.$__.validationError.errors[path]) return;","\t1134:       path: path,","\t1143:   this.$__.validationError.errors[path] = err;","\t1159:   this.$__.activePaths","\t1184:   this.$__.activePaths.clear('modify');","\t1188:   this.schema.requiredPaths().forEach(function (path) {","\t1189:     self.$__.activePaths.require(path);","\t1196:  * Returns this documents dirty paths / vals.","\t1206:   var all = this.$__.activePaths.map('modify', function (path) {","\t1207:     return { path: path","\t1208:            , value: self.getValue(path)","\t1209:            , schema: self.$__path(path) };","\t1212:   // Sort dirty paths in a flat hierarchy.","\t1214:     return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));","\t1219:     , lastPath","\t1223:     if (item.path.indexOf(lastPath) !== 0) {","\t1224:       lastPath = item.path + '.';","\t1230:         // the `top` array itself and a sub path of `top` are being modified.","\t1239:   top = lastPath = null;","\t1288:     , path = (prefix ? prefix + '.' : '') + prop;","\t1299:           if (!this.$__.getters[path]) {","\t1321:               return this.get(path);","\t1324:             compile(subprops, nested, path);","\t1325:             this.$__.getters[path] = nested;","\t1328:           return this.$__.getters[path];","\t1332:           return (this.$__.scope || this).set(path, v);","\t1340:       , get: function ( ) { return this.get.call(this.$__.scope || this, path); }","\t1341:       , set: function (v) { return this.set.call(this.$__.scope || this, path, v); }","\t1362:  * Get active path that were changed and are arrays","\t1365:  * @method $__getArrayPathsToValidate","\t1369: Document.prototype.$__getArrayPathsToValidate = function () {","\t1373:   return this.$__.activePaths","\t1398:   function docReducer(seed, path) {","\t1399:     var val = this[path];","\t1429:   var docs = this.$__getArrayPathsToValidate();","\t1549:  * - `getters` apply all getters (path and virtual getters)","\t1553:  * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)","\t1557:  * Example of only applying path getters","\t1565:  * Example of applying both path and virtual getters","\t1667:     // populated paths that we set to a document","\t1703:     applyGetters(this, ret, 'paths', options);","\t1704:     // applyGetters for paths will add nested empty objects;","\t1778:  * @param {String} type either `virtuals` or `paths`","\t1784:     , paths = Object.keys(schema[type])","\t1785:     , i = paths.length","\t1786:     , path","\t1789:     path = paths[i];","\t1791:     var parts = path.split('.')","\t1800:         branch[part] = clone(self.get(path), options);","\t1897:  *       path: 'notes',","\t1907:  *     doc.populate(path)               // not executed","\t1909:  *     doc.populate(path, callback)     // executed","\t1918:  * Passing the same path a second time will overwrite the previous path options.","\t1922:  * @param {String|Object} [path] The path to populate or an options object","\t1941:     // use hash to remove duplicate paths","\t1944:       pop[res[i].path] = res[i];","\t1949:     var paths = utils.object.vals(pop);","\t1951:     this.constructor.populate(this, paths, fn);","\t1966:  *         path: 'notes',","\t1981:  * Passing the same path a second time will overwrite the previous path options.","\t2003:  * Gets _id(s) used during population of the given `path`.","\t2012:  * If the path was not populated, undefined is returned.","\t2014:  * @param {String} path","\t2019: Document.prototype.populated = function (path, val, options) {","\t2024:     var v = this.$__.populated[path];","\t2033:     return this.$__.populated[path];","\t2037:   this.$__.populated[path] = { value: val, options: options };","\t2042:  * Returns the full path to this document.","\t2044:  * @param {String} [path]","\t2047:  * @method $__fullPath","\t2051: Document.prototype.$__fullPath = function (path) {","\t2053:   return path || '';","","/node_modules/acute-data-mongodb/node_modules/mongoose/lib/index.js:",""]},{"start":{"row":663,"column":0},"end":{"row":670,"column":0},"action":"insert","lines":["\t480: var driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';","","/node_modules/acute-data-mongodb/node_modules/mongoose/lib/internal.js:","\t16:   this.adhocPaths = undefined;","\t26:   this.activePaths = new ActiveRoster;","\t30:   this.fullPath = undefined;","",""]},{"start":{"row":670,"column":0},"end":{"row":743,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/model.js:","\t298:   delta[op][data.path] = val;","\t303:   // path excluded from versioning?","\t305:   if (skipVersioning && skipVersioning[data.path]) return;","\t342:   else if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {","\t343:     // subpath of array","\t359:   if (delta.$set && delta.$set[data.path]) {","\t441:     var match = checkDivergentArray(this, data.path, value);","\t455:     } else if (value._path && value._atomics) {","\t459:     } else if (value._path && Buffer.isBuffer(value)) {","\t487:  * @param {String} path","\t491: function checkDivergentArray (doc, path, array) {","\t492:   // see if we populated this path","\t493:   var pop = doc.populated(path, true);","\t498:     var top = path.split('.')[0];","\t526:       return path;","\t601:   var paths","\t605:     paths = Object.keys(this.$__.shardval)","\t606:     len = paths.length","\t609:       where[paths[i]] = this.$__.shardval[paths[i]];","\t731:   if (schema.path(key)) {","\t772:     schema._requiredpaths = undefined; // reset just in case Schema#requiredPaths() was called on either schema","\t1225:  * @param {String} path","\t1231: Model.where = function where (path, val) {","\t1641:  * The document returned has no paths marked as modified initially.","\t2094:  * - path: space delimited path(s) to populate","\t2105:  *           { path: 'company', match: { x: 1 }, select: 'name' }","\t2106:  *         , { path: 'notes', options: { limit: 10 }, model: 'override' }","\t2116:  *       var opts = [{ path: 'company', match: { x: 1 }, select: 'name' }]","\t2127:  *     Weapon.populate(user, { path: 'weapon', model: 'Weapon' }, function (err, user) {","\t2134:  *     Weapon.populate(users, { path: 'weapon' }, function (err, users) {","\t2145:  * @param {Object} options A hash of key/val (path, options) used for population.","\t2151: Model.populate = function (docs, paths, cb) {","\t2162:   // normalized paths","\t2163:   var paths = utils.populate(paths);","\t2164:   var pending = paths.length;","\t2171:   // each path has its own query options and must be executed separately","\t2173:   var path;","\t2176:     path = paths[i];","\t2177:     if ('function' === typeof path.model) model = path.model;","\t2178:     populate(model, docs, path, next);","\t2197:   var schema = model._getSchema(options.path),","\t2244:       path: options.path,","\t2310:     refPath = schema && schema.options && schema.options.refPath,","\t2313:   if (refPath) {","\t2316:       modelNames = utils.getValue(refPath, doc);","\t2374:     i, j, doc, docs, id, len, len2, ret, isDocument, populated, options, path;","\t2381:     path = options.path;","\t2390:         ret = utils.getValue(path, doc);","\t2404:         doc.populated(path, options._docs[id], options);","\t2436:  * to the original document path.","\t2449:   var path = o.path;","\t2454:     utils.setValue(path, rawIds[i], docs[i], function (val) {","\t2563:  *   if the value of the path is not an array, use findOne rules, else find.","\t2564:  *   for findOne the results are assigned directly to doc path (including null results).","\t2637:  * Finds the schema for `path`. This is different than","\t2638:  * calling `schema.path` as it also resolves paths with","\t2639:  * positional selectors (something.$.another.$.path).","\t2641:  * @param {String} path","\t2646: Model._getSchema = function _getSchema (path) {","\t2648:     , pathschema = schema.path(path);","\t2650:   if (pathschema)","\t2651:     return pathschema;","\t2657:       , trypath","\t2660:       trypath = parts.slice(0, p).join('.');","\t2661:       foundschema = schema.path(trypath);","\t2671:           // are remaining document paths to look up for casting.","\t2672:           // Also we need to handle array.$.path since schema.path","\t2675:           // a path like array.$","\t2681:               // this is the last path of the selector","\t2689:   })(path.split('.'), schema)","\t2705:   if (versioningEnabled && !schema.paths[schema.options.versionKey]) {","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":743,"column":0},"end":{"row":744,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/query.js:",""]},{"start":{"row":744,"column":0},"end":{"row":837,"column":0},"action":"insert","lines":["\t161:   p._path = this._path;","\t199:  * Specifies a `path` for use with chaining.","\t221:  * @param {String|Object} [path]","\t228:  * Specifies the complementary comparison value for paths specified with `where()`","\t293:  * When called with one argument, the most recent path passed to `where()` is used.","\t304:  * @param {String} [path]","\t313:  * When called with one argument, the most recent path passed to `where()` is used.","\t317:  * @param {String} [path]","\t326:  * When called with one argument, the most recent path passed to `where()` is used.","\t330:  * @param {String} [path]","\t339:  * When called with one argument, the most recent path passed to `where()` is used.","\t344:  * @param {String} [path]","\t352:  * When called with one argument, the most recent path passed to `where()` is used.","\t357:  * @param {String} [path]","\t365:  * When called with one argument, the most recent path passed to `where()` is used.","\t370:  * @param {String} [path]","\t378:  * When called with one argument, the most recent path passed to `where()` is used.","\t383:  * @param {String} [path]","\t391:  * When called with one argument, the most recent path passed to `where()` is used.","\t396:  * @param {String} [path]","\t404:  * When called with one argument, the most recent path passed to `where()` is used.","\t418:  * @param {String} [path]","\t426:  * When called with one argument, the most recent path passed to `where()` is used.","\t431:  * @param {String} [path]","\t439:  * When called with one argument, the most recent path passed to `where()` is used.","\t444:  * @param {String} [path]","\t454:  * @param {String} [path]","\t477:  * @param {String} [path]","\t505:  * @param {String|Object|Function} path","\t517:  *     query.where(path).within().box()","\t518:  *     query.where(path).within().circle()","\t519:  *     query.where(path).within().geometry()","\t563:  * @param {String} [path]","\t702:  * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](/docs/api.html#schematype_SchemaType-select).","\t718:  *     query.select('+path')","\t886:  * Makes sure _path is set.","\t888:  * @method _ensurePath","\t1017:   this._applyPaths();","\t1066:  * @param {Array} [pop] array of paths used in population","\t1176:   this._applyPaths();","\t1340:  * If a string is passed, it must be a space delimited list of path names. The","\t1341:  * sort order of each path is ascending unless the path name is prefixed with `-`","\t1447:  * @param {Array} [pop] array of paths used in population","\t1623:   this._applyPaths();","\t1720:  * _All paths passed that are not $atomic operations will become $set ops._","\t1935:  * Finds the schema for `path`. This is different than","\t1936:  * calling `schema.path` as it also resolves paths with","\t1937:  * positional selectors (something.$.another.$.path).","\t1939:  * @param {String} path","\t1943: Query.prototype._getSchema = function _getSchema (path) {","\t1944:   return this.model._getSchema(path);","\t1961:  * of their path schema type.","\t2024:       hasKeys |= this._walkUpdatePath(val, op);","\t2030:       // Also, _walkUpdatePath expects an operation, so give it $set since that","\t2032:       this._walkUpdatePath(ret.$set || {}, '$set');","\t2044:  * Walk each path of obj and cast its values","\t2049:  * @param {String} pref - path prefix (internal only)","\t2050:  * @return {Bool} true if this path has keys to update","\t2054: Query.prototype._walkUpdatePath = function _walkUpdatePath (obj, op, pref) {","\t2078:           // path is not in our strict schema","\t2082:             // ignore paths not specified in schema","\t2115:         hasKeys |= this._walkUpdatePath(val, op, prefix + key) ||","\t2125:                  !/real|nested/.test(this.model.schema.pathType(prefix + key));","\t2154:     // non-existing schema path","\t2216:  * Specifies paths which should be populated with other documents.","\t2225:  *         path: 'owner'","\t2238:  * Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.","\t2240:  * @param {Object|String} path either the path to populate or an object specifying all parameters","\t2261:     opts.populate[res[i].path] = res[i];","\t2345: Query.prototype._applyPaths = function applyPaths () {","\t2371:   var analyzePath = function(path, type) {","\t2374:     var plusPath = '+' + path;","\t2375:     if (fields && plusPath in fields) {","\t2377:       delete fields[plusPath];","\t2381:       if (false === exclude && keys.length > 1 && !~keys.indexOf(path)) {","\t2382:         fields[path] = 1;","\t2389:     var root = path.split('.')[0];","\t2392:     ;(type.selected ? selected : excluded).push(path);","\t2402:     schema.eachPath(function (path, type) {","\t2403:       if (prefix) path = prefix + '.' + path;","\t2405:       analyzePath(path, type);","\t2409:         analyzeSchema(type.schema, path);","\t2470:   this._applyPaths();","\t2527:  *     query.where('path').intersects().geometry({","\t2532:  *     query.where('path').intersects({","\t2573:  * The argument is assigned to the most recent path passed to `where()`.","\t2607:  * @param {String} [path]","\t2637:       // just passing a path","\t2713:  * @param {String|Array} [path]","\t2777:  * @param {String} [path]","\t2811:  * @param {String} [path]","","/node_modules/acute-data-mongodb/node_modules/mongoose/lib/queryhelpers.js:",""]},{"start":{"row":837,"column":0},"end":{"row":841,"column":0},"action":"insert","lines":["\t9:  * Prepare a set of path options for query population.","\t26:  * Prepare a set of path options for query population. This is the MongooseQuery","\t70:  * Set each path query option to lean","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":841,"column":0},"end":{"row":938,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema.js:","\t63:   this.paths = {};","\t64:   this.subpaths = {};","\t73:   this._requiredpaths = undefined;","\t75:   this._indexedpaths = undefined;","\t84:   // build paths","\t93:   var auto_id = !this.paths['_id'] && (!this.options.noId && this.options._id) && !_idSubDoc;","\t100:   var autoid = !this.paths['id'] && (!this.options.noVirtualId && this.options.id);","\t114:     if (!this.paths[createdAt]) {","\t160:  * Schema as flat paths","\t169:  * @property paths","\t172: Schema.prototype.paths;","\t236:  * Adds key path / schema type pairs to this schema.","\t256:       throw new TypeError('Invalid value for schema path `'+ prefix + key +'`');","\t260:       throw new TypeError('Invalid value for schema Array path `'+ prefix + key +'`');","\t269:         this.path(prefix + key, obj[key]); // mixed type","\t272:       this.path(prefix + key, obj[key]);","\t310:  * Gets/sets schema paths.","\t312:  * Sets a path (if arity 2)","\t313:  * Gets a path (if arity 1)","\t317:  *     schema.path('name') // returns a SchemaType","\t318:  *     schema.path('name', Number) // changes the schemaType of `name` to Number","\t320:  * @param {String} path","\t325: Schema.prototype.path = function (path, obj) {","\t327:     if (this.paths[path]) return this.paths[path];","\t328:     if (this.subpaths[path]) return this.subpaths[path];","\t330:     // subpaths?","\t331:     return /\\.\\d+\\.?.*$/.test(path)","\t332:       ? getPositionalPath(this, path)","\t336:   // some path names conflict with document methods","\t337:   if (reserved[path]) {","\t338:     throw new Error(\"`\" + path + \"` may not be used as a schema pathname\");","\t342:   var subpaths = path.split(/\\./)","\t343:     , last = subpaths.pop()","\t346:   subpaths.forEach(function(sub, i) {","\t349:       var msg = 'Cannot set nested path `' + path + '`. '","\t350:               + 'Parent path `'","\t351:               + subpaths.slice(0, i).concat([sub]).join('.')","\t361:   this.paths[path] = Schema.interpretAsType(path, obj);","\t368:  * @param {String} path","\t373: Schema.interpretAsType = function (path, obj) {","\t389:     return new MongooseTypes.Mixed(path, obj);","\t399:       return new MongooseTypes.DocumentArray(path, cast, obj);","\t407:       return new MongooseTypes.DocumentArray(path, new Schema(cast), obj);","\t410:     return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj);","\t429:     throw new TypeError('Undefined type `' + name + '` at `' + path +","\t434:   return new MongooseTypes[name](path, obj);","\t438:  * Iterates the schemas paths similar to Array#forEach.","\t440:  * The callback is passed the pathname and schemaType as arguments on each iteration.","\t447: Schema.prototype.eachPath = function (fn) {","\t448:   var keys = Object.keys(this.paths)","\t452:     fn(keys[i], this.paths[keys[i]]);","\t459:  * Returns an Array of path strings that are required by this schema.","\t465: Schema.prototype.requiredPaths = function requiredPaths () {","\t466:   if (this._requiredpaths) return this._requiredpaths;","\t468:   var paths = Object.keys(this.paths)","\t469:     , i = paths.length","\t473:     var path = paths[i];","\t474:     if (this.paths[path].isRequired) ret.push(path);","\t477:   return this._requiredpaths = ret;","\t487: Schema.prototype.indexedPaths = function indexedPaths () {","\t488:   if (this._indexedpaths) return this._indexedpaths;","\t490:   return this._indexedpaths = this.indexes();","\t494:  * Returns the pathType of `path` for this schema.","\t496:  * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.","\t498:  * @param {String} path","\t503: Schema.prototype.pathType = function (path) {","\t504:   if (path in this.paths) return 'real';","\t505:   if (path in this.virtuals) return 'virtual';","\t506:   if (path in this.nested) return 'nested';","\t507:   if (path in this.subpaths) return 'real';","\t509:   if (/\\.\\d+\\.|\\.\\d+$/.test(path) && getPositionalPath(this, path)) {","\t520: function getPositionalPath (self, path) {","\t521:   var subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);","\t522:   if (subpaths.length < 2) {","\t523:     return self.paths[subpaths[0]];","\t526:   var val = self.path(subpaths[0]);","\t529:   var last = subpaths.length - 1","\t530:     , subpath","\t533:   for (; i < subpaths.length; ++i) {","\t534:     subpath = subpaths[i];","\t536:     if (i === last && val && !val.schema && !/\\D/.test(subpath)) {","\t546:     // ignore if its just a position segment: path.0.subpath","\t547:     if (!/\\D/.test(subpath)) continue;","\t554:     val = val.schema.path(subpath);","\t557:   return self.subpaths[path] = val;","\t827:     var key, path, index, field, isObject, options, type;","\t828:     var keys = Object.keys(schema.paths);","\t832:       path = schema.paths[key];","\t834:       if (path instanceof MongooseTypes.DocumentArray) {","\t835:         collectIndexes(path.schema, key + '.');","\t837:         index = path._index;","\t864:       fixSubIndexPaths(schema, prefix);","\t879:    * These indexes need their paths prefixed properly.","\t884:   function fixSubIndexPaths (schema, prefix) {","\t938: Schema.prototype.virtualpath = function (name) {","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":938,"column":0},"end":{"row":979,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schematype.js:","\t14:  * @param {String} path","\t20: function SchemaType (path, options, instance) {","\t21:   this.path = path;","\t64:  *     schema.path('mixed').default(function () {","\t72:  *     schema.path('mixed').default({});","\t107:  *     Schema.path('my.path').index(true);","\t108:  *     Schema.path('my.date').index({ expires: 60 });","\t109:  *     Schema.path('my.path').index({ unique: true, sparse: true });","\t134:  *     Schema.path('name').index({ unique: true });","\t160:  *      Schema.path('name').index({text : true});","\t183:  *     Schema.path('name').index({ sparse: true });","\t216:  *     s.path('name').set(capitalize)","\t252:  *         return schematype.path + ' is required';","\t296:  *     s.path('born').get(dob)","\t320:  *         return schematype.path + ' is required';","\t322:  *         return schematype.path + ' is not';","\t351:  * Adds validator(s) for this document path.","\t367:  *     var custom = [validator, 'Uh oh, {PATH} does not equal \"something\".']","\t381:  *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');","\t385:  * From the examples above, you may have noticed that error messages support baseic templating. There are a few other template keywords besides `{PATH}` and `{VALUE}` too. To find out more, details are available [here](#error_messages_MongooseError-messages)","\t391:  *     schema.path('name').validate(function (value, respond) {","\t396: *      }, '{PATH} failed validation.');","\t469:  *     var s = new Schema({ born: { type: Date, required: '{PATH} is required!' })","\t471:  *     // or through the path API","\t473:  *     Schema.path('name').required(true);","\t477:  *     Schema.path('name').required(true, 'grrr :( ');","\t502:     // no validation when this path wasn't selected in the query.","\t504:         !this.isSelected(self.path) &&","\t505:         !this.isModified(self.path)) return true;","\t612:  * Sets default `select()` behavior for this path.","\t614:  * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.","\t644:     , path = this.path","\t666:     validatorProperties.path = path;","\t702:     , path = this.path","\t724:     validatorProperties.path = path;","\t752:   // fast path","\t755:   if (!ref && doc && doc.$__fullPath) {","\t759:     var path = doc.$__fullPath(self.path);","\t761:     ref = owner.populated(path);","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":979,"column":0},"end":{"row":1011,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/statemachine.js:","\t16:   this.paths = {};","\t26:  * place their path argument into the given state.","\t53:     // Changes the `path`'s state to `state`.","\t54:     ctor.prototype[state] = function (path) {","\t55:       this._changeState(path, state);","\t65:  * - `require(path)`","\t66:  * - `modify(path)`","\t67:  * - `init(path)`","\t72: StateMachine.prototype._changeState = function _changeState (path, nextState) {","\t73:   var prevBucket = this.states[this.paths[path]];","\t74:   if (prevBucket) delete prevBucket[path];","\t76:   this.paths[path] = nextState;","\t77:   this.states[nextState][path] = true;","\t87:     , path","\t90:     path = keys[i];","\t91:     delete this.states[state][path];","\t92:     delete this.paths[path];","\t97:  * Checks to see if at least one path is in the states passed in via `arguments`","\t131:     var paths = states.reduce(function (paths, state) {","\t132:       return paths.concat(Object.keys(self.states[state]));","\t135:     return paths[iterMethod](function (path, i, paths) {","\t136:       return callback(path, i, paths);","\t142:  * Iterates over the paths that belong to one of the parameter states.","\t145:  * this.forEach(state1, fn);         // iterates over all paths in state1","\t146:  * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2","\t147:  * this.forEach(fn);                 // iterates over all paths in all states","\t161:  * Maps over the paths that belong to one of the parameter states.","\t164:  * this.forEach(state1, fn);         // iterates over all paths in state1","\t165:  * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2","\t166:  * this.forEach(fn);                 // iterates over all paths in all states","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1011,"column":0},"end":{"row":1040,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/utils.js:","\t9:   , mpath = require('mpath')","\t505: function PopulateOptions (path, select, match, options, model) {","\t506:   this.path = path;","\t524: exports.populate = function populate (path, select, model, match, options) {","\t531:     if (path instanceof PopulateOptions) {","\t532:       return [path];","\t535:     if (Array.isArray(path)) {","\t536:       return path.map(function(o){","\t541:     if (exports.isObject(path)) {","\t542:       match = path.match;","\t543:       options = path.options;","\t544:       select = path.select;","\t545:       model = path.model;","\t546:       path = path.path;","\t554:   if ('string' != typeof path) {","\t555:     throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');","\t559:   var paths = path.split(' ');","\t560:   for (var i = 0; i < paths.length; ++i) {","\t561:     ret.push(new PopulateOptions(paths[i], select, match, options, model));","\t568:  * Return the value of `obj` at the given `path`.","\t570:  * @param {String} path","\t574: exports.getValue = function (path, obj, map) {","\t575:   return mpath.get(path, obj, '_doc', map);","\t579:  * Sets the value of `obj` at the given `path`.","\t581:  * @param {String} path","\t586: exports.setValue = function (path, val, obj, map) {","\t587:   mpath.set(path, val, obj, '_doc', map);","",""]},{"start":{"row":1040,"column":0},"end":{"row":1043,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/virtualtype.js:","\t17:   this.path = name;","",""]},{"start":{"row":1043,"column":0},"end":{"row":1048,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/error/cast.js:","\t16: function CastError (type, value, path) {","\t17:   MongooseError.call(this, 'Cast to ' + type + ' failed for value \"' + value + '\" at path \"' + path + '\"');","\t22:   this.path = path;","",""]},{"start":{"row":1048,"column":0},"end":{"row":1053,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/error/divergentArray.js:","\t14: function DivergentArrayError (paths) {","\t20:           + 'path(s) would have been modified unsafely:\\n'","\t21:           + '  ' + paths.join('\\n  ') + '\\n'","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1053,"column":0},"end":{"row":1067,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/error/messages.js:","\t7:  *     mongoose.Error.messages.String.enum  = \"Your custom message for {PATH}.\";","\t11:  * - `{PATH}` is replaced with the invalid document path","\t27: msg.general.default = \"Validator failed for path `{PATH}` with value `{VALUE}`\";","\t28: msg.general.required = \"Path `{PATH}` is required.\";","\t31: msg.Number.min = \"Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).\";","\t32: msg.Number.max = \"Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).\";","\t35: msg.Date.min = \"Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).\";","\t36: msg.Date.max = \"Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).\";","\t39: msg.String.enum = \"`{VALUE}` is not a valid enum value for path `{PATH}`.\";","\t40: msg.String.match = \"Path `{PATH}` is invalid ({VALUE}).\";","\t41: msg.String.minlength = \"Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).\";","\t42: msg.String.maxlength = \"Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).\";","",""]},{"start":{"row":1067,"column":0},"end":{"row":1070,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/error/validator.js:","\t28:   this.path = properties.path;","",""]},{"start":{"row":1070,"column":0},"end":{"row":1082,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/array.js:","\t60:       this.caster.path = key;","\t77:     return new MongooseArray(arr, self.path, this);","\t136:       var indexes = doc.schema.indexedPaths();","\t139:         var pathIndex = indexes[i][0][this.path];","\t140:         if ('2dsphere' === pathIndex || '2d' === pathIndex) {","\t147:       value = new MongooseArray(value, this.path, doc);","\t157:         throw new CastError(e.type, value, this.path);","\t166:       doc.markModified(this.path);","\t317:       o[this.path] = v;","\t318:       return cast(this.casterConstructor.schema, o)[this.path];","",""]},{"start":{"row":1082,"column":0},"end":{"row":1087,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/boolean.js:","\t11:  * @param {String} path","\t17: function SchemaBoolean (path, options) {","\t18:   SchemaType.call(this, path, options);","",""]},{"start":{"row":1087,"column":0},"end":{"row":1088,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/buffer.js:",""]},{"start":{"row":1088,"column":0},"end":{"row":1098,"column":0},"action":"insert","lines":["\t78:     // setting a populated path","\t82:       throw new CastError('buffer', value, this.path);","\t86:     // path to a plain object; cast to the Model used in","\t88:     var path = doc.$__fullPath(this.path);","\t90:     var pop = owner.populated(path, true);","\t107:       value = new MongooseBuffer(value, [this.path, doc]);","\t112:     var ret = new MongooseBuffer(value.value(true), [this.path, doc]);","\t123:     var ret = new MongooseBuffer(value, [this.path, doc]);","\t127:   throw new CastError('buffer', value, this.path);","",""]},{"start":{"row":1098,"column":0},"end":{"row":1106,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/date.js:","\t60:  *     schema.path('createdAt').expires('7d');","\t104:  *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];","\t109:  *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).","\t159:  *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];","\t164:  *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).","\t227:   throw new CastError('date', value, this.path);","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1106,"column":0},"end":{"row":1120,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/documentarray.js:","\t48:   var path = this.path;","\t54:     return new MongooseDocumentArray(arr, path, this);","\t167:     // the db and the path isn't an array in the document","\t169:       doc.markModified(this.path);","\t175:     value = new MongooseDocumentArray(value, this.path, doc);","\t188:         selected || (selected = scopePaths(this, doc.$__.selected, init));","\t215:  * Scopes paths selected in a query to this array.","\t218:  * @param {DocumentArray} array - the array to scope `fields` paths","\t223: function scopePaths (array, fields, init) {","\t226:   var path = array.path + '.'","\t235:     if (0 === key.indexOf(path)) {","\t237:       selected[key.substring(path.length)] = fields[key];","",""]},{"start":{"row":1120,"column":0},"end":{"row":1125,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/mixed.js:","\t12:  * @param {String} path","\t18: function Mixed (path, options) {","\t34:   SchemaType.call(this, path, options);","",""]},{"start":{"row":1125,"column":0},"end":{"row":1126,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/number.js:",""]},{"start":{"row":1126,"column":0},"end":{"row":1137,"column":0},"action":"insert","lines":["\t68:  *     var min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];","\t73:  *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).","\t121:  *     var max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];","\t126:  *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).","\t183:     // setting a populated path","\t187:       throw new CastError('number', value, this.path);","\t191:     // path to a plain object; cast to the Model used in","\t193:     var path = doc.$__fullPath(this.path);","\t195:     var pop = owner.populated(path, true);","\t217:   throw new CastError('number', value, this.path);","",""]},{"start":{"row":1137,"column":0},"end":{"row":1146,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/objectid.js:","\t93:     // setting a populated path","\t97:       throw new CastError('ObjectId', value, this.path);","\t101:     // path to a plain object; cast to the Model used in","\t103:     var path = doc.$__fullPath(this.path);","\t105:     var pop = owner.populated(path, true);","\t124:       throw new CastError('ObjectId', value, this.path);","\t128:   throw new CastError('ObjectId', value, this.path);","",""]},{"start":{"row":1146,"column":0},"end":{"row":1147,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/schema/string.js:",""]},{"start":{"row":1147,"column":0},"end":{"row":1162,"column":0},"action":"insert","lines":["\t51:  *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.","\t59:  *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'","\t65:  *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`","\t200:  *     var minlength = [10, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum length ({MINLENGTH}).'];","\t205:  *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).","\t253:  *     var maxlength = [10, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];","\t258:  *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (10).","\t301:  *       console.error(String(err)) // \"ValidationError: Path `name` is invalid (I am invalid).\"","\t381:     // setting a populated path","\t385:       throw new CastError('string', value, this.path);","\t389:     // path to a plain object; cast to the Model used in","\t391:     var path = doc.$__fullPath(this.path);","\t393:     var pop = owner.populated(path, true);","\t415:   throw new CastError('string', value, this.path);","",""]},{"start":{"row":1162,"column":0},"end":{"row":1183,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/services/updateValidators.js:","\t27:       var paths = Object.keys(castedDoc[keys[i]]);","\t28:       var numPaths = paths.length;","\t29:       for (var j = 0; j < numPaths; ++j) {","\t31:           updatedValues[paths[j]] = castedDoc[keys[i]][paths[j]];","\t33:           updatedValues[paths[j]] = undefined;","\t35:         updatedKeys[paths[j]] = true;","\t44:     paths = Object.keys(query._conditions);","\t45:     numPaths = keys.length;","\t46:     for (var i = 0; i < numPaths; ++i) {","\t47:       if (typeof query._conditions[paths[i]] === 'Object') {","\t48:         var conditionKeys = Object.keys(query._conditions[paths[i]]);","\t61:       updatedKeys[paths[i]] = true;","\t65:       schema.eachPath(function(path, schemaType) {","\t66:         if (path === '_id') {","\t71:         if (!updatedKeys[path] && typeof def !== 'undefined') {","\t73:           castedDoc.$setOnInsert[path] = def;","\t74:           updatedValues[path] = def;","\t87:         schema.path(updates[i]).doValidate(","\t107:           err.errors[validationErrors[i].path] = validationErrors[i];","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1183,"column":0},"end":{"row":1200,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/types/array.js:","\t20:  * @param {String} path","\t27: function MongooseArray (values, path, doc) {","\t35:   arr._path = path;","\t39:     arr._schema = doc.schema.path(path);","\t88:       populated = owner.populated(this._path, true);","\t121:    * @param {String} embeddedPath the path which changed in the embeddedDoc","\t126:   _markModified: function (elem, embeddedPath) {","\t128:       , dirtyPath;","\t131:       dirtyPath = this._path;","\t134:         if (null != embeddedPath) {","\t136:           dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;","\t139:           dirtyPath = dirtyPath + '.' + elem;","\t142:       parent.markModified(dirtyPath);","\t176:     // $atomic op on a single path","\t461:       , cur = this._parent.get(this._path)","",""]},{"start":{"row":1200,"column":0},"end":{"row":1201,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/types/buffer.js:",""]},{"start":{"row":1201,"column":0},"end":{"row":1209,"column":0},"action":"insert","lines":["\t6: var driver = global.MONGOOSE_DRIVER_PATH || '../drivers/node-mongodb-native';","\t39:   var path;","\t44:     path = encode[0];","\t57:     , _path: { value: path }","\t61:   if (doc && \"string\" === typeof path) {","\t63:         value: doc.schema.path(path)","\t108:       parent.markModified(this._path);","",""]},{"start":{"row":1209,"column":0},"end":{"row":1215,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/types/documentarray.js:","\t16:  * @param {String} path the path to this array","\t24: function MongooseDocumentArray (values, path, doc) {","\t35:   arr._path = path;","\t39:     arr._schema = doc.schema.path(path);","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1215,"column":0},"end":{"row":1241,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/types/embedded.js:","\t51:  * @param {String} path the path which changed","\t55: EmbeddedDocument.prototype.markModified = function (path) {","\t58:   this.$__.activePaths.modify(path);","\t65:     this.__parentArray._markModified(this, path);","\t157:  * Marks a path as invalid, causing validation to fail.","\t159:  * @param {String} path the field to invalidate","\t160:  * @param {String|Error} err error which states the reason `path` was invalid","\t165: EmbeddedDocument.prototype.invalidate = function (path, err, val, first) {","\t172:   var parentPath = this.__parentArray._path;","\t173:   var fullPath = [parentPath, index, path].join('.');","\t179:     this.__parent.invalidate(fullPath, err, val);","\t181:     this.__parent.invalidate(fullPath, err);","\t211:  * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.","\t213:  * @param {String} [path]","\t216:  * @method $__fullPath","\t220: EmbeddedDocument.prototype.$__fullPath = function (path) {","\t221:   if (!this.$__.fullPath) {","\t223:     if (!parent.__parent) return path;","\t225:     var paths = [];","\t227:       paths.unshift(parent.__parentArray._path);","\t231:     this.$__.fullPath = paths.join('.');","\t239:   return path","\t240:     ? this.$__.fullPath + '.' + path","\t241:     : this.$__.fullPath;","",""]},{"start":{"row":1241,"column":0},"end":{"row":1244,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/lib/types/objectid.js:","\t6: var driver = global.MONGOOSE_DRIVER_PATH || '../drivers/node-mongodb-native';","",""]},{"start":{"row":1244,"column":0},"end":{"row":1251,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/hooks-fixed/README.md:","\t30:   , Document = require('./path/to/some/document/constructor');","\t63:   , Document = require('./path/to/some/document/constructor');","\t122: Document.hook('set', function (path, val) {","\t123:   this[path] = val;","\t132: Document.pre('set', function (next, path, val) {","",""]},{"start":{"row":1251,"column":0},"end":{"row":1294,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/hooks-fixed/test.js:","\t329:     A.hook('set', function (path, val) {","\t330:       this[path] = val;","\t332:     A.pre('set', function (next, path, val) {","\t333:       path.should.equal('hello');","\t345: //    A.hook('set', function (path, val) {","\t346: //      this[path] = val;","\t360:     A.hook('set', function (path, val) {","\t361:       this[path] = val;","\t363:     A.post('set', function (next, path, val) {","\t364:       path.should.equal('hello');","\t375: //    A.hook('set', function (path, val) {","\t376: //      this[path] = val;","\t390:     A.hook('set', function (path, val) {","\t391:       this[path] = val;","\t394:     A.pre('set', function (next, path, val) {","\t397:     A.pre('set', function (next, path, val) {","\t398:       assert.equal(path, 'foo');","\t402:     A.pre('set', function (next, path, val, opt) {","\t403:       assert.equal(path, 'rock');","\t416:     A.hook('set', function (path, val) {","\t417:       this[path] = val;","\t419:     A.pre('set', function (next, path, val) {","\t422:     A.post('set', function (next, path, val) {","\t423:       path.should.equal('foo');","\t440:     A.hook('set', function (path, val, opts) {","\t441:       this[path] = val;","\t443:     A.pre('set', function (next, path, val, opts) {","\t455:     A.hook('set', function (path, val) {","\t457:       this[path] = val;","\t460:     A.pre('set', function (next, path, val) {","\t464:     A.pre('set', true, function (next, done, path, val) {","\t472:     A.pre('set', function (next, path, val) {","\t476:     A.pre('set', true, function (next, done, path, val) {","\t492:     A.hook('set', function (path, val) {","\t493:       this[path] = val;","\t494:       if (path === 'hello') counter.should.equal(1);","\t495:       if (path === 'foo') counter.should.equal(2);","\t497:     A.pre('set', true, function (next, done, path, val) {","\t565:     A.hook('set', function (path, val, fn) {","\t567:       this[path] = val;","\t570:     A.pre('set', true, function (next, done, path, val, fn) {","",""]},{"start":{"row":1294,"column":0},"end":{"row":1299,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/HISTORY.md:","\t9: - Optimized query path for performance, moving Object.defineProperty outside of constructors.","\t935: * Cleanup of bson.js to remove duplicated code paths","\t937: * Removing require.paths to make tests work with the 0.5.X branch","",""]},{"start":{"row":1299,"column":0},"end":{"row":1303,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/README.md:","\t91: Let's boot up a MongoDB server instance. Download the right MongoDB version from [MongoDB](http://www.mongodb.org), open a new shell or command line and ensure the **mongod** command is in the shell or command line path. Now let's create a database directory (in our case under **/data**).","\t94: mongod --dbpath=/data --port 27017","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1303,"column":0},"end":{"row":1307,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/README.md:","\t85: Let's boot up a MongoDB server instance. Download the right MongoDB version from [MongoDB](http://www.mongodb.org), open a new shell or command line and ensure the **mongod** command is in the shell or command line path. Now let's create a database directory (in our case under **/data**).","\t88: mongod --dbpath=/data --port 27017","",""]},{"start":{"row":1307,"column":0},"end":{"row":1310,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/TESTING.md:","\t6: mongod --dbpath=./db","",""]},{"start":{"row":1310,"column":0},"end":{"row":1313,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/cursor.js:","\t204:     // Otherwise fall back to regular find path","",""]},{"start":{"row":1313,"column":0},"end":{"row":1323,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/mongos_manager.js:","\t4:   , path = require('path')","\t42:   // Set default db path if none set","\t43:   var pidfilepath = mongosOptions.pidfilepath = mongosOptions.pidfilepath || path.join(path.resolve('data'), f(\"data-%d\", port));","\t44:   var logpath = mongosOptions.logpath = mongosOptions.logpath || path.join(path.resolve('data'), f(\"data-%d.log\", port));","\t66:   // Add the file path","\t67:   pidfilepath = mongosOptions.pidfilepath = f(\"%s/mongos-%s.pid\", pidfilepath, port);","\t107:           pid = fs.readFileSync(pidfilepath, 'ascii').trim();          ","\t123:             pid = fs.readFileSync(pidfilepath, 'ascii').trim();          ","",""]},{"start":{"row":1323,"column":0},"end":{"row":1324,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/replset_manager.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1324,"column":0},"end":{"row":1354,"column":0},"action":"insert","lines":["\t4:   , path = require('path')","\t60:   // DbPath","\t61:   var dbpath = replsetOptions.dbpath = replsetOptions.dbpath || path.resolve('data');","\t343:     // Remove db path and recreate it","\t346:         rimraf.sync(dbpath);","\t347:         mkdirp.sync(dbpath);","\t363:         opts.dbpath = opts.dbpath ? opts.dbpath + f(\"/data-%s\", opts.port) : null;","\t364:         opts.logpath = opts.logpath ? opts.logpath + f(\"/data-%s.log\", opts.port) : null;","","/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/server_manager.js:","\t4:   , path = require('path')","\t61:   // Set default db path if none set","\t62:   var dbpath = serverOptions.dbpath = serverOptions.dbpath || path.join(path.resolve('data'), f(\"data-%d\", port));","\t63:   var logpath = serverOptions.logpath = serverOptions.logpath || path.join(path.resolve('data'), f(\"data-%d.log\", port));","\t73:   Object.defineProperty(this, 'dbpath', {","\t74:     enumerable:true, get: function() { return dbpath; }","\t77:   Object.defineProperty(this, 'logpath', {","\t78:     enumerable:true, get: function() { return logpath; }","\t115:     , 'journal', 'notablescan', 'noscripting', 'repairpath', 'repair'","\t118:     , 'dbpath', 'sysinfo', 'cpu', 'profile', 'slowms', 'rest'","\t121:     , 'keyFile', 'pidfilepath', 'timeStampFormat', 'logappend'","\t122:     , 'syslogFacility', 'syslog', 'logpath', 'maxConns', 'bind_ip', 'port'","\t190:             pid = fs.readFileSync(path.join(dbpath, \"mongod.lock\"), 'ascii').trim();","\t249:         rimraf.sync(serverOptions.dbpath);","\t250:         mkdirp.sync(serverOptions.dbpath);        ","\t255:     if(fs.existsSync(path.join(dbpath, \"mongod.lock\"))) {","\t256:       fs.unlinkSync(path.join(dbpath, \"mongod.lock\"));","\t289:   var locateLockFile = function(dbpath) {","\t296:           , pid: fs.readFileSync(path.join(dbpath, possibleLockFiles[i]), 'ascii').trim()","",""]},{"start":{"row":1354,"column":0},"end":{"row":1369,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/sharding_manager.js:","\t4:   , path = require('path')","\t70:   var dbpath = mongosOptions.dbpath;","\t71:   var logpath = mongosOptions.logpath;","\t109:         opts.dbpath = dbpath + f(\"/data-%s\", initiallConfigPort);","\t110:         opts.logpath = logpath + f(\"/data-%s.log\", initiallConfigPort);","\t141:         opts.dbpath = dbpath;","\t142:         opts.logpath = logpath;","\t181:         opts.pidfilepath = f(\"%s\", dbpath);","\t182:         opts.logpath = f(\"%s/mongos-%s.log\", logpath, initiallMongosPort);","\t260:             rimraf.sync(dbpath);","\t261:             mkdirp.sync(dbpath);","\t272:       rimraf.sync(dbpath);","\t273:       mkdirp.sync(dbpath);","",""]},{"start":{"row":1369,"column":0},"end":{"row":1381,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/browser_build/bson.js:","\t30: function normalize(path) {","\t31:   var ret = [], parts = path.split('/'), cur, prev;","\t52: function dirname(path) {","\t53:   return path && path.substr(0, path.lastIndexOf(\"/\")) || \".\";","\t2705:   , './long'].forEach(function (path) {","\t2706:   \tvar module = require('./' + path);","\t2728: ].forEach(function (path) {","\t2729:     \tvar module = require('./' + path);","\t2753:     , '././bson'].forEach(function (path) {","\t2754:     \tvar module = require('./' + path);","",""]},{"start":{"row":1381,"column":0},"end":{"row":1384,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/build/bson.target.mk:","\t118: # Copy this to the executable output path.","",""]},{"start":{"row":1384,"column":0},"end":{"row":1385,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/build/Makefile:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1385,"column":0},"end":{"row":1396,"column":0},"action":"insert","lines":["\t11: abs_srcdir := $(abspath $(srcdir))","\t28: # as they reach into the src/ directory for data with relative paths.","\t30: abs_builddir := $(abspath $(builddir))","\t35: abs_obj := $(abspath $(obj))","\t79: # http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces","\t93: # ccache or distcc lose the path to the target, so we convert a rule of","\t97: #   path/to/foobar.o: DEP1 DEP2","\t114: # Fixup path as in (1).","\t171: # the local, absolute paths used on the link command-line.","\t186: # $LD_LIBRARY_PATH), without triggering make substitution.","",""]},{"start":{"row":1396,"column":0},"end":{"row":1397,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/ext/wscript:",""]},{"start":{"row":1397,"column":0},"end":{"row":1400,"column":0},"action":"insert","lines":["\t3: from os.path import exists ","\t24:   # conf.check(lib='node', libpath=['/usr/lib', '/usr/local/lib'], uselib_store='NODE')","",""]},{"start":{"row":1400,"column":0},"end":{"row":1408,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/lib/bson/index.js:","\t18:   , './long'].forEach(function (path) {","\t19:   \tvar module = require('./' + path);","\t41: ].forEach(function (path) {","\t42:     \tvar module = require('./' + path);","\t66:     , '././bson'].forEach(function (path) {","\t67:     \tvar module = require('./' + path);","",""]},{"start":{"row":1408,"column":0},"end":{"row":1411,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/CHANGELOG.md:","\t166:  - fix \"not all control paths return a value\" compile warning on some platforms","",""]},{"start":{"row":1411,"column":0},"end":{"row":1414,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/include_dirs.js:","\t1: console.log(require('path').relative('.', __dirname));","",""]},{"start":{"row":1414,"column":0},"end":{"row":1418,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/README.md:","\t92: Pull in the path to **NAN** in your *binding.gyp* so that you can use `#include <nan.h>` in your *.cpp* files:","\t100: This works like a `-I<path-to-NAN>` when compiling your addon.","",""]},{"start":{"row":1418,"column":0},"end":{"row":1421,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/build/kerberos.target.mk:","\t133: # Copy this to the executable output path.","",""]},{"start":{"row":1421,"column":0},"end":{"row":1422,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/build/Makefile:",""]},{"start":{"row":1422,"column":0},"end":{"row":1433,"column":0},"action":"insert","lines":["\t11: abs_srcdir := $(abspath $(srcdir))","\t28: # as they reach into the src/ directory for data with relative paths.","\t30: abs_builddir := $(abspath $(builddir))","\t35: abs_obj := $(abspath $(obj))","\t79: # http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces","\t93: # ccache or distcc lose the path to the target, so we convert a rule of","\t97: #   path/to/foobar.o: DEP1 DEP2","\t114: # Fixup path as in (1).","\t171: # the local, absolute paths used on the link command-line.","\t186: # $LD_LIBRARY_PATH), without triggering make substitution.","",""]},{"start":{"row":1433,"column":0},"end":{"row":1436,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/CHANGELOG.md:","\t166:  - fix \"not all control paths return a value\" compile warning on some platforms","",""]},{"start":{"row":1436,"column":0},"end":{"row":1439,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/include_dirs.js:","\t1: console.log(require('path').relative('.', __dirname));","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1439,"column":0},"end":{"row":1440,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/README.md:",""]},{"start":{"row":1440,"column":0},"end":{"row":1443,"column":0},"action":"insert","lines":["\t92: Pull in the path to **NAN** in your *binding.gyp* so that you can use `#include <nan.h>` in your *.cpp* files:","\t100: This works like a `-I<path-to-NAN>` when compiling your addon.","",""]},{"start":{"row":1443,"column":0},"end":{"row":1450,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/index.js:","\t1: var path = require('path');","\t24:     p = path.resolve(p);","\t33:                 mkdirP(path.dirname(p), opts, function (er, made) {","\t67:     p = path.resolve(p);","\t76:                 made = sync(path.dirname(p), opts, made);","",""]},{"start":{"row":1450,"column":0},"end":{"row":1456,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/readme.markdown:","\t46: `opts.fs`. Your implementation should have `opts.fs.mkdir(path, mode, cb)` and","\t47: `opts.fs.stat(path, cb)`.","\t60: `opts.fs`. Your implementation should have `opts.fs.mkdirSync(path, mode)` and","\t61: `opts.fs.statSync(path)`.","",""]},{"start":{"row":1456,"column":0},"end":{"row":1461,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/bin/cmd.js:","\t16: var paths = argv._.slice();","\t20:     if (paths.length === 0) return;","\t21:     var p = paths.shift();","",""]},{"start":{"row":1461,"column":0},"end":{"row":1464,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/chmod.js:","\t2: var path = require('path');","",""]},{"start":{"row":1464,"column":0},"end":{"row":1467,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/clobber.js:","\t2: var path = require('path');","",""]},{"start":{"row":1467,"column":0},"end":{"row":1471,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/mkdirp.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":1471,"column":0},"end":{"row":1474,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/opts_fs.js:","\t2: var path = require('path');","",""]},{"start":{"row":1474,"column":0},"end":{"row":1477,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/opts_fs_sync.js:","\t2: var path = require('path');","",""]},{"start":{"row":1477,"column":0},"end":{"row":1481,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/perm.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":1481,"column":0},"end":{"row":1486,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/perm_sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","","/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/race.js:",""]},{"start":{"row":1486,"column":0},"end":{"row":1493,"column":0},"action":"insert","lines":["\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","","/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/rel.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":1493,"column":0},"end":{"row":1496,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/return.js:","\t2: var path = require('path');","",""]},{"start":{"row":1496,"column":0},"end":{"row":1499,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/return_sync.js:","\t2: var path = require('path');","",""]},{"start":{"row":1499,"column":0},"end":{"row":1507,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/root.js:","\t2: var path = require('path');","\t8:     var file = path.resolve('/');","","/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":1507,"column":0},"end":{"row":1511,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/umask.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":1511,"column":0},"end":{"row":1515,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/umask_sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":1515,"column":0},"end":{"row":1519,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/bin.js:","\t21:   log('Usage: rimraf <path>')","\t23:   log('  Deletes all files and folders at \"path\" recursively.')","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1519,"column":0},"end":{"row":1522,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/README.md:","\t25: command `rimraf <path>` which is useful for cross platform support.","",""]},{"start":{"row":1522,"column":0},"end":{"row":1527,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/rimraf.js:","\t4: var path = require(\"path\")","\t131:       rimraf(path.join(p, f), function (er) {","\t175:     rimrafSync(path.join(p, f))","",""]},{"start":{"row":1527,"column":0},"end":{"row":1531,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/test/test-async.js:","\t2:   , path = require(\"path\")","\t3: rimraf(path.join(__dirname, \"target\"), function (er) {","",""]},{"start":{"row":1531,"column":0},"end":{"row":1535,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/test/test-sync.js:","\t2:   , path = require(\"path\")","\t3: rimraf.sync(path.join(__dirname, \"target\"))","",""]},{"start":{"row":1535,"column":0},"end":{"row":1540,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/readable-stream/lib/_stream_transform.js:","\t51: // a pathological inflate type of transform can cause excessive buffering","\t57: // such a pathological inflating mechanism, there'd be no way to tell","\t61: // However, even in such a pathological case, only a single written chunk","",""]},{"start":{"row":1540,"column":0},"end":{"row":1541,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mongodb/node_modules/readable-stream/node_modules/isarray/build/build.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1541,"column":0},"end":{"row":1592,"column":0},"action":"insert","lines":["\t3:  * Require the given path.","\t5:  * @param {String} path","\t10: function require(path, parent, orig) {","\t11:   var resolved = require.resolve(path);","\t15:     orig = orig || path;","\t18:     err.path = orig;","\t51:  * Resolve `path`.","\t55:  *   - PATH/index.js","\t56:  *   - PATH.js","\t57:  *   - PATH","\t59:  * @param {String} path","\t60:  * @return {String} path or null","\t64: require.resolve = function(path) {","\t65:   if (path.charAt(0) === '/') path = path.slice(1);","\t66:   var index = path + '/index.js';","\t68:   var paths = [","\t69:     path,","\t70:     path + '.js',","\t71:     path + '.json',","\t72:     path + '/index.js',","\t73:     path + '/index.json'","\t76:   for (var i = 0; i < paths.length; i++) {","\t77:     var path = paths[i];","\t78:     if (require.modules.hasOwnProperty(path)) return path;","\t87:  * Normalize `path` relative to the current path.","\t90:  * @param {String} path","\t95: require.normalize = function(curr, path) {","\t98:   if ('.' != path.charAt(0)) return path;","\t101:   path = path.split('/');","\t103:   for (var i = 0; i < path.length; ++i) {","\t104:     if ('..' == path[i]) {","\t106:     } else if ('.' != path[i] && '' != path[i]) {","\t107:       segs.push(path[i]);","\t115:  * Register module at `path` with callback `definition`.","\t117:  * @param {String} path","\t122: require.register = function(path, definition) {","\t123:   require.modules[path] = definition;","\t142:  * Return a require function relative to the `parent` path.","\t168:   function localRequire(path) {","\t169:     var resolved = localRequire.resolve(path);","\t170:     return require(resolved, parent, path);","\t177:   localRequire.resolve = function(path) {","\t178:     var c = path.charAt(0);","\t179:     if ('/' == c) return path.slice(1);","\t180:     if ('.' == c) return require.normalize(p, path);","\t188:     path = segs.slice(0, i + 1).join('/') + '/deps/' + path;","\t189:     return path;","\t193:    * Check if module is defined at `path`.","\t196:   localRequire.exists = function(path) {","\t197:     return require.modules.hasOwnProperty(localRequire.resolve(path));","",""]},{"start":{"row":1592,"column":0},"end":{"row":1593,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mpath/package.json:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1593,"column":0},"end":{"row":1605,"column":0},"action":"insert","lines":["\t2:   \"name\": \"mpath\",","\t4:   \"description\": \"{G,S}et object values using MongoDB path notation\",","\t11:     \"url\": \"git://github.com/aheckmann/mpath.git\"","\t15:     \"path\",","\t27:   \"readme\": \"#mpath\\n\\n{G,S}et javascript object values using MongoDB-like path notation.\\n\\n###Getting\\n\\n```js\\nvar mpath = require('mpath');\\n\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.get('comments.1.title', obj) // 'exciting!'\\n```\\n\\n`mpath.get` supports array property notation as well.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.get('comments.title', obj) // ['funny', 'exciting!']\\n```\\n\\nArray property and indexing syntax, when used together, are very powerful.\\n\\n```js\\nvar obj = {\\n  array: [\\n      { o: { array: [{x: {b: [4,6,8]}}, { y: 10} ] }}\\n    , { o: { array: [{x: {b: [1,2,3]}}, { x: {z: 10 }}, { x: 'Turkey Day' }] }}\\n    , { o: { array: [{x: {b: null }}, { x: { b: [null, 1]}}] }}\\n    , { o: { array: [{x: null }] }}\\n    , { o: { array: [{y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ];\\n}\\n\\nvar found = mpath.get('array.o.array.x.b.1', obj);\\n\\nconsole.log(found); // prints..\\n\\n    [ [6, undefined]\\n    , [2, undefined, undefined]\\n    , [null, 1]\\n    , [null]\\n    , [undefined]\\n    , [undefined, undefined, undefined]\\n    , undefined\\n    ]\\n\\n```\\n\\n#####Field selection rules:\\n\\nThe following rules are iteratively applied to each `segment` in the passed `path`. For example:\\n\\n```js\\nvar path = 'one.two.14'; // path\\n'one' // segment 0\\n'two' // segment 1\\n14    // segment 2\\n```\\n\\n- 1) when value of the segment parent is not an array, return the value of `parent.segment`\\n- 2) when value of the segment parent is an array\\n  - a) if the segment is an integer, replace the parent array with the value at `parent[segment]`\\n  - b) if not an integer, keep the array but replace each array `item` with the value returned from calling `get(remainingSegments, item)` or undefined if falsey.\\n\\n#####Maps\\n\\n`mpath.get` also accepts an optional `map` argument which receives each individual found value. The value returned from the `map` function will be used in the original found values place.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.get('comments.title', obj, function (val) {\\n  return 'funny' == val\\n    ? 'amusing'\\n    : val;\\n});\\n// ['amusing', 'exciting!']\\n```\\n\\n###Setting\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.1.title', 'hilarious', obj)\\nconsole.log(obj.comments[1].title) // 'hilarious'\\n```\\n\\n`mpath.set` supports the same array property notation as `mpath.get`.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.title', ['hilarious', 'fruity'], obj);\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: 'hilarious' },\\n      { title: 'fruity' }\\n  ]}\\n```\\n\\nArray property and indexing syntax can be used together also when setting.\\n\\n```js\\nvar obj = {\\n  array: [\\n      { o: { array: [{x: {b: [4,6,8]}}, { y: 10} ] }}\\n    , { o: { array: [{x: {b: [1,2,3]}}, { x: {z: 10 }}, { x: 'Turkey Day' }] }}\\n    , { o: { array: [{x: {b: null }}, { x: { b: [null, 1]}}] }}\\n    , { o: { array: [{x: null }] }}\\n    , { o: { array: [{y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ]\\n}\\n\\nmpath.set('array.1.o', 'this was changed', obj);\\n\\nconsole.log(require('util').inspect(obj, false, 1000)); // prints..\\n\\n{\\n  array: [\\n      { o: { array: [{x: {b: [4,6,8]}}, { y: 10} ] }}\\n    , { o: 'this was changed' }\\n    , { o: { array: [{x: {b: null }}, { x: { b: [null, 1]}}] }}\\n    , { o: { array: [{x: null }] }}\\n    , { o: { array: [{y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ];\\n}\\n\\nmpath.set('array.o.array.x', 'this was changed too', obj);\\n\\nconsole.log(require('util').inspect(obj, false, 1000)); // prints..\\n\\n{\\n  array: [\\n      { o: { array: [{x: 'this was changed too'}, { y: 10, x: 'this was changed too'} ] }}\\n    , { o: 'this was changed' }\\n    , { o: { array: [{x: 'this was changed too'}, { x: 'this was changed too'}] }}\\n    , { o: { array: [{x: 'this was changed too'}] }}\\n    , { o: { array: [{x: 'this was changed too', y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ];\\n}\\n```\\n\\n####Setting arrays\\n\\nBy default, setting a property within an array to another array results in each element of the new array being set to the item in the destination array at the matching index. An example is helpful.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.title', ['hilarious', 'fruity'], obj);\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: 'hilarious' },\\n      { title: 'fruity' }\\n  ]}\\n```\\n\\nIf we do not desire this destructuring-like assignment behavior we may instead specify the `$` operator in the path being set to force the array to be copied directly.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.$.title', ['hilarious', 'fruity'], obj);\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: ['hilarious', 'fruity'] },\\n      { title: ['hilarious', 'fruity'] }\\n  ]}\\n```\\n\\n####Field assignment rules\\n\\nThe rules utilized mirror those used on `mpath.get`, meaning we can take values returned from `mpath.get`, update them, and reassign them using `mpath.set`. Note that setting nested arrays of arrays can get unweildy quickly. Check out the [tests](https://github.com/aheckmann/mpath/blob/master/test/index.js) for more extreme examples.\\n\\n#####Maps\\n\\n`mpath.set` also accepts an optional `map` argument which receives each individual value being set. The value returned from the `map` function will be used in the original values place.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.title', ['hilarious', 'fruity'], obj, function (val) {\\n  return val.length;\\n});\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: 9 },\\n      { title: 6 }\\n  ]}\\n```\\n\\n### Custom object types\\n\\nSometimes you may want to enact the same functionality on custom object types that store all their real data internally, say for an ODM type object. No fear, `mpath` has you covered. Simply pass the name of the property being used to store the internal data and it will be traversed instead:\\n\\n```js\\nvar mpath = require('mpath');\\n\\nvar obj = {\\n    comments: [\\n      { title: 'exciting!', _doc: { title: 'great!' }}\\n    ]\\n}\\n\\nmpath.get('comments.0.title', obj, '_doc')            // 'great!'\\nmpath.set('comments.0.title', 'nov 3rd', obj, '_doc')\\nmpath.get('comments.0.title', obj, '_doc')            // 'nov 3rd'\\nmpath.get('comments.0.title', obj)                    // 'exciting'\\n```\\n\\nWhen used with a `map`, the `map` argument comes last.\\n\\n```js\\nmpath.get(path, obj, '_doc', map);\\nmpath.set(path, val, obj, '_doc', map);\\n```\\n\\n[LICENSE](https://github.com/aheckmann/mpath/blob/master/LICENSE)\\n\\n\",","\t28:   \"_id\": \"mpath@0.1.1\",","\t31:     \"tarball\": \"http://registry.npmjs.org/mpath/-/mpath-0.1.1.tgz\"","\t46:   \"_from\": \"mpath@0.1.1\",","\t47:   \"_resolved\": \"https://registry.npmjs.org/mpath/-/mpath-0.1.1.tgz\",","\t49:     \"url\": \"https://github.com/aheckmann/mpath/issues\"","\t51:   \"homepage\": \"https://github.com/aheckmann/mpath\"","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1605,"column":0},"end":{"row":1638,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mpath/README.md:","\t1: #mpath","\t3: {G,S}et javascript object values using MongoDB-like path notation.","\t8: var mpath = require('mpath');","\t17: mpath.get('comments.1.title', obj) // 'exciting!'","\t20: `mpath.get` supports array property notation as well.","\t30: mpath.get('comments.title', obj) // ['funny', 'exciting!']","\t48: var found = mpath.get('array.o.array.x.b.1', obj);","\t65: The following rules are iteratively applied to each `segment` in the passed `path`. For example:","\t68: var path = 'one.two.14'; // path","\t81: `mpath.get` also accepts an optional `map` argument which receives each individual found value. The value returned from the `map` function will be used in the original found values place.","\t91: mpath.get('comments.title', obj, function (val) {","\t109: mpath.set('comments.1.title', 'hilarious', obj)","\t113: `mpath.set` supports the same array property notation as `mpath.get`.","\t123: mpath.set('comments.title', ['hilarious', 'fruity'], obj);","\t148: mpath.set('array.1.o', 'this was changed', obj);","\t164: mpath.set('array.o.array.x', 'this was changed too', obj);","\t193: mpath.set('comments.title', ['hilarious', 'fruity'], obj);","\t203: If we do not desire this destructuring-like assignment behavior we may instead specify the `$` operator in the path being set to force the array to be copied directly.","\t213: mpath.set('comments.$.title', ['hilarious', 'fruity'], obj);","\t225: The rules utilized mirror those used on `mpath.get`, meaning we can take values returned from `mpath.get`, update them, and reassign them using `mpath.set`. Note that setting nested arrays of arrays can get unweildy quickly. Check out the [tests](https://github.com/aheckmann/mpath/blob/master/test/index.js) for more extreme examples.","\t229: `mpath.set` also accepts an optional `map` argument which receives each individual value being set. The value returned from the `map` function will be used in the original values place.","\t239: mpath.set('comments.title', ['hilarious', 'fruity'], obj, function (val) {","\t253: Sometimes you may want to enact the same functionality on custom object types that store all their real data internally, say for an ODM type object. No fear, `mpath` has you covered. Simply pass the name of the property being used to store the internal data and it will be traversed instead:","\t256: var mpath = require('mpath');","\t264: mpath.get('comments.0.title', obj, '_doc')            // 'great!'","\t265: mpath.set('comments.0.title', 'nov 3rd', obj, '_doc')","\t266: mpath.get('comments.0.title', obj, '_doc')            // 'nov 3rd'","\t267: mpath.get('comments.0.title', obj)                    // 'exciting'","\t273: mpath.get(path, obj, '_doc', map);","\t274: mpath.set(path, val, obj, '_doc', map);","\t277: [LICENSE](https://github.com/aheckmann/mpath/blob/master/LICENSE)","",""]},{"start":{"row":1638,"column":0},"end":{"row":1671,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mpath/lib/index.js:","\t3:  * Returns the value of object `o` at the given `path`.","\t14:  *     mpath.get('comments.0.title', o)         // 'exciting!'","\t15:  *     mpath.get('comments.0.title', o, '_doc') // 'great!'","\t16:  *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']","\t19:  *     mpath.get(path, o)","\t20:  *     mpath.get(path, o, special)","\t21:  *     mpath.get(path, o, map)","\t22:  *     mpath.get(path, o, special, map)","\t24:  * @param {String} path","\t26:  * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.","\t30: exports.get = function (path, o, special, map) {","\t38:   var parts = 'string' == typeof path","\t39:     ? path.split('.')","\t40:     : path","\t43:     throw new TypeError('Invalid `path`. Must be either string or array');","\t54:       var paths = parts.slice(i);","\t58:           ? exports.get(paths, item, special, map)","\t74:  * Sets the `val` at the given `path` of object `o`.","\t76:  * @param {String} path","\t79:  * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.","\t84: exports.set = function (path, val, o, special, map, _copying) {","\t92:   var parts = 'string' == typeof path","\t93:     ? path.split('.')","\t94:     : path","\t97:     throw new TypeError('Invalid `path`. Must be either string or array');","\t102:   // the existance of $ in a path tells us if the user desires","\t106:   var copy = _copying || /\\$/.test(path)","\t122:       var paths = parts.slice(i);","\t126:           exports.set(paths, val[j], obj[j], special, map, copy);","\t131:           exports.set(paths, val, obj[j], special, map, copy);","\t144:   // process the last property of the path","",""]},{"start":{"row":1671,"column":0},"end":{"row":1672,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mpath/test/index.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1672,"column":0},"end":{"row":1876,"column":0},"action":"insert","lines":["\t6: var mpath = require('../')","\t19:  * special path for override tests","\t28: describe('mpath', function(){","\t63:     it('`path` must be a string or array', function(done){","\t65:         mpath.get({}, o);","\t68:         mpath.get(4, o);","\t71:         mpath.get(function(){}, o);","\t74:         mpath.get(/asdf/, o);","\t77:         mpath.get(Math, o);","\t80:         mpath.get(Buffer, o);","\t83:         mpath.get('string', o);","\t86:         mpath.get([], o);","\t93:         assert.equal('jiro', mpath.get('name', o));","\t97:           , mpath.get('first', o)","\t102:           , mpath.get('first.second', o)","\t107:           , mpath.get('first.second.third', o)","\t112:           , mpath.get('first.second.third.0', o)","\t117:           , mpath.get('first.second.third.2', o)","\t122:           , mpath.get('first.second.third.1', o)","\t127:           , mpath.get('first.second.third.1.name', o)","\t136:           mpath.get('comments', o));","\t138:         assert.deepEqual({ name: 'one' }, mpath.get('comments.0', o));","\t139:         assert.deepEqual('one', mpath.get('comments.0.name', o));","\t140:         assert.deepEqual('two', mpath.get('comments.1.name', o));","\t141:         assert.deepEqual('three', mpath.get('comments.2.name', o));","\t144:             , mpath.get('comments.2.comments', o));","\t147:             , mpath.get('comments.2.comments.1', o));","\t149:         assert.deepEqual('twoo', mpath.get('comments.2.comments.1.comments.0.val', o));","\t157:           , mpath.get('comments.name', o)","\t165:           , mpath.get('comments.comments', o)","\t173:           , mpath.get('first.second.third.name', o)","\t177:           , mpath.get('first.second.third.name', o, function (v) {","\t194:           , mpath.get('array.o.array', o)","\t209:           , mpath.get('array.o.array.0', o)","\t224:           , mpath.get('array.o.array.0.x', o)","\t239:           , mpath.get('array.o.array.y', o)","\t250:           , mpath.get('array.o.array.x', o)","\t265:           , mpath.get('array.o.array.x.b', o)","\t280:           , mpath.get('array.o.array.x.b.1', o)","\t291:           , mpath.get('array.o.array.x.b.1', o, function (v) {","\t301:           , mpath.get('array.1.o.array', o)","\t305:           , mpath.get('array.1.o.array', o, function (v) {","\t320:           , mpath.get('arr.arr.1', o)","\t324:           , mpath.get('arr.arr.1', o, function (v) {","\t335:           , mpath.get('arr.arr.1.a', o, function (v) {","\t342:           , mpath.get('arr.arr.1.a', o)","\t344:         mpath.set('arr.arr.1.a', [{c:49},undefined], o)","\t347:           , mpath.get('arr.arr.1.a', o)","\t349:         mpath.set('arr.arr.1.a', [{c:48},undefined], o)","\t356:           , mpath.get('arr.arr.1.a.c', o)","\t360:           , mpath.get('arr.arr.1.a.c', o, function (v) {","\t372:         assert.equal('jiro', mpath.get('name', o, special));","\t376:           , mpath.get('first', o, special)","\t381:           , mpath.get('first.second', o, special)","\t386:           , mpath.get('first.second.third', o, special)","\t391:           , mpath.get('first.second.third.0', o, special)","\t396:           , mpath.get('first.second.third.0', o, special, function (v) {","\t403:           , mpath.get('first.second.third.2', o, special)","\t408:           , mpath.get('first.second.third.1', o, special)","\t413:           , mpath.get('first.second.third.1.name', o, special)","\t422:           mpath.get('comments', o, special));","\t424:         assert.deepEqual({ name: 'one' }, mpath.get('comments.0', o, special));","\t425:         assert.deepEqual('one', mpath.get('comments.0.name', o, special));","\t426:         assert.deepEqual('2', mpath.get('comments.1.name', o, special));","\t427:         assert.deepEqual('3', mpath.get('comments.2.name', o, special));","\t428:         assert.deepEqual('nice', mpath.get('comments.2.name', o, special, function (v) {","\t433:             , mpath.get('comments.2.comments', o, special));","\t436:             , mpath.get('comments.2.comments.1', o, special));","\t438:         assert.deepEqual(2, mpath.get('comments.2.comments.1.comments.0.val', o, special));","\t445:           , mpath.get('comments.name', o, special)","\t449:           , mpath.get('comments.name', o, special, function (v) {","\t459:           , mpath.get('comments.comments', o, special)","\t467:           , mpath.get('comments.comments.1.comments', o, special)","\t475:           , mpath.get('comments.comments.1.comments.val', o, special)","\t479:           , mpath.get('comments.comments.1.comments.val', o, special, function (v) {","\t494:         mpath.set('name', 'a new val', o, function (v) {","\t499:         mpath.set('name', 'changed', o);","\t502:         mpath.set('first.second.third', [1,{name:'x'},9], o);","\t505:         mpath.set('first.second.third.1.name', 'y', o)","\t508:         mpath.set('comments.1.name', 'ttwwoo', o);","\t511:         mpath.set('comments.2.comments.1.comments.0.expand', 'added', o);","\t516:         mpath.set('comments.2.comments.1.comments.2', 'added', o);","\t531:       describe('array.path', function(){","\t534:             mpath.set('arr.yep', false, o, function (v) {","\t542:             mpath.set('arr.yep', false, o);","\t554:             mpath.set('arr.yep', ['one',2], o, function (v) {","\t561:             mpath.set('arr.yep', ['one',2], o);","\t572:             mpath.set('arr.yep', [47], o, function (v) {","\t580:             mpath.set('arr.yep', [47], o);","\t590:             mpath.set('arr.yep', [5,6,7], o, function (v) {","\t598:             mpath.set('arr.yep', [5,6,7], o);","\t609:       describe('array.$.path', function(){","\t612:             mpath.set('arr.$.yep', {xtra: 'double good'}, o, function (v) {","\t620:             mpath.set('arr.$.yep', {xtra: 'double good'}, o);","\t631:             mpath.set('arr.$.yep', [15], o, function (v) {","\t639:             mpath.set('arr.$.yep', [15], o);","\t650:       describe('array.index.path', function(){","\t652:           mpath.set('arr.1.yep', 0, o, function (v) {","\t660:           mpath.set('arr.1.yep', 0, o);","\t670:       describe('array.index.array.path', function(){","\t672:           mpath.set('arr.0.arr.e', 35, o, function (v) {","\t680:           mpath.set('arr.0.arr.e', 35, o);","\t689:           mpath.set('arr.0.arr.e', ['a','b'], o, function (v) {","\t697:           mpath.set('arr.0.arr.e', ['a','b'], o);","\t707:       describe('array.index.array.path.path', function(){","\t709:           mpath.set('arr.0.arr.a.b', 36, o, function (v) {","\t717:           mpath.set('arr.0.arr.a.b', 36, o);","\t726:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o, function (v) {","\t734:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o);","\t744:       describe('array.index.array.$.path.path', function(){","\t746:           mpath.set('arr.0.arr.$.a.b', '$', o, function (v) {","\t754:           mpath.set('arr.0.arr.$.a.b', '$', o);","\t763:           mpath.set('arr.0.arr.$.a.b', [1], o, function (v) {","\t771:           mpath.set('arr.0.arr.$.a.b', [1], o);","\t781:       describe('array.array.index.path', function(){","\t783:           mpath.set('arr.arr.0.a', 'single', o, function (v) {","\t791:           mpath.set('arr.arr.0.a', 'single', o);","\t800:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o, function (v) {","\t808:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o);","\t818:       describe('array.array.$.index.path', function(){","\t820:           mpath.set('arr.arr.$.0.a', 'singles', o, function (v) {","\t828:           mpath.set('arr.arr.$.0.a', 'singles', o);","\t834:           mpath.set('$.arr.arr.0.a', 'single', o);","\t843:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o, function (v) {","\t851:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o);","\t857:           mpath.set('arr.$.arr.0.a', [4,8,15,16,23,42,108], o);","\t867:       describe('array.array.path.index', function(){","\t869:           mpath.set('arr.arr.a.7', 47, o, function (v) {","\t877:           mpath.set('arr.arr.a.7', 47, o);","\t887:           mpath.set('arr.arr.a.7', [[null,46], [undefined, 'woot']], o);","\t903:       describe('handles array.array.path', function(){","\t916:           mpath.set('arr.arr.e', 47, o, function (v) {","\t936:           mpath.set('arr.arr.e', 47, o);","\t955:           mpath.set('arr.arr.e', [[1,2,3],[4,5],null,[],[6], [7,8,9]], o, function (v) {","\t977:           mpath.set('arr.arr.e', [[1,2,3],[4,5],null,[],[6], [7,8,9]], o);","\t1005:         mpath.set('name', 'chan', o, special, function (v) {","\t1010:         mpath.set('name', 'changer', o, special);","\t1013:         mpath.set('first.second.third', [1,{name:'y'},9], o, special);","\t1016:         mpath.set('first.second.third.1.name', 'z', o, special)","\t1019:         mpath.set('comments.1.name', 'ttwwoo', o, special);","\t1022:         mpath.set('comments.2.comments.1.comments.0.expander', 'adder', o, special, function (v) {","\t1029:         mpath.set('comments.2.comments.1.comments.0.expander', 'adder', o, special);","\t1034:         mpath.set('comments.2.comments.1.comments.2', 'set', o, special);","\t1048:       describe('array.path', function(){","\t1053:             mpath.set('arr.yep', false, o, special, function (v) {","\t1061:             mpath.set('arr.yep', false, o, special);","\t1072:             mpath.set('arr.yep', ['one',2], o, special, function (v) {","\t1080:             mpath.set('arr.yep', ['one',2], o, special);","\t1090:             mpath.set('arr.yep', [47], o, special, function (v) {","\t1098:             mpath.set('arr.yep', [47], o, special);","\t1107:             mpath.set('arr.yep', [20], o, special);","\t1117:             mpath.set('arr.yep', [5,6,7], o, special, function () {","\t1125:             mpath.set('arr.yep', [5,6,7], o, special);","\t1136:       describe('array.$.path', function(){","\t1139:             mpath.set('arr.$.yep', {xtra: 'double good'}, o, special, function (v) {","\t1148:             mpath.set('arr.$.yep', {xtra: 'double good'}, o, special);","\t1160:             mpath.set('arr.$.yep', [15], o, special, function (v) {","\t1169:             mpath.set('arr.$.yep', [15], o, special);","\t1181:       describe('array.index.path', function(){","\t1183:           mpath.set('arr.1.yep', 0, o, special, function (v) {","\t1192:           mpath.set('arr.1.yep', 0, o, special);","\t1203:       describe('array.index.array.path', function(){","\t1205:           mpath.set('arr.0.arr.e', 35, o, special, function (v) {","\t1214:           mpath.set('arr.0.arr.e', 35, o, special);","\t1224:           mpath.set('arr.0.arr.e', ['a','b'], o, special, function (v) {","\t1233:           mpath.set('arr.0.arr.e', ['a','b'], o, special);","\t1244:       describe('array.index.array.path.path', function(){","\t1246:           mpath.set('arr.0.arr.a.b', 36, o, special, function (v) {","\t1255:           mpath.set('arr.0.arr.a.b', 36, o, special);","\t1265:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o, special, function (v) {","\t1274:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o, special);","\t1285:       describe('array.index.array.$.path.path', function(){","\t1287:           mpath.set('arr.0.arr.$.a.b', '$', o, special, function (v) {","\t1296:           mpath.set('arr.0.arr.$.a.b', '$', o, special);","\t1306:           mpath.set('arr.0.arr.$.a.b', [1], o, special, function (v) {","\t1315:           mpath.set('arr.0.arr.$.a.b', [1], o, special);","\t1326:       describe('array.array.index.path', function(){","\t1328:           mpath.set('arr.arr.0.a', 'single', o, special, function (v) {","\t1337:           mpath.set('arr.arr.0.a', 'single', o, special);","\t1347:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o, special, function (v) {","\t1356:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o, special);","\t1367:       describe('array.array.$.index.path', function(){","\t1369:           mpath.set('arr.arr.$.0.a', 'singles', o, special, function (v) {","\t1378:           mpath.set('arr.arr.$.0.a', 'singles', o, special);","\t1385:           mpath.set('$.arr.arr.0.a', 'single', o, special);","\t1395:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o, special, function (v) {","\t1404:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o, special);","\t1411:           mpath.set('arr.$.arr.0.a', [4,8,15,16,23,42,108], o, special);","\t1422:       describe('array.array.path.index', function(){","\t1424:           mpath.set('arr.arr.a.7', 47, o, special, function (v) {","\t1433:           mpath.set('arr.arr.a.7', 47, o, special);","\t1444:           mpath.set('arr.arr.a.7', [[null,46], [undefined, 'woot']], o, special, function (v) {","\t1459:           mpath.set('arr.arr.a.7', [[null,46], [undefined, 'woot']], o, special);","\t1473:       describe('handles array.array.path', function(){","\t1483:           mpath.set('arr.arr.e', 47, o, special);","\t1519:           mpath.set('arr.arr.e', [[1,2,3],[4,5],null,[],[6], [7,8,9]], o, special);","\t1562:         var vals = mpath.get('array.o.array.x.b', o);","\t1570:         mpath.set('array.o.array.x.b', vals, o);","\t1586:         mpath.set('comments.name', ['this', 'was', 'changed'], o);","\t1596:         mpath.set('comments.name', ['also', 'changed', 'this'], o, special);","\t1615:           mpath.set('arr.$.arr.$.a', 35, o);","\t1621:     it('ignores setting a nested path that doesnt exist', function(done){","\t1624:         mpath.set('thing.that.is.new', 10, o);","",""]},{"start":{"row":1876,"column":0},"end":{"row":1877,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mquery/README.md:",""]},{"start":{"row":1877,"column":0},"end":{"row":1886,"column":0},"action":"insert","lines":["\t180: All paths passed that are not `$atomic` operations will become `$set` ops. For example:","\t405: Specifies the complementary comparison value for the path specified with `where()`.","\t499: query.where('path').intersects().geometry({","\t505: query.where('path').intersects({","\t655: When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.","\t721: Specifies a `$slice` projection for a `path`","\t757: Specifies a `path` for use with chaining","\t884: If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.","",""]},{"start":{"row":1886,"column":0},"end":{"row":1887,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mquery/lib/mquery.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":1887,"column":0},"end":{"row":2002,"column":0},"action":"insert","lines":["\t50:   this._path = proto._path || undefined;","\t135:   p._path = this._path;","\t231:  * Specifies a `path` for use with chaining.","\t251:  * @param {String} [path]","\t264:     this._path = arguments[0];","\t267:       this._conditions[this._path] = arguments[1];","\t277:   throw new TypeError('path must be a string or object');","\t281:  * Specifies the complementary comparison value for paths specified with `where()`","\t297:   this._ensurePath('equals');","\t298:   var path = this._path;","\t299:   this._conditions[path] = val;","\t364:  * When called with one argument, the most recent path passed to `where()` is used.","\t375:  * @param {String} [path]","\t383:  * When called with one argument, the most recent path passed to `where()` is used.","\t387:  * @param {String} [path]","\t395:  * When called with one argument, the most recent path passed to `where()` is used.","\t399:  * @param {String} [path]","\t407:  * When called with one argument, the most recent path passed to `where()` is used.","\t411:  * @param {String} [path]","\t419:  * When called with one argument, the most recent path passed to `where()` is used.","\t423:  * @param {String} [path]","\t431:  * When called with one argument, the most recent path passed to `where()` is used.","\t435:  * @param {String} [path]","\t443:  * When called with one argument, the most recent path passed to `where()` is used.","\t447:  * @param {String} [path]","\t455:  * When called with one argument, the most recent path passed to `where()` is used.","\t459:  * @param {String} [path]","\t467:  * When called with one argument, the most recent path passed to `where()` is used.","\t471:  * @param {String} [path]","\t479:  * When called with one argument, the most recent path passed to `where()` is used.","\t483:  * @param {String} [path]","\t491:  * When called with one argument, the most recent path passed to `where()` is used.","\t495:  * @param {String} [path]","\t508:     var path, val;","\t511:       this._ensurePath($conditional);","\t513:       path = this._path;","\t516:       path = arguments[0];","\t519:     var conds = this._conditions[path] || (this._conditions[path] = {});","\t528:  * @param {String} [path]","\t535:   var val, path;","\t538:     this._ensurePath('mod')","\t540:     path = this._path;","\t542:     this._ensurePath('mod')","\t544:     path = this._path;","\t547:     path = arguments[0];","\t550:     path = arguments[0];","\t553:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t572:  * @param {String} [path]","\t579:   var path, val;","\t582:     this._ensurePath('exists');","\t583:     path = this._path;","\t587:       this._ensurePath('exists');","\t588:       path = this._path;","\t591:       path = arguments[0];","\t595:     path = arguments[0];","\t599:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t623:  * @param {String|Object|Function} path","\t633:   var fn, path, criteria;","\t636:     this._ensurePath('elemMatch');","\t637:     path = this._path;","\t640:     this._ensurePath('elemMatch');","\t641:     path = this._path;","\t644:     path = arguments[0];","\t647:     path = arguments[0];","\t659:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t694:   this._ensurePath('within');","\t740:  * @param {String} path","\t747:   var path, box;","\t751:     path = arguments[0];","\t755:     this._ensurePath('box');","\t756:     path = this._path;","\t762:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t775:  * @param {String|Array} [path]","\t783:   var val, path;","\t787:     path = arguments[0];","\t791:     this._ensurePath('polygon');","\t792:     path = this._path;","\t796:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t815:  * @param {String} [path]","\t823:   var path, val;","\t826:     this._ensurePath('circle');","\t827:     path = this._path;","\t830:     path = arguments[0];","\t839:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t869:  * @param {String} [path]","\t877:   var path, val;","\t884:     this._ensurePath('near');","\t885:     path = this._path;","\t888:     path = arguments[0];","\t898:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t936:  *     query.where('path').intersects().geometry({","\t941:  *     query.where('path').intersects({","\t953:   this._ensurePath('intersects');","\t996:  * The most recent path passed to `where()` is used.","\t1014:   var val, path;","\t1017:     this._ensurePath('geometry');","\t1018:     path = this._path;","\t1028:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t1041:  * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.","\t1102:  * Specifies a $slice condition for a `path`","\t1112:  * @param {String} [path]","\t1125:   var path, val;","\t1128:     this._ensurePath('slice');","\t1129:     path = this._path;","\t1133:       this._ensurePath('slice');","\t1134:       path = this._path;","\t1137:       path = arguments[0];","\t1141:     path = arguments[0];","\t1146:   myFields[path] = { '$slice': val };","\t1155:  * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.","\t1798:  * _All paths passed that are not $atomic operations will become $set ops._","\t2381:  * Make sure _path is set.","\t2386: Query.prototype._ensurePath = function (method) {","\t2387:   if (!this._path) {","",""]},{"start":{"row":2002,"column":0},"end":{"row":2012,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/mquery/test/index.js:","\t61:       var path = 'street';","\t67:       q.where(path);","\t78:       assert.equal(path, m._path);","\t143:       }, /path must be a string or object/);","\t160:         assert.equal('name', m._path);","\t167:       assert.equal('name', m._path);","\t186:     it('sets value of path set with where()', function(){","\t287:       it('uses previously set `where` path if 1 arg passed', function(){","",""]},{"start":{"row":2012,"column":0},"end":{"row":2025,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/ms/test/support/jquery.js:","\t1665: \t\t\t// the code to shortcut on the same path as a DOM node with no cache","\t3047: \t\t\tcache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;","\t3117: \t\t// Determine event propagation path in advance, per W3C events spec (#9951)","\t3119: \t\teventPath = [[ elem, special.bindType || type ]];","\t3126: \t\t\t\teventPath.push([ cur, bubbleType ]);","\t3132: \t\t\t\teventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);","\t3136: \t\t// Fire handlers on the event path","\t3137: \t\tfor ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {","\t3139: \t\t\tcur = eventPath[i][0];","\t3140: \t\t\tevent.type = eventPath[i][1];","\t6667: \t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...","",""]},{"start":{"row":2025,"column":0},"end":{"row":2029,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/node_modules/mongoose/node_modules/muri/lib/index.js:","\t44:   var path = match[2];","\t75:   var parts = path.split('?');","",""]},{"start":{"row":2029,"column":0},"end":{"row":2034,"column":0},"action":"insert","lines":["/node_modules/acute-data-mongodb/tests/testMongoDb.js:","\t2:     path = require('path'),","\t9:         var configPath = path.join(__dirname, \"testconfig.js\");","\t10:         var config = architect.loadConfig(configPath);","",""]},{"start":{"row":2034,"column":0},"end":{"row":2039,"column":0},"action":"insert","lines":["/node_modules/acute-express-app/tests/testApp.js:","\t2:     path = require('path'),","\t9:         var configPath = path.join(__dirname, \"testconfig.js\");","\t10:         var config = architect.loadConfig(configPath);","",""]},{"start":{"row":2039,"column":0},"end":{"row":2042,"column":0},"action":"insert","lines":["/node_modules/acute-express-app/tests/testconfig.js:","\t7:         packagePath: \"../\",","",""]},{"start":{"row":2042,"column":0},"end":{"row":2046,"column":0},"action":"insert","lines":["/node_modules/acute-express-controllers/package.json:","\t36:     \"path\": \"*\"","","/node_modules/acute-express-controllers/lib/index.js:",""]},{"start":{"row":2046,"column":0},"end":{"row":2066,"column":0},"action":"insert","lines":["\t5:  * can be overridden by exporting a \"mountPath\" option from the controller.","\t9:     path = require('path'),","\t16: var DEFAULT_MOUNTPATH = \"/\";","\t18: var add = function(mountPath, router, fn) {","\t19:   console.log(\"loading router at \", mountPath);","\t21:     if (!mountPath) {","\t22:       mountPath = DEFAULT_MOUNTPATH;","\t24:     app.app.use(mountPath, router);","\t37:   console.log(\"path = \", path.join(basedir, dirname));","\t38:     acuteUtils.walkFs(path.join(basedir, dirname), function(err, files) {","\t47:             if (_.isUndefined(controller.mountPath)) {","\t48:               var relPath = path.relative(path.join(basedir, dirname), file);","\t49:               var p = relPath.split(path.sep);","\t52:                 controller.mountPath = path.sep + p.join(path.sep);","\t54:                 controller.mountPath = DEFAULT_MOUNTPATH;","\t57:             add(controller.mountPath, controller.routes, function(err) {","","/node_modules/acute-express-controllers/tests/testconfig.js:","\t3:         packagePath: \"../\",","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2066,"column":0},"end":{"row":2072,"column":0},"action":"insert","lines":["/node_modules/acute-express-controllers/tests/testControllers.js:","\t2:     path = require('path'),","\t9:         var configPath = path.join(__dirname, \"testconfig.js\");","\t10:         var config = architect.loadConfig(configPath);","","/node_modules/acute-express-controllers/tests/test_controllers/index.js:",""]},{"start":{"row":2072,"column":0},"end":{"row":2074,"column":0},"action":"insert","lines":["\t26:       // mountPath: \"/\"","",""]},{"start":{"row":2074,"column":0},"end":{"row":2077,"column":0},"action":"insert","lines":["/node_modules/acute-express-controllers/tests/test_controllers/index2.js:","\t26:       // mountPath: \"/\"","",""]},{"start":{"row":2077,"column":0},"end":{"row":2083,"column":0},"action":"insert","lines":["/node_modules/acute-express-controllers/tests/test_controllers/controller_folder/controller_in_subfolder.js:","\t26:       // mountPath: \"/\"","","/node_modules/acute-express-data/package.json:","\t35:     \"path\": \"*\",","",""]},{"start":{"row":2083,"column":0},"end":{"row":2086,"column":0},"action":"insert","lines":["/node_modules/acute-express-data/node_modules/util/test/node/debug.js:","\t49:   var child = spawn(process.execPath, [__filename, 'child'], {","",""]},{"start":{"row":2086,"column":0},"end":{"row":2089,"column":0},"action":"insert","lines":["/node_modules/acute-express-data/tests/testconfig.js:","\t3:         packagePath: \"../\",","",""]},{"start":{"row":2089,"column":0},"end":{"row":2094,"column":0},"action":"insert","lines":["/node_modules/acute-express-data/tests/testData.js:","\t2:     path = require('path'),","\t9:         var configPath = path.join(__dirname, \"testconfig.js\");","\t10:         var config = architect.loadConfig(configPath);","",""]},{"start":{"row":2094,"column":0},"end":{"row":2127,"column":0},"action":"insert","lines":["/node_modules/acute-express-utils/package.json:","\t35:     \"path\": \"*\",","","/node_modules/acute-express-utils/lib/index.js:","\t9:     path = require('path');","\t38:   var path = require('path');","\t41:       var base = path.basename(dir);","\t64:     fn(err.path);","\t70:  * using the path components.","\t75: var pathsToFileTree = function(files, basedir, fn) {","\t79:     var relativePath = path.relative(basedir, file);","\t80:     // var base = path.dirname(file);","\t81:     var pathComponents = relativePath.split(path.sep);","\t82:     // to reverse this, call pathComponents.join(path.sep);","\t84:     // console.log(\"pathComponents = \", pathComponents);","\t85:     tree.push(pathComponents);","\t97:  * Converts path components in an array to a path.","\t98:  * @param pathComponents the array that describes the file path.","\t99:  * @param fn a callback with the signature (path)","\t101: var urlFromPathComponents = function(pathComponents, basedir, fn) {","\t103:   pathComponents.pop();","\t104:   fn(\"/\" + pathComponents.join(\"/\"));","\t106:     // This snippet of code can search through a relative path to get the directory","\t107:     // structure and separate them out into separate path components","\t108:     // var relativePath = path.relative(baseDir, file);","\t109:     // var pathComponents = relativePath.split(path.sep);","\t110:     // // console.log(\"path components\", pathComponents);","\t111:     // if (pathComponents.length > 1) {","\t112:     //   async.reduce(pathComponents, returnFile, function(memo, item, callback){","\t121:     //       result[pathComponents[-1]] = file;","\t141:       pathsToFileTree: pathsToFileTree,","\t142:       urlFromPathComponents: urlFromPathComponents","",""]},{"start":{"row":2127,"column":0},"end":{"row":2145,"column":0},"action":"insert","lines":["/node_modules/acute-express-utils/node_modules/findit/index.js:","\t3: var path = require('path');","\t26:         emitter.emit('path', fdir, dstat);","\t47:             if (!err.path) err.path = dir;","\t60:                     if (!err.path) err.path = dir;","\t64:                 var file_ = path.resolve(dir, rfile);","\t75:             emitter.emit('path', fdir, stat);","\t83:             emitter.emit('path', fdir, stat);","\t95:             emitter.emit('path', fdir, stat);","\t115:             if (!err.path) err.path = dir;","\t121:             var file = path.join(fdir, rfile);","\t129:                     if (!err.path) err.path = file;","\t154:                     if (!err.path) err.path = file;","\t158:                 var file_ = path.resolve(path.dirname(file), rfile);","\t166:                         if (!err.path) err.path = file_;","\t178:             emitter.emit('path', file, stat);","\t183:             emitter.emit('path', file, stat);","",""]},{"start":{"row":2145,"column":0},"end":{"row":2156,"column":0},"action":"insert","lines":["/node_modules/acute-express-utils/node_modules/findit/readme.markdown:","\t11: var path = require('path');","\t14:     var base = path.basename(dir);","\t61: ## finder.on('path', function (file, stat) {})","\t71: For each directory, this event fires with the path `dir`.","\t98: You can always get the source of the error by checking `err.path`.","","/node_modules/acute-express-utils/node_modules/findit/example/emitter.js:","\t2: var path = require('path');","\t5:     var base = path.basename(dir);","",""]},{"start":{"row":2156,"column":0},"end":{"row":2160,"column":0},"action":"insert","lines":["/node_modules/acute-express-utils/node_modules/findit/test/err.js:","\t3: var path = require('path');","\t10:         t.equal(err.path, __dirname + '/does/not/exist');","",""]},{"start":{"row":2160,"column":0},"end":{"row":2167,"column":0},"action":"insert","lines":["/node_modules/acute-express-utils/node_modules/findit/test/foo.js:","\t8:     var paths = []","\t9:     finder.on('path', function (p, stat) {","\t10:         paths.push(p);","\t37:         var count = { dirs : 0, files : 0, paths : 0 };","\t54:         t.deepEqual(paths.sort(), Object.keys(ps).sort());","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2167,"column":0},"end":{"row":2171,"column":0},"action":"insert","lines":["/node_modules/acute-express-utils/node_modules/findit/test/stop.js:","\t3: var path = require('path');","","/node_modules/acute-express-utils/node_modules/findit/test/symlinks.js:",""]},{"start":{"row":2171,"column":0},"end":{"row":2177,"column":0},"action":"insert","lines":["\t2: var path = require('path');","\t15:         symlinks.push(path.basename(link));","\t20:         files.push(path.basename(file));","\t25:         dirs.push(path.basename(dir));","\t65:             data.errors[0].path, __dirname","",""]},{"start":{"row":2177,"column":0},"end":{"row":2180,"column":0},"action":"insert","lines":["/node_modules/acute-express-utils/node_modules/util/test/node/debug.js:","\t49:   var child = spawn(process.execPath, [__filename, 'child'], {","",""]},{"start":{"row":2180,"column":0},"end":{"row":2194,"column":0},"action":"insert","lines":["/node_modules/acute-express-utils/tests/testUtils.js:","\t2:     path = require('path'),","\t9:         var configPath = path.join(__dirname, \"testconfig.js\");","\t10:         var config = architect.loadConfig(configPath);","\t26:             app.services.utils.walkFs(path.join(__dirname, \"testdir\"), function(err, file) {","\t38:     describe(\"#pathsToFileTree\", function() {","\t41:             app.services.utils.walkFs(path.join(__dirname, \"testdir\"), function(err, fileArray) {","\t45:                     app.services.utils.pathsToFileTree(fileArray, path.join(__dirname, \"testdir\"), function(err, fileTree) {","\t58:     describe(\"#urlFromPathComponents\", function() {","\t59:         it(\"should create a url from path components\", function(done) {","\t61:             app.services.utils.walkFs(path.join(__dirname, \"testdir\"), function(err, fileArray) {","\t66:                     app.services.utils.pathsToFileTree(fileArray, path.join(__dirname, \"testdir\"), function(err, fileTree) {","\t73:                                 app.services.utils.urlFromPathComponents(item, \"/\", function(route) {","",""]},{"start":{"row":2194,"column":0},"end":{"row":2202,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/package.json:","\t36:     \"path\": \"*\"","","/node_modules/acute-mongoose-models/lib/index.js:","\t9:     path = require('path'),","\t25:           path = require('path');","\t54:     acuteUtils.walkFs(path.join(basedir, dirname), function(err, files) {","",""]},{"start":{"row":2202,"column":0},"end":{"row":2203,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/History.md:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2203,"column":0},"end":{"row":2265,"column":0},"action":"insert","lines":["\t5:  * added; dynamic refpaths #2640 [chetvernikov](https://github.com/chetvernikov)","\t14:  * fixed; array saved as object when path is object in array #2442","\t33:  * added; can explicitly exclude paths from versioning #2576 [csabapalfi](https://github.com/csabapalfi)","\t107:  * added; ability to set single populated paths to documents #1530","\t136:  * fixed; properly remove modified array paths if array has been overwritten #1638","\t190:  * fixed; custom getter might cause mongoose to mistakenly think a path is dirty #2100 [pgherveou](https://github.com/pgherveou)","\t235:  * updated; added get / set to reserved path list #1903 [tstrimple](https://github.com/tstrimple)","\t337:  * fixed; repopulating modified populated paths #1697","\t414:  * fixed; repopulating modified populated paths #1697","\t535:  * fixed; repopulating modified populated paths #1697","\t677:   * fixed; strict:throw edge case using .set(path, val)","\t678:   * fixed; schema.pathType() on some numbericAlpha paths","\t679:   * fixed; numbericAlpha path versioning","\t680:   * fixed; setting nested mixed paths #1418","\t725:   * fixed; use of `setMaxListeners` as path","\t757:   * added; doc#populated(path) stores original populated _ids","\t762:   * added; support for rich nested path population","\t775:   * fixed; setting populated paths #570","\t787:   * fixed; add EventEmitter props to reserved paths #1338","\t791:   * fixed; specifying schema type edge case { path: [{type: \"String\" }] }","\t797:   * updated; mpath to 0.1.1","\t840:   * fixed; setting populated paths #570","\t852:   * fixed; add EventEmitter props to reserved paths #1338","\t871:   * fixed; specifying schema type edge case { path: [{type: \"String\" }] }","\t877:   * added; doc#populated(path) stores original populated _ids","\t882:   * added; support for rich nested path population","\t890:   * updated; mpath to 0.1.1","\t979:   * fixed; add EventEmitter props to reserved paths #1338","\t1009:   * changed; \"_pres\" & \"_posts\" are now reserved pathnames #1261","\t1031:   * fixed; regression when using subdoc with `path` as pathname #1245 [daeq](https://github.com/daeq)","\t1042:   * added; paths to CastErrors #1239","\t1083:   * changed; adding invalid nested paths to non-objects throws 4216f14","\t1188:   * fixed; use of nested paths beginning w/ numbers #1062","\t1202:   * fixed; compat with non-schema path props using positional notation (#1048)","\t1227:   * fixed; allow subdoc literal declarations containing \"type\" pathname (#993)","\t1230:   * fixed; allow use of `options` as a pathname (#529)","\t1231:   * fixed; `model` is again a permitted schema path name","\t1250:   * fixed; provide helpful error msgs when reserved schema path is used (#928)","\t1276:   * changed; doc#modifiedPaths is now a method (#950)","\t1292:   * fixed; setting invalid paths in strict mode (#916)","\t1299:   * fixed; subdoc paths reported in validation errors (#725)","\t1306:   * fixed; set/updating nested objects by parent pathname (#843)","\t1318:   * added; inclusion of deselected schema path (#786)","\t1372:   * fixed; edge case when using 'options' as a path name (#961)","\t1378:   * fixed; selection of _id w/ another excluded path (#954)","\t1393:   * fixed; setting invalid paths in strict mode (#916)","\t1435:   * fixed; doc.isSelected(otherpath) when only _id is selected (#730)","\t1441:   * fixed; failing validation of unselected required paths (#730,#713)","\t1469:   * added; default path selection to SchemaTypes","\t1508:   * added; doc#isSelected(path)","\t1512:   * added; document.modifiedPaths (#709) [ljharb]","\t1566:   * fixed; bug in 2.4.6 with path setting","\t1611:   * added; $unset is now used when setting a path to undefined (#519)","\t1638:   * fixed; model.update casting for nested paths works (#542)","\t1782:   * fixed; reset modified paths and atomics after saved (#459)","\t1934:   * fixed; 'path' is now a valid Schema pathname","\t1938:   * fixed; modifying subdoc property sets modified paths for subdoc and parent doc","\t1939:   * fixed; marking subdoc path as modified properly persists the value to the db","\t2041:   * Fixed; no longer using $set on paths to an unexisting fields","\t2112:   * Only doValidate when path exists in Schema [aheckmann]","\t2226:   * Fixed; it's now possible to instantiate a model even when one of the paths maps","",""]},{"start":{"row":2265,"column":0},"end":{"row":2268,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/package.json:","\t31:     \"mpath\": \"0.1.1\",","",""]},{"start":{"row":2268,"column":0},"end":{"row":2274,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/README.md:","\t104: Comment.path('name').set(function (v) {","\t219: For example, this would allow you to broadcast changes about your Documents every time someone `set`s a path in your Document to a new value:","\t222: schema.pre('set', function (next, path, val, typel) {","\t224:   this.emit('set', path, val);","",""]},{"start":{"row":2274,"column":0},"end":{"row":2277,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/examples/population/population-across-three-collections.js:","\t113:           path: 'author.friends',","",""]},{"start":{"row":2277,"column":0},"end":{"row":2280,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/examples/population/population-of-multiple-existing-docs.js:","\t88:     var options = { path: 'consoles', select: 'name released -_id' };","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2280,"column":0},"end":{"row":2283,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/examples/population/population-options.js:","\t93:       path: 'consoles'","",""]},{"start":{"row":2283,"column":0},"end":{"row":2287,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/examples/schema/schema.js:","\t46: BlogPost.path('date')","\t88:     schema.path(key).set(function(v){","",""]},{"start":{"row":2287,"column":0},"end":{"row":2290,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/aggregate.js:","\t280:  * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.","",""]},{"start":{"row":2290,"column":0},"end":{"row":2291,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/browserDocument.js:",""]},{"start":{"row":2291,"column":0},"end":{"row":2319,"column":0},"action":"insert","lines":["\t30:  * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data","\t80:   var required = this.schema.requiredPaths();","\t82:     this.$__.activePaths.require(required[i]);","","/node_modules/acute-mongoose-models/node_modules/mongoose/lib/cast.js:","\t18:   var paths = Object.keys(obj)","\t19:     , i = paths.length","\t23:     , path","\t28:     path = paths[i];","\t29:     val = obj[path];","\t31:     if ('$or' === path || '$nor' === path || '$and' === path) {","\t39:     } else if (path === '$where') {","\t47:         obj[path] = val.toString();","\t59:       schematype = schema.path(path);","\t63:         var split = path.split('.')","\t65:           , pathFirstHalf","\t66:           , pathLastHalf","\t70:         // Find the part of the var path that is a path of the Schema","\t72:           pathFirstHalf = split.slice(0, j).join('.');","\t73:           schematype = schema.path(pathFirstHalf);","\t77:         // If a substring of the input path resolves to an actual real path...","\t82:             pathLastHalf = split.slice(j).join('.');","\t83:             remainingConds[pathLastHalf] = val;","\t84:             obj[path] = cast(schematype.caster.schema, remainingConds)[pathLastHalf];","\t86:             obj[path] = val;","\t169:           obj[path] = schematype.castForQuery(val);","\t202:         obj[path] = schematype.castForQuery(val);","",""]},{"start":{"row":2319,"column":0},"end":{"row":2322,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/connection.js:","\t8:   , driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native'","",""]},{"start":{"row":2322,"column":0},"end":{"row":2323,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/document.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2323,"column":0},"end":{"row":2598,"column":0},"action":"insert","lines":["\t29:  * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data","\t53:   var required = schema.requiredPaths();","\t55:     this.$__.activePaths.require(required[i]);","\t171:   var paths = Object.keys(this.schema.paths)","\t172:     , plen = paths.length","\t176:     var p = paths[ii];","\t183:     var type = this.schema.paths[p]","\t184:       , path = p.split('.')","\t185:       , len = path.length","\t187:       , curPath = ''","\t192:       var piece = path[i]","\t197:         curPath += piece;","\t198:         if (curPath in fields) break;","\t199:         curPath += '.';","\t211:               self.$__.activePaths.default(p);","\t219:               self.$__.activePaths.default(p);","\t226:             self.$__.activePaths.default(p);","\t259:   // handle docs with populated paths","\t265:       this.populated(item.path, item._docs[id], item);","\t292:     , path","\t297:     path = prefix + i;","\t298:     schema = self.schema.path(path);","\t304:       init(self, obj[i], doc[i], path + '.');","\t313:             self.invalidate(e.path, new ValidatorError({","\t314:               path: e.path,","\t325:       if (!self.isModified(path)) {","\t326:         self.$__.activePaths.init(path);","\t350:     , paths = Object.keys(key)","\t351:     , len = paths.length","\t355:     val = this.getValue(paths[i]);","\t357:       orig[paths[i]] = val.toObject({ depopulate: true })","\t362:       orig[paths[i]] = val.valueOf();","\t364:       orig[paths[i]] = val;","\t403:  * Sets the value of a path, or many paths.","\t407:  *     // path, value","\t408:  *     doc.set(path, value)","\t412:  *         path  : value","\t413:  *       , path2 : {","\t414:  *            path  : value","\t419:  *     doc.set(path, value, Number)","\t422:  *     doc.set(path, value, String)","\t425:  *     doc.set(path, value, { strict: false });","\t427:  * @param {String|Object} path path or object of key/vals to set","\t434: Document.prototype.set = function (path, val, type, options) {","\t450:     adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});","\t451:     adhocs[path] = Schema.interpretAsType(path, type);","\t454:   if ('string' !== typeof path) {","\t457:     if (null === path || undefined === path) {","\t458:       var _ = path;","\t459:       path = val;","\t467:       if (path instanceof Document) path = path._doc;","\t469:       var keys = Object.keys(path)","\t471:         , pathtype","\t476:         pathtype = this.schema.pathType(prefix + key);","\t477:         if (null != path[key]","\t479:             && utils.isObject(path[key])","\t480:             && (!path[key].constructor || 'Object' == utils.getFunctionName(path[key].constructor))","\t481:             && 'virtual' != pathtype","\t482:             && !(this.$__path(prefix + key) instanceof MixedSchema)","\t483:             && !(this.schema.paths[key] && this.schema.paths[key].options.ref)","\t485:           this.set(path[key], prefix + key, constructing);","\t487:           if ('real' === pathtype || 'virtual' === pathtype) {","\t488:             this.set(prefix + key, path[key], constructing);","\t492:         } else if (undefined !== path[key]) {","\t493:           this.set(prefix + key, path[key], constructing);","\t502:   // docschema = new Schema({ path: { nest: 'string' }})","\t503:   // doc.set('path', obj);","\t504:   var pathType = this.schema.pathType(path);","\t505:   if ('nested' == pathType && val && utils.isObject(val) &&","\t507:     if (!merge) this.setValue(path, null);","\t508:     this.set(val, path, constructing);","\t513:   var parts = path.split('.');","\t515:   if ('adhocOrUndefined' == pathType && strict) {","\t521:       var subpath = parts.slice(0, i+1).join('.');","\t522:       schema = this.schema.path(subpath);","\t524:         // allow changes to sub paths of mixed types","\t532:         throw new Error(\"Field `\" + path + \"` is not in schema.\");","\t537:   } else if ('virtual' == pathType) {","\t538:     schema = this.schema.virtualpath(path);","\t542:     schema = this.$__path(path);","\t545:   var pathToMark;","\t547:   // When using the $set operator the path to the field must already exist.","\t551:     pathToMark = path;","\t554:       var subpath = parts.slice(0, i+1).join('.');","\t555:       if (this.isDirectModified(subpath) // earlier prefixes that are already","\t557:           || this.get(subpath) === null) {","\t558:         pathToMark = subpath;","\t563:     if (!pathToMark) pathToMark = path;","\t569:     : this.getValue(path);","\t572:     this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);","\t579:     // If the user is trying to set a ref path to a document with","\t585:       this.populated(path, val);","\t589:     this.invalidate(e.path, new ValidatorError({","\t590:       path: e.path,","\t599:     this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);","\t615:     pathToMark, path, constructing, parts, schema, val, priorVal) {","\t619:   if (undefined === val && !this.isSelected(path)) {","\t620:     // when a path is not selected in a query, its initial","\t625:   if (undefined === val && path in this.$__.activePaths.states.default) {","\t630:   if (!deepEqual(val, priorVal || this.get(path))) {","\t636:       path in this.$__.activePaths.states.default &&","\t638:     // a path with a default was $unset on the server","\t646:  * Handles the actual setting of the value and marking the path modified if appropriate.","\t654:     pathToMark, path, constructing, parts, schema, val, priorVal) {","\t661:     this.markModified(pathToMark, val);","\t669:       // paths that were modified before the array overwrite","\t670:       this.$__.activePaths.forEach(function(modifiedPath) {","\t671:         if (modifiedPath.indexOf(path + '.') === 0) {","\t672:           _this.$__.activePaths.ignore(modifiedPath);","\t703:  * Gets a raw value from a path (no getters)","\t705:  * @param {String} path","\t709: Document.prototype.getValue = function (path) {","\t710:   return utils.getValue(path, this._doc);","\t714:  * Sets a raw value for a path (no casting, setters, transformations)","\t716:  * @param {String} path","\t721: Document.prototype.setValue = function (path, val) {","\t722:   utils.setValue(path, val, this._doc);","\t727:  * Returns the value of a path.","\t731:  *     // path","\t737:  * @param {String} path","\t742: Document.prototype.get = function (path, type) {","\t745:     adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});","\t746:     adhocs[path] = Schema.interpretAsType(path, type);","\t749:   var schema = this.$__path(path) || this.schema.virtualpath(path)","\t750:     , pieces = path.split('.')","\t767:  * Returns the schematype for the given `path`.","\t769:  * @param {String} path","\t771:  * @method $__path","\t775: Document.prototype.$__path = function (path) {","\t776:   var adhocs = this.$__.adhocPaths","\t777:     , adhocType = adhocs && adhocs[path];","\t782:     return this.schema.path(path);","\t787:  * Marks the path as having pending changes to write to the db.","\t797:  * @param {String} path the path to mark modified","\t801: Document.prototype.markModified = function (path) {","\t802:   this.$__.activePaths.modify(path);","\t806:  * Returns the list of paths that have been modified.","\t812: Document.prototype.modifiedPaths = function () {","\t813:   var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);","\t815:   return directModifiedPaths.reduce(function (list, path) {","\t816:     var parts = path.split('.');","\t826:  * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.","\t836:  * @param {String} [path] optional","\t841: Document.prototype.isModified = function (path) {","\t842:   return path","\t843:     ? !!~this.modifiedPaths().indexOf(path)","\t844:     : this.$__.activePaths.some('modify');","\t848:  * Returns true if `path` was directly set and modified, else false.","\t856:  * @param {String} path","\t861: Document.prototype.isDirectModified = function (path) {","\t862:   return (path in this.$__.activePaths.states.modify);","\t866:  * Checks if `path` was initialized.","\t868:  * @param {String} path","\t873: Document.prototype.isInit = function (path) {","\t874:   return (path in this.$__.activePaths.states.init);","\t878:  * Checks if `path` was selected in the source query which initialized this document.","\t887:  * @param {String} path","\t892: Document.prototype.isSelected = function isSelected (path) {","\t895:     if ('_id' === path) {","\t899:     var paths = Object.keys(this.$__.selected)","\t900:       , i = paths.length","\t904:     if (1 === i && '_id' === paths[0]) {","\t910:       cur = paths[i];","\t916:     if (path in this.$__.selected) {","\t920:     i = paths.length;","\t921:     var pathDot = path + '.';","\t924:       cur = paths[i];","\t927:       if (0 === cur.indexOf(pathDot)) {","\t931:       if (0 === pathDot.indexOf(cur + '.')) {","\t972:   var paths = Object.keys(this.$__.activePaths.states.require).filter(function (path) {","\t973:     if (!self.isSelected(path) && !self.isModified(path)) return false;","\t977:   paths = paths.concat(Object.keys(this.$__.activePaths.states.init));","\t978:   paths = paths.concat(Object.keys(this.$__.activePaths.states.modify));","\t979:   paths = paths.concat(Object.keys(this.$__.activePaths.states.default));","\t981:   if (0 === paths.length) {","\t993:   for (var i = 0; i < paths.length; ++i) {","\t994:     var path = paths[i];","\t995:     var val = self.getValue(path);","\t1000:         paths.push(path + '.' + j);","\t1004:   paths.forEach(validatePath);","\t1007:   function validatePath (path) {","\t1008:     if (validating[path]) return;","\t1010:     validating[path] = true;","\t1014:       var p = self.schema.path(path);","\t1017:       var val = self.getValue(path);","\t1020:           self.invalidate(path, err, undefined, true);","\t1063:   var paths = Object.keys(this.$__.activePaths.states.require).filter(function (path) {","\t1064:     if (!self.isSelected(path) && !self.isModified(path)) return false;","\t1068:   paths = paths.concat(Object.keys(this.$__.activePaths.states.init));","\t1069:   paths = paths.concat(Object.keys(this.$__.activePaths.states.modify));","\t1070:   paths = paths.concat(Object.keys(this.$__.activePaths.states.default));","\t1074:   paths.forEach(function (path) {","\t1075:     if (validating[path]) return;","\t1077:     validating[path] = true;","\t1079:     var p = self.schema.path(path);","\t1082:     var val = self.getValue(path);","\t1085:       self.invalidate(path, err, undefined, true);","\t1097:  * Marks a path as invalid, causing validation to fail.","\t1114:  *               path: 'size',","\t1119:  * @param {String} path the field to invalidate","\t1120:  * @param {String|Error} errorMsg the error which states the reason `path` was invalid","\t1125: Document.prototype.invalidate = function (path, err, val) {","\t1130:   if (this.$__.validationError.errors[path]) return;","\t1134:       path: path,","\t1143:   this.$__.validationError.errors[path] = err;","\t1159:   this.$__.activePaths","\t1184:   this.$__.activePaths.clear('modify');","\t1188:   this.schema.requiredPaths().forEach(function (path) {","\t1189:     self.$__.activePaths.require(path);","\t1196:  * Returns this documents dirty paths / vals.","\t1206:   var all = this.$__.activePaths.map('modify', function (path) {","\t1207:     return { path: path","\t1208:            , value: self.getValue(path)","\t1209:            , schema: self.$__path(path) };","\t1212:   // Sort dirty paths in a flat hierarchy.","\t1214:     return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));","\t1219:     , lastPath","\t1223:     if (item.path.indexOf(lastPath) !== 0) {","\t1224:       lastPath = item.path + '.';","\t1230:         // the `top` array itself and a sub path of `top` are being modified.","\t1239:   top = lastPath = null;","\t1288:     , path = (prefix ? prefix + '.' : '') + prop;","\t1299:           if (!this.$__.getters[path]) {","\t1321:               return this.get(path);","\t1324:             compile(subprops, nested, path);","\t1325:             this.$__.getters[path] = nested;","\t1328:           return this.$__.getters[path];","\t1332:           return (this.$__.scope || this).set(path, v);","\t1340:       , get: function ( ) { return this.get.call(this.$__.scope || this, path); }","\t1341:       , set: function (v) { return this.set.call(this.$__.scope || this, path, v); }","\t1362:  * Get active path that were changed and are arrays","\t1365:  * @method $__getArrayPathsToValidate","\t1369: Document.prototype.$__getArrayPathsToValidate = function () {","\t1373:   return this.$__.activePaths","\t1398:   function docReducer(seed, path) {","\t1399:     var val = this[path];","\t1429:   var docs = this.$__getArrayPathsToValidate();","\t1549:  * - `getters` apply all getters (path and virtual getters)","\t1553:  * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)","\t1557:  * Example of only applying path getters","\t1565:  * Example of applying both path and virtual getters","\t1667:     // populated paths that we set to a document","\t1703:     applyGetters(this, ret, 'paths', options);","\t1704:     // applyGetters for paths will add nested empty objects;","\t1778:  * @param {String} type either `virtuals` or `paths`","\t1784:     , paths = Object.keys(schema[type])","\t1785:     , i = paths.length","\t1786:     , path","\t1789:     path = paths[i];","\t1791:     var parts = path.split('.')","\t1800:         branch[part] = clone(self.get(path), options);","\t1897:  *       path: 'notes',","\t1907:  *     doc.populate(path)               // not executed","\t1909:  *     doc.populate(path, callback)     // executed","\t1918:  * Passing the same path a second time will overwrite the previous path options.","\t1922:  * @param {String|Object} [path] The path to populate or an options object","\t1941:     // use hash to remove duplicate paths","\t1944:       pop[res[i].path] = res[i];","\t1949:     var paths = utils.object.vals(pop);","\t1951:     this.constructor.populate(this, paths, fn);","\t1966:  *         path: 'notes',","\t1981:  * Passing the same path a second time will overwrite the previous path options.","\t2003:  * Gets _id(s) used during population of the given `path`.","\t2012:  * If the path was not populated, undefined is returned.","\t2014:  * @param {String} path","\t2019: Document.prototype.populated = function (path, val, options) {","\t2024:     var v = this.$__.populated[path];","\t2033:     return this.$__.populated[path];","\t2037:   this.$__.populated[path] = { value: val, options: options };","\t2042:  * Returns the full path to this document.","\t2044:  * @param {String} [path]","\t2047:  * @method $__fullPath","\t2051: Document.prototype.$__fullPath = function (path) {","\t2053:   return path || '';","",""]},{"start":{"row":2598,"column":0},"end":{"row":2606,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/index.js:","\t480: var driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';","","/node_modules/acute-mongoose-models/node_modules/mongoose/lib/internal.js:","\t16:   this.adhocPaths = undefined;","\t26:   this.activePaths = new ActiveRoster;","\t30:   this.fullPath = undefined;","",""]},{"start":{"row":2606,"column":0},"end":{"row":2607,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/model.js:",""]},{"start":{"row":2607,"column":0},"end":{"row":2679,"column":0},"action":"insert","lines":["\t298:   delta[op][data.path] = val;","\t303:   // path excluded from versioning?","\t305:   if (skipVersioning && skipVersioning[data.path]) return;","\t342:   else if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {","\t343:     // subpath of array","\t359:   if (delta.$set && delta.$set[data.path]) {","\t441:     var match = checkDivergentArray(this, data.path, value);","\t455:     } else if (value._path && value._atomics) {","\t459:     } else if (value._path && Buffer.isBuffer(value)) {","\t487:  * @param {String} path","\t491: function checkDivergentArray (doc, path, array) {","\t492:   // see if we populated this path","\t493:   var pop = doc.populated(path, true);","\t498:     var top = path.split('.')[0];","\t526:       return path;","\t601:   var paths","\t605:     paths = Object.keys(this.$__.shardval)","\t606:     len = paths.length","\t609:       where[paths[i]] = this.$__.shardval[paths[i]];","\t731:   if (schema.path(key)) {","\t772:     schema._requiredpaths = undefined; // reset just in case Schema#requiredPaths() was called on either schema","\t1225:  * @param {String} path","\t1231: Model.where = function where (path, val) {","\t1641:  * The document returned has no paths marked as modified initially.","\t2094:  * - path: space delimited path(s) to populate","\t2105:  *           { path: 'company', match: { x: 1 }, select: 'name' }","\t2106:  *         , { path: 'notes', options: { limit: 10 }, model: 'override' }","\t2116:  *       var opts = [{ path: 'company', match: { x: 1 }, select: 'name' }]","\t2127:  *     Weapon.populate(user, { path: 'weapon', model: 'Weapon' }, function (err, user) {","\t2134:  *     Weapon.populate(users, { path: 'weapon' }, function (err, users) {","\t2145:  * @param {Object} options A hash of key/val (path, options) used for population.","\t2151: Model.populate = function (docs, paths, cb) {","\t2162:   // normalized paths","\t2163:   var paths = utils.populate(paths);","\t2164:   var pending = paths.length;","\t2171:   // each path has its own query options and must be executed separately","\t2173:   var path;","\t2176:     path = paths[i];","\t2177:     if ('function' === typeof path.model) model = path.model;","\t2178:     populate(model, docs, path, next);","\t2197:   var schema = model._getSchema(options.path),","\t2244:       path: options.path,","\t2310:     refPath = schema && schema.options && schema.options.refPath,","\t2313:   if (refPath) {","\t2316:       modelNames = utils.getValue(refPath, doc);","\t2374:     i, j, doc, docs, id, len, len2, ret, isDocument, populated, options, path;","\t2381:     path = options.path;","\t2390:         ret = utils.getValue(path, doc);","\t2404:         doc.populated(path, options._docs[id], options);","\t2436:  * to the original document path.","\t2449:   var path = o.path;","\t2454:     utils.setValue(path, rawIds[i], docs[i], function (val) {","\t2563:  *   if the value of the path is not an array, use findOne rules, else find.","\t2564:  *   for findOne the results are assigned directly to doc path (including null results).","\t2637:  * Finds the schema for `path`. This is different than","\t2638:  * calling `schema.path` as it also resolves paths with","\t2639:  * positional selectors (something.$.another.$.path).","\t2641:  * @param {String} path","\t2646: Model._getSchema = function _getSchema (path) {","\t2648:     , pathschema = schema.path(path);","\t2650:   if (pathschema)","\t2651:     return pathschema;","\t2657:       , trypath","\t2660:       trypath = parts.slice(0, p).join('.');","\t2661:       foundschema = schema.path(trypath);","\t2671:           // are remaining document paths to look up for casting.","\t2672:           // Also we need to handle array.$.path since schema.path","\t2675:           // a path like array.$","\t2681:               // this is the last path of the selector","\t2689:   })(path.split('.'), schema)","\t2705:   if (versioningEnabled && !schema.paths[schema.options.versionKey]) {","",""]},{"start":{"row":2679,"column":0},"end":{"row":2772,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/query.js:","\t161:   p._path = this._path;","\t199:  * Specifies a `path` for use with chaining.","\t221:  * @param {String|Object} [path]","\t228:  * Specifies the complementary comparison value for paths specified with `where()`","\t293:  * When called with one argument, the most recent path passed to `where()` is used.","\t304:  * @param {String} [path]","\t313:  * When called with one argument, the most recent path passed to `where()` is used.","\t317:  * @param {String} [path]","\t326:  * When called with one argument, the most recent path passed to `where()` is used.","\t330:  * @param {String} [path]","\t339:  * When called with one argument, the most recent path passed to `where()` is used.","\t344:  * @param {String} [path]","\t352:  * When called with one argument, the most recent path passed to `where()` is used.","\t357:  * @param {String} [path]","\t365:  * When called with one argument, the most recent path passed to `where()` is used.","\t370:  * @param {String} [path]","\t378:  * When called with one argument, the most recent path passed to `where()` is used.","\t383:  * @param {String} [path]","\t391:  * When called with one argument, the most recent path passed to `where()` is used.","\t396:  * @param {String} [path]","\t404:  * When called with one argument, the most recent path passed to `where()` is used.","\t418:  * @param {String} [path]","\t426:  * When called with one argument, the most recent path passed to `where()` is used.","\t431:  * @param {String} [path]","\t439:  * When called with one argument, the most recent path passed to `where()` is used.","\t444:  * @param {String} [path]","\t454:  * @param {String} [path]","\t477:  * @param {String} [path]","\t505:  * @param {String|Object|Function} path","\t517:  *     query.where(path).within().box()","\t518:  *     query.where(path).within().circle()","\t519:  *     query.where(path).within().geometry()","\t563:  * @param {String} [path]","\t702:  * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](/docs/api.html#schematype_SchemaType-select).","\t718:  *     query.select('+path')","\t886:  * Makes sure _path is set.","\t888:  * @method _ensurePath","\t1017:   this._applyPaths();","\t1066:  * @param {Array} [pop] array of paths used in population","\t1176:   this._applyPaths();","\t1340:  * If a string is passed, it must be a space delimited list of path names. The","\t1341:  * sort order of each path is ascending unless the path name is prefixed with `-`","\t1447:  * @param {Array} [pop] array of paths used in population","\t1623:   this._applyPaths();","\t1720:  * _All paths passed that are not $atomic operations will become $set ops._","\t1935:  * Finds the schema for `path`. This is different than","\t1936:  * calling `schema.path` as it also resolves paths with","\t1937:  * positional selectors (something.$.another.$.path).","\t1939:  * @param {String} path","\t1943: Query.prototype._getSchema = function _getSchema (path) {","\t1944:   return this.model._getSchema(path);","\t1961:  * of their path schema type.","\t2024:       hasKeys |= this._walkUpdatePath(val, op);","\t2030:       // Also, _walkUpdatePath expects an operation, so give it $set since that","\t2032:       this._walkUpdatePath(ret.$set || {}, '$set');","\t2044:  * Walk each path of obj and cast its values","\t2049:  * @param {String} pref - path prefix (internal only)","\t2050:  * @return {Bool} true if this path has keys to update","\t2054: Query.prototype._walkUpdatePath = function _walkUpdatePath (obj, op, pref) {","\t2078:           // path is not in our strict schema","\t2082:             // ignore paths not specified in schema","\t2115:         hasKeys |= this._walkUpdatePath(val, op, prefix + key) ||","\t2125:                  !/real|nested/.test(this.model.schema.pathType(prefix + key));","\t2154:     // non-existing schema path","\t2216:  * Specifies paths which should be populated with other documents.","\t2225:  *         path: 'owner'","\t2238:  * Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.","\t2240:  * @param {Object|String} path either the path to populate or an object specifying all parameters","\t2261:     opts.populate[res[i].path] = res[i];","\t2345: Query.prototype._applyPaths = function applyPaths () {","\t2371:   var analyzePath = function(path, type) {","\t2374:     var plusPath = '+' + path;","\t2375:     if (fields && plusPath in fields) {","\t2377:       delete fields[plusPath];","\t2381:       if (false === exclude && keys.length > 1 && !~keys.indexOf(path)) {","\t2382:         fields[path] = 1;","\t2389:     var root = path.split('.')[0];","\t2392:     ;(type.selected ? selected : excluded).push(path);","\t2402:     schema.eachPath(function (path, type) {","\t2403:       if (prefix) path = prefix + '.' + path;","\t2405:       analyzePath(path, type);","\t2409:         analyzeSchema(type.schema, path);","\t2470:   this._applyPaths();","\t2527:  *     query.where('path').intersects().geometry({","\t2532:  *     query.where('path').intersects({","\t2573:  * The argument is assigned to the most recent path passed to `where()`.","\t2607:  * @param {String} [path]","\t2637:       // just passing a path","\t2713:  * @param {String|Array} [path]","\t2777:  * @param {String} [path]","\t2811:  * @param {String} [path]","",""]},{"start":{"row":2772,"column":0},"end":{"row":2777,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/queryhelpers.js:","\t9:  * Prepare a set of path options for query population.","\t26:  * Prepare a set of path options for query population. This is the MongooseQuery","\t70:  * Set each path query option to lean","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2777,"column":0},"end":{"row":2874,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema.js:","\t63:   this.paths = {};","\t64:   this.subpaths = {};","\t73:   this._requiredpaths = undefined;","\t75:   this._indexedpaths = undefined;","\t84:   // build paths","\t93:   var auto_id = !this.paths['_id'] && (!this.options.noId && this.options._id) && !_idSubDoc;","\t100:   var autoid = !this.paths['id'] && (!this.options.noVirtualId && this.options.id);","\t114:     if (!this.paths[createdAt]) {","\t160:  * Schema as flat paths","\t169:  * @property paths","\t172: Schema.prototype.paths;","\t236:  * Adds key path / schema type pairs to this schema.","\t256:       throw new TypeError('Invalid value for schema path `'+ prefix + key +'`');","\t260:       throw new TypeError('Invalid value for schema Array path `'+ prefix + key +'`');","\t269:         this.path(prefix + key, obj[key]); // mixed type","\t272:       this.path(prefix + key, obj[key]);","\t310:  * Gets/sets schema paths.","\t312:  * Sets a path (if arity 2)","\t313:  * Gets a path (if arity 1)","\t317:  *     schema.path('name') // returns a SchemaType","\t318:  *     schema.path('name', Number) // changes the schemaType of `name` to Number","\t320:  * @param {String} path","\t325: Schema.prototype.path = function (path, obj) {","\t327:     if (this.paths[path]) return this.paths[path];","\t328:     if (this.subpaths[path]) return this.subpaths[path];","\t330:     // subpaths?","\t331:     return /\\.\\d+\\.?.*$/.test(path)","\t332:       ? getPositionalPath(this, path)","\t336:   // some path names conflict with document methods","\t337:   if (reserved[path]) {","\t338:     throw new Error(\"`\" + path + \"` may not be used as a schema pathname\");","\t342:   var subpaths = path.split(/\\./)","\t343:     , last = subpaths.pop()","\t346:   subpaths.forEach(function(sub, i) {","\t349:       var msg = 'Cannot set nested path `' + path + '`. '","\t350:               + 'Parent path `'","\t351:               + subpaths.slice(0, i).concat([sub]).join('.')","\t361:   this.paths[path] = Schema.interpretAsType(path, obj);","\t368:  * @param {String} path","\t373: Schema.interpretAsType = function (path, obj) {","\t389:     return new MongooseTypes.Mixed(path, obj);","\t399:       return new MongooseTypes.DocumentArray(path, cast, obj);","\t407:       return new MongooseTypes.DocumentArray(path, new Schema(cast), obj);","\t410:     return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj);","\t429:     throw new TypeError('Undefined type `' + name + '` at `' + path +","\t434:   return new MongooseTypes[name](path, obj);","\t438:  * Iterates the schemas paths similar to Array#forEach.","\t440:  * The callback is passed the pathname and schemaType as arguments on each iteration.","\t447: Schema.prototype.eachPath = function (fn) {","\t448:   var keys = Object.keys(this.paths)","\t452:     fn(keys[i], this.paths[keys[i]]);","\t459:  * Returns an Array of path strings that are required by this schema.","\t465: Schema.prototype.requiredPaths = function requiredPaths () {","\t466:   if (this._requiredpaths) return this._requiredpaths;","\t468:   var paths = Object.keys(this.paths)","\t469:     , i = paths.length","\t473:     var path = paths[i];","\t474:     if (this.paths[path].isRequired) ret.push(path);","\t477:   return this._requiredpaths = ret;","\t487: Schema.prototype.indexedPaths = function indexedPaths () {","\t488:   if (this._indexedpaths) return this._indexedpaths;","\t490:   return this._indexedpaths = this.indexes();","\t494:  * Returns the pathType of `path` for this schema.","\t496:  * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.","\t498:  * @param {String} path","\t503: Schema.prototype.pathType = function (path) {","\t504:   if (path in this.paths) return 'real';","\t505:   if (path in this.virtuals) return 'virtual';","\t506:   if (path in this.nested) return 'nested';","\t507:   if (path in this.subpaths) return 'real';","\t509:   if (/\\.\\d+\\.|\\.\\d+$/.test(path) && getPositionalPath(this, path)) {","\t520: function getPositionalPath (self, path) {","\t521:   var subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);","\t522:   if (subpaths.length < 2) {","\t523:     return self.paths[subpaths[0]];","\t526:   var val = self.path(subpaths[0]);","\t529:   var last = subpaths.length - 1","\t530:     , subpath","\t533:   for (; i < subpaths.length; ++i) {","\t534:     subpath = subpaths[i];","\t536:     if (i === last && val && !val.schema && !/\\D/.test(subpath)) {","\t546:     // ignore if its just a position segment: path.0.subpath","\t547:     if (!/\\D/.test(subpath)) continue;","\t554:     val = val.schema.path(subpath);","\t557:   return self.subpaths[path] = val;","\t827:     var key, path, index, field, isObject, options, type;","\t828:     var keys = Object.keys(schema.paths);","\t832:       path = schema.paths[key];","\t834:       if (path instanceof MongooseTypes.DocumentArray) {","\t835:         collectIndexes(path.schema, key + '.');","\t837:         index = path._index;","\t864:       fixSubIndexPaths(schema, prefix);","\t879:    * These indexes need their paths prefixed properly.","\t884:   function fixSubIndexPaths (schema, prefix) {","\t938: Schema.prototype.virtualpath = function (name) {","",""]},{"start":{"row":2874,"column":0},"end":{"row":2875,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schematype.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2875,"column":0},"end":{"row":2915,"column":0},"action":"insert","lines":["\t14:  * @param {String} path","\t20: function SchemaType (path, options, instance) {","\t21:   this.path = path;","\t64:  *     schema.path('mixed').default(function () {","\t72:  *     schema.path('mixed').default({});","\t107:  *     Schema.path('my.path').index(true);","\t108:  *     Schema.path('my.date').index({ expires: 60 });","\t109:  *     Schema.path('my.path').index({ unique: true, sparse: true });","\t134:  *     Schema.path('name').index({ unique: true });","\t160:  *      Schema.path('name').index({text : true});","\t183:  *     Schema.path('name').index({ sparse: true });","\t216:  *     s.path('name').set(capitalize)","\t252:  *         return schematype.path + ' is required';","\t296:  *     s.path('born').get(dob)","\t320:  *         return schematype.path + ' is required';","\t322:  *         return schematype.path + ' is not';","\t351:  * Adds validator(s) for this document path.","\t367:  *     var custom = [validator, 'Uh oh, {PATH} does not equal \"something\".']","\t381:  *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');","\t385:  * From the examples above, you may have noticed that error messages support baseic templating. There are a few other template keywords besides `{PATH}` and `{VALUE}` too. To find out more, details are available [here](#error_messages_MongooseError-messages)","\t391:  *     schema.path('name').validate(function (value, respond) {","\t396: *      }, '{PATH} failed validation.');","\t469:  *     var s = new Schema({ born: { type: Date, required: '{PATH} is required!' })","\t471:  *     // or through the path API","\t473:  *     Schema.path('name').required(true);","\t477:  *     Schema.path('name').required(true, 'grrr :( ');","\t502:     // no validation when this path wasn't selected in the query.","\t504:         !this.isSelected(self.path) &&","\t505:         !this.isModified(self.path)) return true;","\t612:  * Sets default `select()` behavior for this path.","\t614:  * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.","\t644:     , path = this.path","\t666:     validatorProperties.path = path;","\t702:     , path = this.path","\t724:     validatorProperties.path = path;","\t752:   // fast path","\t755:   if (!ref && doc && doc.$__fullPath) {","\t759:     var path = doc.$__fullPath(self.path);","\t761:     ref = owner.populated(path);","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2915,"column":0},"end":{"row":2947,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/statemachine.js:","\t16:   this.paths = {};","\t26:  * place their path argument into the given state.","\t53:     // Changes the `path`'s state to `state`.","\t54:     ctor.prototype[state] = function (path) {","\t55:       this._changeState(path, state);","\t65:  * - `require(path)`","\t66:  * - `modify(path)`","\t67:  * - `init(path)`","\t72: StateMachine.prototype._changeState = function _changeState (path, nextState) {","\t73:   var prevBucket = this.states[this.paths[path]];","\t74:   if (prevBucket) delete prevBucket[path];","\t76:   this.paths[path] = nextState;","\t77:   this.states[nextState][path] = true;","\t87:     , path","\t90:     path = keys[i];","\t91:     delete this.states[state][path];","\t92:     delete this.paths[path];","\t97:  * Checks to see if at least one path is in the states passed in via `arguments`","\t131:     var paths = states.reduce(function (paths, state) {","\t132:       return paths.concat(Object.keys(self.states[state]));","\t135:     return paths[iterMethod](function (path, i, paths) {","\t136:       return callback(path, i, paths);","\t142:  * Iterates over the paths that belong to one of the parameter states.","\t145:  * this.forEach(state1, fn);         // iterates over all paths in state1","\t146:  * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2","\t147:  * this.forEach(fn);                 // iterates over all paths in all states","\t161:  * Maps over the paths that belong to one of the parameter states.","\t164:  * this.forEach(state1, fn);         // iterates over all paths in state1","\t165:  * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2","\t166:  * this.forEach(fn);                 // iterates over all paths in all states","",""]},{"start":{"row":2947,"column":0},"end":{"row":2948,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/utils.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":2948,"column":0},"end":{"row":2976,"column":0},"action":"insert","lines":["\t9:   , mpath = require('mpath')","\t505: function PopulateOptions (path, select, match, options, model) {","\t506:   this.path = path;","\t524: exports.populate = function populate (path, select, model, match, options) {","\t531:     if (path instanceof PopulateOptions) {","\t532:       return [path];","\t535:     if (Array.isArray(path)) {","\t536:       return path.map(function(o){","\t541:     if (exports.isObject(path)) {","\t542:       match = path.match;","\t543:       options = path.options;","\t544:       select = path.select;","\t545:       model = path.model;","\t546:       path = path.path;","\t554:   if ('string' != typeof path) {","\t555:     throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');","\t559:   var paths = path.split(' ');","\t560:   for (var i = 0; i < paths.length; ++i) {","\t561:     ret.push(new PopulateOptions(paths[i], select, match, options, model));","\t568:  * Return the value of `obj` at the given `path`.","\t570:  * @param {String} path","\t574: exports.getValue = function (path, obj, map) {","\t575:   return mpath.get(path, obj, '_doc', map);","\t579:  * Sets the value of `obj` at the given `path`.","\t581:  * @param {String} path","\t586: exports.setValue = function (path, val, obj, map) {","\t587:   mpath.set(path, val, obj, '_doc', map);","",""]},{"start":{"row":2976,"column":0},"end":{"row":2977,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/virtualtype.js:",""]},{"start":{"row":2977,"column":0},"end":{"row":2979,"column":0},"action":"insert","lines":["\t17:   this.path = name;","",""]},{"start":{"row":2979,"column":0},"end":{"row":2984,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/error/cast.js:","\t16: function CastError (type, value, path) {","\t17:   MongooseError.call(this, 'Cast to ' + type + ' failed for value \"' + value + '\" at path \"' + path + '\"');","\t22:   this.path = path;","",""]},{"start":{"row":2984,"column":0},"end":{"row":3003,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/error/divergentArray.js:","\t14: function DivergentArrayError (paths) {","\t20:           + 'path(s) would have been modified unsafely:\\n'","\t21:           + '  ' + paths.join('\\n  ') + '\\n'","","/node_modules/acute-mongoose-models/node_modules/mongoose/lib/error/messages.js:","\t7:  *     mongoose.Error.messages.String.enum  = \"Your custom message for {PATH}.\";","\t11:  * - `{PATH}` is replaced with the invalid document path","\t27: msg.general.default = \"Validator failed for path `{PATH}` with value `{VALUE}`\";","\t28: msg.general.required = \"Path `{PATH}` is required.\";","\t31: msg.Number.min = \"Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).\";","\t32: msg.Number.max = \"Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).\";","\t35: msg.Date.min = \"Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).\";","\t36: msg.Date.max = \"Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).\";","\t39: msg.String.enum = \"`{VALUE}` is not a valid enum value for path `{PATH}`.\";","\t40: msg.String.match = \"Path `{PATH}` is invalid ({VALUE}).\";","\t41: msg.String.minlength = \"Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).\";","\t42: msg.String.maxlength = \"Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).\";","",""]},{"start":{"row":3003,"column":0},"end":{"row":3004,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/error/validator.js:",""]},{"start":{"row":3004,"column":0},"end":{"row":3006,"column":0},"action":"insert","lines":["\t28:   this.path = properties.path;","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3006,"column":0},"end":{"row":3018,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/array.js:","\t60:       this.caster.path = key;","\t77:     return new MongooseArray(arr, self.path, this);","\t136:       var indexes = doc.schema.indexedPaths();","\t139:         var pathIndex = indexes[i][0][this.path];","\t140:         if ('2dsphere' === pathIndex || '2d' === pathIndex) {","\t147:       value = new MongooseArray(value, this.path, doc);","\t157:         throw new CastError(e.type, value, this.path);","\t166:       doc.markModified(this.path);","\t317:       o[this.path] = v;","\t318:       return cast(this.casterConstructor.schema, o)[this.path];","",""]},{"start":{"row":3018,"column":0},"end":{"row":3023,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/boolean.js:","\t11:  * @param {String} path","\t17: function SchemaBoolean (path, options) {","\t18:   SchemaType.call(this, path, options);","",""]},{"start":{"row":3023,"column":0},"end":{"row":3034,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/buffer.js:","\t78:     // setting a populated path","\t82:       throw new CastError('buffer', value, this.path);","\t86:     // path to a plain object; cast to the Model used in","\t88:     var path = doc.$__fullPath(this.path);","\t90:     var pop = owner.populated(path, true);","\t107:       value = new MongooseBuffer(value, [this.path, doc]);","\t112:     var ret = new MongooseBuffer(value.value(true), [this.path, doc]);","\t123:     var ret = new MongooseBuffer(value, [this.path, doc]);","\t127:   throw new CastError('buffer', value, this.path);","",""]},{"start":{"row":3034,"column":0},"end":{"row":3042,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/date.js:","\t60:  *     schema.path('createdAt').expires('7d');","\t104:  *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];","\t109:  *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).","\t159:  *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];","\t164:  *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).","\t227:   throw new CastError('date', value, this.path);","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3042,"column":0},"end":{"row":3056,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/documentarray.js:","\t48:   var path = this.path;","\t54:     return new MongooseDocumentArray(arr, path, this);","\t167:     // the db and the path isn't an array in the document","\t169:       doc.markModified(this.path);","\t175:     value = new MongooseDocumentArray(value, this.path, doc);","\t188:         selected || (selected = scopePaths(this, doc.$__.selected, init));","\t215:  * Scopes paths selected in a query to this array.","\t218:  * @param {DocumentArray} array - the array to scope `fields` paths","\t223: function scopePaths (array, fields, init) {","\t226:   var path = array.path + '.'","\t235:     if (0 === key.indexOf(path)) {","\t237:       selected[key.substring(path.length)] = fields[key];","",""]},{"start":{"row":3056,"column":0},"end":{"row":3061,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/mixed.js:","\t12:  * @param {String} path","\t18: function Mixed (path, options) {","\t34:   SchemaType.call(this, path, options);","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3061,"column":0},"end":{"row":3073,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/number.js:","\t68:  *     var min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];","\t73:  *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).","\t121:  *     var max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];","\t126:  *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).","\t183:     // setting a populated path","\t187:       throw new CastError('number', value, this.path);","\t191:     // path to a plain object; cast to the Model used in","\t193:     var path = doc.$__fullPath(this.path);","\t195:     var pop = owner.populated(path, true);","\t217:   throw new CastError('number', value, this.path);","",""]},{"start":{"row":3073,"column":0},"end":{"row":3082,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/objectid.js:","\t93:     // setting a populated path","\t97:       throw new CastError('ObjectId', value, this.path);","\t101:     // path to a plain object; cast to the Model used in","\t103:     var path = doc.$__fullPath(this.path);","\t105:     var pop = owner.populated(path, true);","\t124:       throw new CastError('ObjectId', value, this.path);","\t128:   throw new CastError('ObjectId', value, this.path);","",""]},{"start":{"row":3082,"column":0},"end":{"row":3098,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/schema/string.js:","\t51:  *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.","\t59:  *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'","\t65:  *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`","\t200:  *     var minlength = [10, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum length ({MINLENGTH}).'];","\t205:  *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).","\t253:  *     var maxlength = [10, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];","\t258:  *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (10).","\t301:  *       console.error(String(err)) // \"ValidationError: Path `name` is invalid (I am invalid).\"","\t381:     // setting a populated path","\t385:       throw new CastError('string', value, this.path);","\t389:     // path to a plain object; cast to the Model used in","\t391:     var path = doc.$__fullPath(this.path);","\t393:     var pop = owner.populated(path, true);","\t415:   throw new CastError('string', value, this.path);","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3098,"column":0},"end":{"row":3119,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/services/updateValidators.js:","\t27:       var paths = Object.keys(castedDoc[keys[i]]);","\t28:       var numPaths = paths.length;","\t29:       for (var j = 0; j < numPaths; ++j) {","\t31:           updatedValues[paths[j]] = castedDoc[keys[i]][paths[j]];","\t33:           updatedValues[paths[j]] = undefined;","\t35:         updatedKeys[paths[j]] = true;","\t44:     paths = Object.keys(query._conditions);","\t45:     numPaths = keys.length;","\t46:     for (var i = 0; i < numPaths; ++i) {","\t47:       if (typeof query._conditions[paths[i]] === 'Object') {","\t48:         var conditionKeys = Object.keys(query._conditions[paths[i]]);","\t61:       updatedKeys[paths[i]] = true;","\t65:       schema.eachPath(function(path, schemaType) {","\t66:         if (path === '_id') {","\t71:         if (!updatedKeys[path] && typeof def !== 'undefined') {","\t73:           castedDoc.$setOnInsert[path] = def;","\t74:           updatedValues[path] = def;","\t87:         schema.path(updates[i]).doValidate(","\t107:           err.errors[validationErrors[i].path] = validationErrors[i];","",""]},{"start":{"row":3119,"column":0},"end":{"row":3137,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/types/array.js:","\t20:  * @param {String} path","\t27: function MongooseArray (values, path, doc) {","\t35:   arr._path = path;","\t39:     arr._schema = doc.schema.path(path);","\t88:       populated = owner.populated(this._path, true);","\t121:    * @param {String} embeddedPath the path which changed in the embeddedDoc","\t126:   _markModified: function (elem, embeddedPath) {","\t128:       , dirtyPath;","\t131:       dirtyPath = this._path;","\t134:         if (null != embeddedPath) {","\t136:           dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;","\t139:           dirtyPath = dirtyPath + '.' + elem;","\t142:       parent.markModified(dirtyPath);","\t176:     // $atomic op on a single path","\t461:       , cur = this._parent.get(this._path)","","/node_modules/acute-mongoose-models/node_modules/mongoose/lib/types/buffer.js:",""]},{"start":{"row":3137,"column":0},"end":{"row":3151,"column":0},"action":"insert","lines":["\t6: var driver = global.MONGOOSE_DRIVER_PATH || '../drivers/node-mongodb-native';","\t39:   var path;","\t44:     path = encode[0];","\t57:     , _path: { value: path }","\t61:   if (doc && \"string\" === typeof path) {","\t63:         value: doc.schema.path(path)","\t108:       parent.markModified(this._path);","","/node_modules/acute-mongoose-models/node_modules/mongoose/lib/types/documentarray.js:","\t16:  * @param {String} path the path to this array","\t24: function MongooseDocumentArray (values, path, doc) {","\t35:   arr._path = path;","\t39:     arr._schema = doc.schema.path(path);","",""]},{"start":{"row":3151,"column":0},"end":{"row":3177,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/types/embedded.js:","\t51:  * @param {String} path the path which changed","\t55: EmbeddedDocument.prototype.markModified = function (path) {","\t58:   this.$__.activePaths.modify(path);","\t65:     this.__parentArray._markModified(this, path);","\t157:  * Marks a path as invalid, causing validation to fail.","\t159:  * @param {String} path the field to invalidate","\t160:  * @param {String|Error} err error which states the reason `path` was invalid","\t165: EmbeddedDocument.prototype.invalidate = function (path, err, val, first) {","\t172:   var parentPath = this.__parentArray._path;","\t173:   var fullPath = [parentPath, index, path].join('.');","\t179:     this.__parent.invalidate(fullPath, err, val);","\t181:     this.__parent.invalidate(fullPath, err);","\t211:  * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.","\t213:  * @param {String} [path]","\t216:  * @method $__fullPath","\t220: EmbeddedDocument.prototype.$__fullPath = function (path) {","\t221:   if (!this.$__.fullPath) {","\t223:     if (!parent.__parent) return path;","\t225:     var paths = [];","\t227:       paths.unshift(parent.__parentArray._path);","\t231:     this.$__.fullPath = paths.join('.');","\t239:   return path","\t240:     ? this.$__.fullPath + '.' + path","\t241:     : this.$__.fullPath;","",""]},{"start":{"row":3177,"column":0},"end":{"row":3180,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/lib/types/objectid.js:","\t6: var driver = global.MONGOOSE_DRIVER_PATH || '../drivers/node-mongodb-native';","",""]},{"start":{"row":3180,"column":0},"end":{"row":3187,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/hooks-fixed/README.md:","\t30:   , Document = require('./path/to/some/document/constructor');","\t63:   , Document = require('./path/to/some/document/constructor');","\t122: Document.hook('set', function (path, val) {","\t123:   this[path] = val;","\t132: Document.pre('set', function (next, path, val) {","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3187,"column":0},"end":{"row":3230,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/hooks-fixed/test.js:","\t329:     A.hook('set', function (path, val) {","\t330:       this[path] = val;","\t332:     A.pre('set', function (next, path, val) {","\t333:       path.should.equal('hello');","\t345: //    A.hook('set', function (path, val) {","\t346: //      this[path] = val;","\t360:     A.hook('set', function (path, val) {","\t361:       this[path] = val;","\t363:     A.post('set', function (next, path, val) {","\t364:       path.should.equal('hello');","\t375: //    A.hook('set', function (path, val) {","\t376: //      this[path] = val;","\t390:     A.hook('set', function (path, val) {","\t391:       this[path] = val;","\t394:     A.pre('set', function (next, path, val) {","\t397:     A.pre('set', function (next, path, val) {","\t398:       assert.equal(path, 'foo');","\t402:     A.pre('set', function (next, path, val, opt) {","\t403:       assert.equal(path, 'rock');","\t416:     A.hook('set', function (path, val) {","\t417:       this[path] = val;","\t419:     A.pre('set', function (next, path, val) {","\t422:     A.post('set', function (next, path, val) {","\t423:       path.should.equal('foo');","\t440:     A.hook('set', function (path, val, opts) {","\t441:       this[path] = val;","\t443:     A.pre('set', function (next, path, val, opts) {","\t455:     A.hook('set', function (path, val) {","\t457:       this[path] = val;","\t460:     A.pre('set', function (next, path, val) {","\t464:     A.pre('set', true, function (next, done, path, val) {","\t472:     A.pre('set', function (next, path, val) {","\t476:     A.pre('set', true, function (next, done, path, val) {","\t492:     A.hook('set', function (path, val) {","\t493:       this[path] = val;","\t494:       if (path === 'hello') counter.should.equal(1);","\t495:       if (path === 'foo') counter.should.equal(2);","\t497:     A.pre('set', true, function (next, done, path, val) {","\t565:     A.hook('set', function (path, val, fn) {","\t567:       this[path] = val;","\t570:     A.pre('set', true, function (next, done, path, val, fn) {","",""]},{"start":{"row":3230,"column":0},"end":{"row":3235,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/HISTORY.md:","\t9: - Optimized query path for performance, moving Object.defineProperty outside of constructors.","\t935: * Cleanup of bson.js to remove duplicated code paths","\t937: * Removing require.paths to make tests work with the 0.5.X branch","",""]},{"start":{"row":3235,"column":0},"end":{"row":3239,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/README.md:","\t91: Let's boot up a MongoDB server instance. Download the right MongoDB version from [MongoDB](http://www.mongodb.org), open a new shell or command line and ensure the **mongod** command is in the shell or command line path. Now let's create a database directory (in our case under **/data**).","\t94: mongod --dbpath=/data --port 27017","",""]},{"start":{"row":3239,"column":0},"end":{"row":3243,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/README.md:","\t85: Let's boot up a MongoDB server instance. Download the right MongoDB version from [MongoDB](http://www.mongodb.org), open a new shell or command line and ensure the **mongod** command is in the shell or command line path. Now let's create a database directory (in our case under **/data**).","\t88: mongod --dbpath=/data --port 27017","",""]},{"start":{"row":3243,"column":0},"end":{"row":3246,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/TESTING.md:","\t6: mongod --dbpath=./db","",""]},{"start":{"row":3246,"column":0},"end":{"row":3249,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/cursor.js:","\t204:     // Otherwise fall back to regular find path","",""]},{"start":{"row":3249,"column":0},"end":{"row":3259,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/mongos_manager.js:","\t4:   , path = require('path')","\t42:   // Set default db path if none set","\t43:   var pidfilepath = mongosOptions.pidfilepath = mongosOptions.pidfilepath || path.join(path.resolve('data'), f(\"data-%d\", port));","\t44:   var logpath = mongosOptions.logpath = mongosOptions.logpath || path.join(path.resolve('data'), f(\"data-%d.log\", port));","\t66:   // Add the file path","\t67:   pidfilepath = mongosOptions.pidfilepath = f(\"%s/mongos-%s.pid\", pidfilepath, port);","\t107:           pid = fs.readFileSync(pidfilepath, 'ascii').trim();          ","\t123:             pid = fs.readFileSync(pidfilepath, 'ascii').trim();          ","",""]},{"start":{"row":3259,"column":0},"end":{"row":3269,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/replset_manager.js:","\t4:   , path = require('path')","\t60:   // DbPath","\t61:   var dbpath = replsetOptions.dbpath = replsetOptions.dbpath || path.resolve('data');","\t343:     // Remove db path and recreate it","\t346:         rimraf.sync(dbpath);","\t347:         mkdirp.sync(dbpath);","\t363:         opts.dbpath = opts.dbpath ? opts.dbpath + f(\"/data-%s\", opts.port) : null;","\t364:         opts.logpath = opts.logpath ? opts.logpath + f(\"/data-%s.log\", opts.port) : null;","",""]},{"start":{"row":3269,"column":0},"end":{"row":3290,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/server_manager.js:","\t4:   , path = require('path')","\t61:   // Set default db path if none set","\t62:   var dbpath = serverOptions.dbpath = serverOptions.dbpath || path.join(path.resolve('data'), f(\"data-%d\", port));","\t63:   var logpath = serverOptions.logpath = serverOptions.logpath || path.join(path.resolve('data'), f(\"data-%d.log\", port));","\t73:   Object.defineProperty(this, 'dbpath', {","\t74:     enumerable:true, get: function() { return dbpath; }","\t77:   Object.defineProperty(this, 'logpath', {","\t78:     enumerable:true, get: function() { return logpath; }","\t115:     , 'journal', 'notablescan', 'noscripting', 'repairpath', 'repair'","\t118:     , 'dbpath', 'sysinfo', 'cpu', 'profile', 'slowms', 'rest'","\t121:     , 'keyFile', 'pidfilepath', 'timeStampFormat', 'logappend'","\t122:     , 'syslogFacility', 'syslog', 'logpath', 'maxConns', 'bind_ip', 'port'","\t190:             pid = fs.readFileSync(path.join(dbpath, \"mongod.lock\"), 'ascii').trim();","\t249:         rimraf.sync(serverOptions.dbpath);","\t250:         mkdirp.sync(serverOptions.dbpath);        ","\t255:     if(fs.existsSync(path.join(dbpath, \"mongod.lock\"))) {","\t256:       fs.unlinkSync(path.join(dbpath, \"mongod.lock\"));","\t289:   var locateLockFile = function(dbpath) {","\t296:           , pid: fs.readFileSync(path.join(dbpath, possibleLockFiles[i]), 'ascii').trim()","",""]},{"start":{"row":3290,"column":0},"end":{"row":3305,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/lib/tools/sharding_manager.js:","\t4:   , path = require('path')","\t70:   var dbpath = mongosOptions.dbpath;","\t71:   var logpath = mongosOptions.logpath;","\t109:         opts.dbpath = dbpath + f(\"/data-%s\", initiallConfigPort);","\t110:         opts.logpath = logpath + f(\"/data-%s.log\", initiallConfigPort);","\t141:         opts.dbpath = dbpath;","\t142:         opts.logpath = logpath;","\t181:         opts.pidfilepath = f(\"%s\", dbpath);","\t182:         opts.logpath = f(\"%s/mongos-%s.log\", logpath, initiallMongosPort);","\t260:             rimraf.sync(dbpath);","\t261:             mkdirp.sync(dbpath);","\t272:       rimraf.sync(dbpath);","\t273:       mkdirp.sync(dbpath);","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3305,"column":0},"end":{"row":3332,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/browser_build/bson.js:","\t30: function normalize(path) {","\t31:   var ret = [], parts = path.split('/'), cur, prev;","\t52: function dirname(path) {","\t53:   return path && path.substr(0, path.lastIndexOf(\"/\")) || \".\";","\t2705:   , './long'].forEach(function (path) {","\t2706:   \tvar module = require('./' + path);","\t2728: ].forEach(function (path) {","\t2729:     \tvar module = require('./' + path);","\t2753:     , '././bson'].forEach(function (path) {","\t2754:     \tvar module = require('./' + path);","","/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/build/bson.target.mk:","\t118: # Copy this to the executable output path.","","/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/build/Makefile:","\t11: abs_srcdir := $(abspath $(srcdir))","\t28: # as they reach into the src/ directory for data with relative paths.","\t30: abs_builddir := $(abspath $(builddir))","\t35: abs_obj := $(abspath $(obj))","\t79: # http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces","\t93: # ccache or distcc lose the path to the target, so we convert a rule of","\t97: #   path/to/foobar.o: DEP1 DEP2","\t114: # Fixup path as in (1).","\t171: # the local, absolute paths used on the link command-line.","\t186: # $LD_LIBRARY_PATH), without triggering make substitution.","",""]},{"start":{"row":3332,"column":0},"end":{"row":3336,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/ext/wscript:","\t3: from os.path import exists ","\t24:   # conf.check(lib='node', libpath=['/usr/lib', '/usr/local/lib'], uselib_store='NODE')","",""]},{"start":{"row":3336,"column":0},"end":{"row":3344,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/lib/bson/index.js:","\t18:   , './long'].forEach(function (path) {","\t19:   \tvar module = require('./' + path);","\t41: ].forEach(function (path) {","\t42:     \tvar module = require('./' + path);","\t66:     , '././bson'].forEach(function (path) {","\t67:     \tvar module = require('./' + path);","",""]},{"start":{"row":3344,"column":0},"end":{"row":3347,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/CHANGELOG.md:","\t166:  - fix \"not all control paths return a value\" compile warning on some platforms","",""]},{"start":{"row":3347,"column":0},"end":{"row":3350,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/include_dirs.js:","\t1: console.log(require('path').relative('.', __dirname));","",""]},{"start":{"row":3350,"column":0},"end":{"row":3354,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/bson/node_modules/nan/README.md:","\t92: Pull in the path to **NAN** in your *binding.gyp* so that you can use `#include <nan.h>` in your *.cpp* files:","\t100: This works like a `-I<path-to-NAN>` when compiling your addon.","",""]},{"start":{"row":3354,"column":0},"end":{"row":3357,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/build/kerberos.target.mk:","\t133: # Copy this to the executable output path.","",""]},{"start":{"row":3357,"column":0},"end":{"row":3369,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/build/Makefile:","\t11: abs_srcdir := $(abspath $(srcdir))","\t28: # as they reach into the src/ directory for data with relative paths.","\t30: abs_builddir := $(abspath $(builddir))","\t35: abs_obj := $(abspath $(obj))","\t79: # http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces","\t93: # ccache or distcc lose the path to the target, so we convert a rule of","\t97: #   path/to/foobar.o: DEP1 DEP2","\t114: # Fixup path as in (1).","\t171: # the local, absolute paths used on the link command-line.","\t186: # $LD_LIBRARY_PATH), without triggering make substitution.","",""]},{"start":{"row":3369,"column":0},"end":{"row":3372,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/CHANGELOG.md:","\t166:  - fix \"not all control paths return a value\" compile warning on some platforms","",""]},{"start":{"row":3372,"column":0},"end":{"row":3375,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/include_dirs.js:","\t1: console.log(require('path').relative('.', __dirname));","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3375,"column":0},"end":{"row":3379,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/kerberos/node_modules/nan/README.md:","\t92: Pull in the path to **NAN** in your *binding.gyp* so that you can use `#include <nan.h>` in your *.cpp* files:","\t100: This works like a `-I<path-to-NAN>` when compiling your addon.","",""]},{"start":{"row":3379,"column":0},"end":{"row":3386,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/index.js:","\t1: var path = require('path');","\t24:     p = path.resolve(p);","\t33:                 mkdirP(path.dirname(p), opts, function (er, made) {","\t67:     p = path.resolve(p);","\t76:                 made = sync(path.dirname(p), opts, made);","",""]},{"start":{"row":3386,"column":0},"end":{"row":3392,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/readme.markdown:","\t46: `opts.fs`. Your implementation should have `opts.fs.mkdir(path, mode, cb)` and","\t47: `opts.fs.stat(path, cb)`.","\t60: `opts.fs`. Your implementation should have `opts.fs.mkdirSync(path, mode)` and","\t61: `opts.fs.statSync(path)`.","",""]},{"start":{"row":3392,"column":0},"end":{"row":3397,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/bin/cmd.js:","\t16: var paths = argv._.slice();","\t20:     if (paths.length === 0) return;","\t21:     var p = paths.shift();","",""]},{"start":{"row":3397,"column":0},"end":{"row":3400,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/chmod.js:","\t2: var path = require('path');","",""]},{"start":{"row":3400,"column":0},"end":{"row":3407,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/clobber.js:","\t2: var path = require('path');","","/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/mkdirp.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":3407,"column":0},"end":{"row":3410,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/opts_fs.js:","\t2: var path = require('path');","",""]},{"start":{"row":3410,"column":0},"end":{"row":3417,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/opts_fs_sync.js:","\t2: var path = require('path');","","/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/perm.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":3417,"column":0},"end":{"row":3421,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/perm_sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":3421,"column":0},"end":{"row":3425,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/race.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":3425,"column":0},"end":{"row":3447,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/rel.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","","/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/return.js:","\t2: var path = require('path');","","/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/return_sync.js:","\t2: var path = require('path');","","/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/root.js:","\t2: var path = require('path');","\t8:     var file = path.resolve('/');","","/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","","/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/umask.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":3447,"column":0},"end":{"row":3451,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/mkdirp/test/umask_sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":3451,"column":0},"end":{"row":3455,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/bin.js:","\t21:   log('Usage: rimraf <path>')","\t23:   log('  Deletes all files and folders at \"path\" recursively.')","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3455,"column":0},"end":{"row":3463,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/README.md:","\t25: command `rimraf <path>` which is useful for cross platform support.","","/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/rimraf.js:","\t4: var path = require(\"path\")","\t131:       rimraf(path.join(p, f), function (er) {","\t175:     rimrafSync(path.join(p, f))","",""]},{"start":{"row":3463,"column":0},"end":{"row":3467,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/test/test-async.js:","\t2:   , path = require(\"path\")","\t3: rimraf(path.join(__dirname, \"target\"), function (er) {","",""]},{"start":{"row":3467,"column":0},"end":{"row":3471,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/mongodb-core/node_modules/rimraf/test/test-sync.js:","\t2:   , path = require(\"path\")","\t3: rimraf.sync(path.join(__dirname, \"target\"))","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3471,"column":0},"end":{"row":3476,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/readable-stream/lib/_stream_transform.js:","\t51: // a pathological inflate type of transform can cause excessive buffering","\t57: // such a pathological inflating mechanism, there'd be no way to tell","\t61: // However, even in such a pathological case, only a single written chunk","",""]},{"start":{"row":3476,"column":0},"end":{"row":3528,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mongodb/node_modules/readable-stream/node_modules/isarray/build/build.js:","\t3:  * Require the given path.","\t5:  * @param {String} path","\t10: function require(path, parent, orig) {","\t11:   var resolved = require.resolve(path);","\t15:     orig = orig || path;","\t18:     err.path = orig;","\t51:  * Resolve `path`.","\t55:  *   - PATH/index.js","\t56:  *   - PATH.js","\t57:  *   - PATH","\t59:  * @param {String} path","\t60:  * @return {String} path or null","\t64: require.resolve = function(path) {","\t65:   if (path.charAt(0) === '/') path = path.slice(1);","\t66:   var index = path + '/index.js';","\t68:   var paths = [","\t69:     path,","\t70:     path + '.js',","\t71:     path + '.json',","\t72:     path + '/index.js',","\t73:     path + '/index.json'","\t76:   for (var i = 0; i < paths.length; i++) {","\t77:     var path = paths[i];","\t78:     if (require.modules.hasOwnProperty(path)) return path;","\t87:  * Normalize `path` relative to the current path.","\t90:  * @param {String} path","\t95: require.normalize = function(curr, path) {","\t98:   if ('.' != path.charAt(0)) return path;","\t101:   path = path.split('/');","\t103:   for (var i = 0; i < path.length; ++i) {","\t104:     if ('..' == path[i]) {","\t106:     } else if ('.' != path[i] && '' != path[i]) {","\t107:       segs.push(path[i]);","\t115:  * Register module at `path` with callback `definition`.","\t117:  * @param {String} path","\t122: require.register = function(path, definition) {","\t123:   require.modules[path] = definition;","\t142:  * Return a require function relative to the `parent` path.","\t168:   function localRequire(path) {","\t169:     var resolved = localRequire.resolve(path);","\t170:     return require(resolved, parent, path);","\t177:   localRequire.resolve = function(path) {","\t178:     var c = path.charAt(0);","\t179:     if ('/' == c) return path.slice(1);","\t180:     if ('.' == c) return require.normalize(p, path);","\t188:     path = segs.slice(0, i + 1).join('/') + '/deps/' + path;","\t189:     return path;","\t193:    * Check if module is defined at `path`.","\t196:   localRequire.exists = function(path) {","\t197:     return require.modules.hasOwnProperty(localRequire.resolve(path));","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3528,"column":0},"end":{"row":3541,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mpath/package.json:","\t2:   \"name\": \"mpath\",","\t4:   \"description\": \"{G,S}et object values using MongoDB path notation\",","\t11:     \"url\": \"git://github.com/aheckmann/mpath.git\"","\t15:     \"path\",","\t27:   \"readme\": \"#mpath\\n\\n{G,S}et javascript object values using MongoDB-like path notation.\\n\\n###Getting\\n\\n```js\\nvar mpath = require('mpath');\\n\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.get('comments.1.title', obj) // 'exciting!'\\n```\\n\\n`mpath.get` supports array property notation as well.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.get('comments.title', obj) // ['funny', 'exciting!']\\n```\\n\\nArray property and indexing syntax, when used together, are very powerful.\\n\\n```js\\nvar obj = {\\n  array: [\\n      { o: { array: [{x: {b: [4,6,8]}}, { y: 10} ] }}\\n    , { o: { array: [{x: {b: [1,2,3]}}, { x: {z: 10 }}, { x: 'Turkey Day' }] }}\\n    , { o: { array: [{x: {b: null }}, { x: { b: [null, 1]}}] }}\\n    , { o: { array: [{x: null }] }}\\n    , { o: { array: [{y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ];\\n}\\n\\nvar found = mpath.get('array.o.array.x.b.1', obj);\\n\\nconsole.log(found); // prints..\\n\\n    [ [6, undefined]\\n    , [2, undefined, undefined]\\n    , [null, 1]\\n    , [null]\\n    , [undefined]\\n    , [undefined, undefined, undefined]\\n    , undefined\\n    ]\\n\\n```\\n\\n#####Field selection rules:\\n\\nThe following rules are iteratively applied to each `segment` in the passed `path`. For example:\\n\\n```js\\nvar path = 'one.two.14'; // path\\n'one' // segment 0\\n'two' // segment 1\\n14    // segment 2\\n```\\n\\n- 1) when value of the segment parent is not an array, return the value of `parent.segment`\\n- 2) when value of the segment parent is an array\\n  - a) if the segment is an integer, replace the parent array with the value at `parent[segment]`\\n  - b) if not an integer, keep the array but replace each array `item` with the value returned from calling `get(remainingSegments, item)` or undefined if falsey.\\n\\n#####Maps\\n\\n`mpath.get` also accepts an optional `map` argument which receives each individual found value. The value returned from the `map` function will be used in the original found values place.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.get('comments.title', obj, function (val) {\\n  return 'funny' == val\\n    ? 'amusing'\\n    : val;\\n});\\n// ['amusing', 'exciting!']\\n```\\n\\n###Setting\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.1.title', 'hilarious', obj)\\nconsole.log(obj.comments[1].title) // 'hilarious'\\n```\\n\\n`mpath.set` supports the same array property notation as `mpath.get`.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.title', ['hilarious', 'fruity'], obj);\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: 'hilarious' },\\n      { title: 'fruity' }\\n  ]}\\n```\\n\\nArray property and indexing syntax can be used together also when setting.\\n\\n```js\\nvar obj = {\\n  array: [\\n      { o: { array: [{x: {b: [4,6,8]}}, { y: 10} ] }}\\n    , { o: { array: [{x: {b: [1,2,3]}}, { x: {z: 10 }}, { x: 'Turkey Day' }] }}\\n    , { o: { array: [{x: {b: null }}, { x: { b: [null, 1]}}] }}\\n    , { o: { array: [{x: null }] }}\\n    , { o: { array: [{y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ]\\n}\\n\\nmpath.set('array.1.o', 'this was changed', obj);\\n\\nconsole.log(require('util').inspect(obj, false, 1000)); // prints..\\n\\n{\\n  array: [\\n      { o: { array: [{x: {b: [4,6,8]}}, { y: 10} ] }}\\n    , { o: 'this was changed' }\\n    , { o: { array: [{x: {b: null }}, { x: { b: [null, 1]}}] }}\\n    , { o: { array: [{x: null }] }}\\n    , { o: { array: [{y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ];\\n}\\n\\nmpath.set('array.o.array.x', 'this was changed too', obj);\\n\\nconsole.log(require('util').inspect(obj, false, 1000)); // prints..\\n\\n{\\n  array: [\\n      { o: { array: [{x: 'this was changed too'}, { y: 10, x: 'this was changed too'} ] }}\\n    , { o: 'this was changed' }\\n    , { o: { array: [{x: 'this was changed too'}, { x: 'this was changed too'}] }}\\n    , { o: { array: [{x: 'this was changed too'}] }}\\n    , { o: { array: [{x: 'this was changed too', y: 3 }] }}\\n    , { o: { array: [3, 0, null] }}\\n    , { o: { name: 'ha' }}\\n  ];\\n}\\n```\\n\\n####Setting arrays\\n\\nBy default, setting a property within an array to another array results in each element of the new array being set to the item in the destination array at the matching index. An example is helpful.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.title', ['hilarious', 'fruity'], obj);\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: 'hilarious' },\\n      { title: 'fruity' }\\n  ]}\\n```\\n\\nIf we do not desire this destructuring-like assignment behavior we may instead specify the `$` operator in the path being set to force the array to be copied directly.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.$.title', ['hilarious', 'fruity'], obj);\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: ['hilarious', 'fruity'] },\\n      { title: ['hilarious', 'fruity'] }\\n  ]}\\n```\\n\\n####Field assignment rules\\n\\nThe rules utilized mirror those used on `mpath.get`, meaning we can take values returned from `mpath.get`, update them, and reassign them using `mpath.set`. Note that setting nested arrays of arrays can get unweildy quickly. Check out the [tests](https://github.com/aheckmann/mpath/blob/master/test/index.js) for more extreme examples.\\n\\n#####Maps\\n\\n`mpath.set` also accepts an optional `map` argument which receives each individual value being set. The value returned from the `map` function will be used in the original values place.\\n\\n```js\\nvar obj = {\\n    comments: [\\n      { title: 'funny' },\\n      { title: 'exciting!' }\\n    ]\\n}\\n\\nmpath.set('comments.title', ['hilarious', 'fruity'], obj, function (val) {\\n  return val.length;\\n});\\n\\nconsole.log(obj); // prints..\\n\\n  { comments: [\\n      { title: 9 },\\n      { title: 6 }\\n  ]}\\n```\\n\\n### Custom object types\\n\\nSometimes you may want to enact the same functionality on custom object types that store all their real data internally, say for an ODM type object. No fear, `mpath` has you covered. Simply pass the name of the property being used to store the internal data and it will be traversed instead:\\n\\n```js\\nvar mpath = require('mpath');\\n\\nvar obj = {\\n    comments: [\\n      { title: 'exciting!', _doc: { title: 'great!' }}\\n    ]\\n}\\n\\nmpath.get('comments.0.title', obj, '_doc')            // 'great!'\\nmpath.set('comments.0.title', 'nov 3rd', obj, '_doc')\\nmpath.get('comments.0.title', obj, '_doc')            // 'nov 3rd'\\nmpath.get('comments.0.title', obj)                    // 'exciting'\\n```\\n\\nWhen used with a `map`, the `map` argument comes last.\\n\\n```js\\nmpath.get(path, obj, '_doc', map);\\nmpath.set(path, val, obj, '_doc', map);\\n```\\n\\n[LICENSE](https://github.com/aheckmann/mpath/blob/master/LICENSE)\\n\\n\",","\t28:   \"_id\": \"mpath@0.1.1\",","\t31:     \"tarball\": \"http://registry.npmjs.org/mpath/-/mpath-0.1.1.tgz\"","\t46:   \"_from\": \"mpath@0.1.1\",","\t47:   \"_resolved\": \"https://registry.npmjs.org/mpath/-/mpath-0.1.1.tgz\",","\t49:     \"url\": \"https://github.com/aheckmann/mpath/issues\"","\t51:   \"homepage\": \"https://github.com/aheckmann/mpath\"","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3541,"column":0},"end":{"row":3607,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mpath/README.md:","\t1: #mpath","\t3: {G,S}et javascript object values using MongoDB-like path notation.","\t8: var mpath = require('mpath');","\t17: mpath.get('comments.1.title', obj) // 'exciting!'","\t20: `mpath.get` supports array property notation as well.","\t30: mpath.get('comments.title', obj) // ['funny', 'exciting!']","\t48: var found = mpath.get('array.o.array.x.b.1', obj);","\t65: The following rules are iteratively applied to each `segment` in the passed `path`. For example:","\t68: var path = 'one.two.14'; // path","\t81: `mpath.get` also accepts an optional `map` argument which receives each individual found value. The value returned from the `map` function will be used in the original found values place.","\t91: mpath.get('comments.title', obj, function (val) {","\t109: mpath.set('comments.1.title', 'hilarious', obj)","\t113: `mpath.set` supports the same array property notation as `mpath.get`.","\t123: mpath.set('comments.title', ['hilarious', 'fruity'], obj);","\t148: mpath.set('array.1.o', 'this was changed', obj);","\t164: mpath.set('array.o.array.x', 'this was changed too', obj);","\t193: mpath.set('comments.title', ['hilarious', 'fruity'], obj);","\t203: If we do not desire this destructuring-like assignment behavior we may instead specify the `$` operator in the path being set to force the array to be copied directly.","\t213: mpath.set('comments.$.title', ['hilarious', 'fruity'], obj);","\t225: The rules utilized mirror those used on `mpath.get`, meaning we can take values returned from `mpath.get`, update them, and reassign them using `mpath.set`. Note that setting nested arrays of arrays can get unweildy quickly. Check out the [tests](https://github.com/aheckmann/mpath/blob/master/test/index.js) for more extreme examples.","\t229: `mpath.set` also accepts an optional `map` argument which receives each individual value being set. The value returned from the `map` function will be used in the original values place.","\t239: mpath.set('comments.title', ['hilarious', 'fruity'], obj, function (val) {","\t253: Sometimes you may want to enact the same functionality on custom object types that store all their real data internally, say for an ODM type object. No fear, `mpath` has you covered. Simply pass the name of the property being used to store the internal data and it will be traversed instead:","\t256: var mpath = require('mpath');","\t264: mpath.get('comments.0.title', obj, '_doc')            // 'great!'","\t265: mpath.set('comments.0.title', 'nov 3rd', obj, '_doc')","\t266: mpath.get('comments.0.title', obj, '_doc')            // 'nov 3rd'","\t267: mpath.get('comments.0.title', obj)                    // 'exciting'","\t273: mpath.get(path, obj, '_doc', map);","\t274: mpath.set(path, val, obj, '_doc', map);","\t277: [LICENSE](https://github.com/aheckmann/mpath/blob/master/LICENSE)","","/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mpath/lib/index.js:","\t3:  * Returns the value of object `o` at the given `path`.","\t14:  *     mpath.get('comments.0.title', o)         // 'exciting!'","\t15:  *     mpath.get('comments.0.title', o, '_doc') // 'great!'","\t16:  *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']","\t19:  *     mpath.get(path, o)","\t20:  *     mpath.get(path, o, special)","\t21:  *     mpath.get(path, o, map)","\t22:  *     mpath.get(path, o, special, map)","\t24:  * @param {String} path","\t26:  * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.","\t30: exports.get = function (path, o, special, map) {","\t38:   var parts = 'string' == typeof path","\t39:     ? path.split('.')","\t40:     : path","\t43:     throw new TypeError('Invalid `path`. Must be either string or array');","\t54:       var paths = parts.slice(i);","\t58:           ? exports.get(paths, item, special, map)","\t74:  * Sets the `val` at the given `path` of object `o`.","\t76:  * @param {String} path","\t79:  * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.","\t84: exports.set = function (path, val, o, special, map, _copying) {","\t92:   var parts = 'string' == typeof path","\t93:     ? path.split('.')","\t94:     : path","\t97:     throw new TypeError('Invalid `path`. Must be either string or array');","\t102:   // the existance of $ in a path tells us if the user desires","\t106:   var copy = _copying || /\\$/.test(path)","\t122:       var paths = parts.slice(i);","\t126:           exports.set(paths, val[j], obj[j], special, map, copy);","\t131:           exports.set(paths, val, obj[j], special, map, copy);","\t144:   // process the last property of the path","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3607,"column":0},"end":{"row":3812,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mpath/test/index.js:","\t6: var mpath = require('../')","\t19:  * special path for override tests","\t28: describe('mpath', function(){","\t63:     it('`path` must be a string or array', function(done){","\t65:         mpath.get({}, o);","\t68:         mpath.get(4, o);","\t71:         mpath.get(function(){}, o);","\t74:         mpath.get(/asdf/, o);","\t77:         mpath.get(Math, o);","\t80:         mpath.get(Buffer, o);","\t83:         mpath.get('string', o);","\t86:         mpath.get([], o);","\t93:         assert.equal('jiro', mpath.get('name', o));","\t97:           , mpath.get('first', o)","\t102:           , mpath.get('first.second', o)","\t107:           , mpath.get('first.second.third', o)","\t112:           , mpath.get('first.second.third.0', o)","\t117:           , mpath.get('first.second.third.2', o)","\t122:           , mpath.get('first.second.third.1', o)","\t127:           , mpath.get('first.second.third.1.name', o)","\t136:           mpath.get('comments', o));","\t138:         assert.deepEqual({ name: 'one' }, mpath.get('comments.0', o));","\t139:         assert.deepEqual('one', mpath.get('comments.0.name', o));","\t140:         assert.deepEqual('two', mpath.get('comments.1.name', o));","\t141:         assert.deepEqual('three', mpath.get('comments.2.name', o));","\t144:             , mpath.get('comments.2.comments', o));","\t147:             , mpath.get('comments.2.comments.1', o));","\t149:         assert.deepEqual('twoo', mpath.get('comments.2.comments.1.comments.0.val', o));","\t157:           , mpath.get('comments.name', o)","\t165:           , mpath.get('comments.comments', o)","\t173:           , mpath.get('first.second.third.name', o)","\t177:           , mpath.get('first.second.third.name', o, function (v) {","\t194:           , mpath.get('array.o.array', o)","\t209:           , mpath.get('array.o.array.0', o)","\t224:           , mpath.get('array.o.array.0.x', o)","\t239:           , mpath.get('array.o.array.y', o)","\t250:           , mpath.get('array.o.array.x', o)","\t265:           , mpath.get('array.o.array.x.b', o)","\t280:           , mpath.get('array.o.array.x.b.1', o)","\t291:           , mpath.get('array.o.array.x.b.1', o, function (v) {","\t301:           , mpath.get('array.1.o.array', o)","\t305:           , mpath.get('array.1.o.array', o, function (v) {","\t320:           , mpath.get('arr.arr.1', o)","\t324:           , mpath.get('arr.arr.1', o, function (v) {","\t335:           , mpath.get('arr.arr.1.a', o, function (v) {","\t342:           , mpath.get('arr.arr.1.a', o)","\t344:         mpath.set('arr.arr.1.a', [{c:49},undefined], o)","\t347:           , mpath.get('arr.arr.1.a', o)","\t349:         mpath.set('arr.arr.1.a', [{c:48},undefined], o)","\t356:           , mpath.get('arr.arr.1.a.c', o)","\t360:           , mpath.get('arr.arr.1.a.c', o, function (v) {","\t372:         assert.equal('jiro', mpath.get('name', o, special));","\t376:           , mpath.get('first', o, special)","\t381:           , mpath.get('first.second', o, special)","\t386:           , mpath.get('first.second.third', o, special)","\t391:           , mpath.get('first.second.third.0', o, special)","\t396:           , mpath.get('first.second.third.0', o, special, function (v) {","\t403:           , mpath.get('first.second.third.2', o, special)","\t408:           , mpath.get('first.second.third.1', o, special)","\t413:           , mpath.get('first.second.third.1.name', o, special)","\t422:           mpath.get('comments', o, special));","\t424:         assert.deepEqual({ name: 'one' }, mpath.get('comments.0', o, special));","\t425:         assert.deepEqual('one', mpath.get('comments.0.name', o, special));","\t426:         assert.deepEqual('2', mpath.get('comments.1.name', o, special));","\t427:         assert.deepEqual('3', mpath.get('comments.2.name', o, special));","\t428:         assert.deepEqual('nice', mpath.get('comments.2.name', o, special, function (v) {","\t433:             , mpath.get('comments.2.comments', o, special));","\t436:             , mpath.get('comments.2.comments.1', o, special));","\t438:         assert.deepEqual(2, mpath.get('comments.2.comments.1.comments.0.val', o, special));","\t445:           , mpath.get('comments.name', o, special)","\t449:           , mpath.get('comments.name', o, special, function (v) {","\t459:           , mpath.get('comments.comments', o, special)","\t467:           , mpath.get('comments.comments.1.comments', o, special)","\t475:           , mpath.get('comments.comments.1.comments.val', o, special)","\t479:           , mpath.get('comments.comments.1.comments.val', o, special, function (v) {","\t494:         mpath.set('name', 'a new val', o, function (v) {","\t499:         mpath.set('name', 'changed', o);","\t502:         mpath.set('first.second.third', [1,{name:'x'},9], o);","\t505:         mpath.set('first.second.third.1.name', 'y', o)","\t508:         mpath.set('comments.1.name', 'ttwwoo', o);","\t511:         mpath.set('comments.2.comments.1.comments.0.expand', 'added', o);","\t516:         mpath.set('comments.2.comments.1.comments.2', 'added', o);","\t531:       describe('array.path', function(){","\t534:             mpath.set('arr.yep', false, o, function (v) {","\t542:             mpath.set('arr.yep', false, o);","\t554:             mpath.set('arr.yep', ['one',2], o, function (v) {","\t561:             mpath.set('arr.yep', ['one',2], o);","\t572:             mpath.set('arr.yep', [47], o, function (v) {","\t580:             mpath.set('arr.yep', [47], o);","\t590:             mpath.set('arr.yep', [5,6,7], o, function (v) {","\t598:             mpath.set('arr.yep', [5,6,7], o);","\t609:       describe('array.$.path', function(){","\t612:             mpath.set('arr.$.yep', {xtra: 'double good'}, o, function (v) {","\t620:             mpath.set('arr.$.yep', {xtra: 'double good'}, o);","\t631:             mpath.set('arr.$.yep', [15], o, function (v) {","\t639:             mpath.set('arr.$.yep', [15], o);","\t650:       describe('array.index.path', function(){","\t652:           mpath.set('arr.1.yep', 0, o, function (v) {","\t660:           mpath.set('arr.1.yep', 0, o);","\t670:       describe('array.index.array.path', function(){","\t672:           mpath.set('arr.0.arr.e', 35, o, function (v) {","\t680:           mpath.set('arr.0.arr.e', 35, o);","\t689:           mpath.set('arr.0.arr.e', ['a','b'], o, function (v) {","\t697:           mpath.set('arr.0.arr.e', ['a','b'], o);","\t707:       describe('array.index.array.path.path', function(){","\t709:           mpath.set('arr.0.arr.a.b', 36, o, function (v) {","\t717:           mpath.set('arr.0.arr.a.b', 36, o);","\t726:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o, function (v) {","\t734:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o);","\t744:       describe('array.index.array.$.path.path', function(){","\t746:           mpath.set('arr.0.arr.$.a.b', '$', o, function (v) {","\t754:           mpath.set('arr.0.arr.$.a.b', '$', o);","\t763:           mpath.set('arr.0.arr.$.a.b', [1], o, function (v) {","\t771:           mpath.set('arr.0.arr.$.a.b', [1], o);","\t781:       describe('array.array.index.path', function(){","\t783:           mpath.set('arr.arr.0.a', 'single', o, function (v) {","\t791:           mpath.set('arr.arr.0.a', 'single', o);","\t800:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o, function (v) {","\t808:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o);","\t818:       describe('array.array.$.index.path', function(){","\t820:           mpath.set('arr.arr.$.0.a', 'singles', o, function (v) {","\t828:           mpath.set('arr.arr.$.0.a', 'singles', o);","\t834:           mpath.set('$.arr.arr.0.a', 'single', o);","\t843:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o, function (v) {","\t851:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o);","\t857:           mpath.set('arr.$.arr.0.a', [4,8,15,16,23,42,108], o);","\t867:       describe('array.array.path.index', function(){","\t869:           mpath.set('arr.arr.a.7', 47, o, function (v) {","\t877:           mpath.set('arr.arr.a.7', 47, o);","\t887:           mpath.set('arr.arr.a.7', [[null,46], [undefined, 'woot']], o);","\t903:       describe('handles array.array.path', function(){","\t916:           mpath.set('arr.arr.e', 47, o, function (v) {","\t936:           mpath.set('arr.arr.e', 47, o);","\t955:           mpath.set('arr.arr.e', [[1,2,3],[4,5],null,[],[6], [7,8,9]], o, function (v) {","\t977:           mpath.set('arr.arr.e', [[1,2,3],[4,5],null,[],[6], [7,8,9]], o);","\t1005:         mpath.set('name', 'chan', o, special, function (v) {","\t1010:         mpath.set('name', 'changer', o, special);","\t1013:         mpath.set('first.second.third', [1,{name:'y'},9], o, special);","\t1016:         mpath.set('first.second.third.1.name', 'z', o, special)","\t1019:         mpath.set('comments.1.name', 'ttwwoo', o, special);","\t1022:         mpath.set('comments.2.comments.1.comments.0.expander', 'adder', o, special, function (v) {","\t1029:         mpath.set('comments.2.comments.1.comments.0.expander', 'adder', o, special);","\t1034:         mpath.set('comments.2.comments.1.comments.2', 'set', o, special);","\t1048:       describe('array.path', function(){","\t1053:             mpath.set('arr.yep', false, o, special, function (v) {","\t1061:             mpath.set('arr.yep', false, o, special);","\t1072:             mpath.set('arr.yep', ['one',2], o, special, function (v) {","\t1080:             mpath.set('arr.yep', ['one',2], o, special);","\t1090:             mpath.set('arr.yep', [47], o, special, function (v) {","\t1098:             mpath.set('arr.yep', [47], o, special);","\t1107:             mpath.set('arr.yep', [20], o, special);","\t1117:             mpath.set('arr.yep', [5,6,7], o, special, function () {","\t1125:             mpath.set('arr.yep', [5,6,7], o, special);","\t1136:       describe('array.$.path', function(){","\t1139:             mpath.set('arr.$.yep', {xtra: 'double good'}, o, special, function (v) {","\t1148:             mpath.set('arr.$.yep', {xtra: 'double good'}, o, special);","\t1160:             mpath.set('arr.$.yep', [15], o, special, function (v) {","\t1169:             mpath.set('arr.$.yep', [15], o, special);","\t1181:       describe('array.index.path', function(){","\t1183:           mpath.set('arr.1.yep', 0, o, special, function (v) {","\t1192:           mpath.set('arr.1.yep', 0, o, special);","\t1203:       describe('array.index.array.path', function(){","\t1205:           mpath.set('arr.0.arr.e', 35, o, special, function (v) {","\t1214:           mpath.set('arr.0.arr.e', 35, o, special);","\t1224:           mpath.set('arr.0.arr.e', ['a','b'], o, special, function (v) {","\t1233:           mpath.set('arr.0.arr.e', ['a','b'], o, special);","\t1244:       describe('array.index.array.path.path', function(){","\t1246:           mpath.set('arr.0.arr.a.b', 36, o, special, function (v) {","\t1255:           mpath.set('arr.0.arr.a.b', 36, o, special);","\t1265:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o, special, function (v) {","\t1274:           mpath.set('arr.0.arr.a.b', [1,2,3,4], o, special);","\t1285:       describe('array.index.array.$.path.path', function(){","\t1287:           mpath.set('arr.0.arr.$.a.b', '$', o, special, function (v) {","\t1296:           mpath.set('arr.0.arr.$.a.b', '$', o, special);","\t1306:           mpath.set('arr.0.arr.$.a.b', [1], o, special, function (v) {","\t1315:           mpath.set('arr.0.arr.$.a.b', [1], o, special);","\t1326:       describe('array.array.index.path', function(){","\t1328:           mpath.set('arr.arr.0.a', 'single', o, special, function (v) {","\t1337:           mpath.set('arr.arr.0.a', 'single', o, special);","\t1347:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o, special, function (v) {","\t1356:           mpath.set('arr.arr.0.a', [4,8,15,16,23,42], o, special);","\t1367:       describe('array.array.$.index.path', function(){","\t1369:           mpath.set('arr.arr.$.0.a', 'singles', o, special, function (v) {","\t1378:           mpath.set('arr.arr.$.0.a', 'singles', o, special);","\t1385:           mpath.set('$.arr.arr.0.a', 'single', o, special);","\t1395:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o, special, function (v) {","\t1404:           mpath.set('arr.arr.$.0.a', [4,8,15,16,23,42], o, special);","\t1411:           mpath.set('arr.$.arr.0.a', [4,8,15,16,23,42,108], o, special);","\t1422:       describe('array.array.path.index', function(){","\t1424:           mpath.set('arr.arr.a.7', 47, o, special, function (v) {","\t1433:           mpath.set('arr.arr.a.7', 47, o, special);","\t1444:           mpath.set('arr.arr.a.7', [[null,46], [undefined, 'woot']], o, special, function (v) {","\t1459:           mpath.set('arr.arr.a.7', [[null,46], [undefined, 'woot']], o, special);","\t1473:       describe('handles array.array.path', function(){","\t1483:           mpath.set('arr.arr.e', 47, o, special);","\t1519:           mpath.set('arr.arr.e', [[1,2,3],[4,5],null,[],[6], [7,8,9]], o, special);","\t1562:         var vals = mpath.get('array.o.array.x.b', o);","\t1570:         mpath.set('array.o.array.x.b', vals, o);","\t1586:         mpath.set('comments.name', ['this', 'was', 'changed'], o);","\t1596:         mpath.set('comments.name', ['also', 'changed', 'this'], o, special);","\t1615:           mpath.set('arr.$.arr.$.a', 35, o);","\t1621:     it('ignores setting a nested path that doesnt exist', function(done){","\t1624:         mpath.set('thing.that.is.new', 10, o);","",""]},{"start":{"row":3812,"column":0},"end":{"row":3822,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mquery/README.md:","\t180: All paths passed that are not `$atomic` operations will become `$set` ops. For example:","\t405: Specifies the complementary comparison value for the path specified with `where()`.","\t499: query.where('path').intersects().geometry({","\t505: query.where('path').intersects({","\t655: When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.","\t721: Specifies a `$slice` projection for a `path`","\t757: Specifies a `path` for use with chaining","\t884: If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3822,"column":0},"end":{"row":3938,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mquery/lib/mquery.js:","\t50:   this._path = proto._path || undefined;","\t135:   p._path = this._path;","\t231:  * Specifies a `path` for use with chaining.","\t251:  * @param {String} [path]","\t264:     this._path = arguments[0];","\t267:       this._conditions[this._path] = arguments[1];","\t277:   throw new TypeError('path must be a string or object');","\t281:  * Specifies the complementary comparison value for paths specified with `where()`","\t297:   this._ensurePath('equals');","\t298:   var path = this._path;","\t299:   this._conditions[path] = val;","\t364:  * When called with one argument, the most recent path passed to `where()` is used.","\t375:  * @param {String} [path]","\t383:  * When called with one argument, the most recent path passed to `where()` is used.","\t387:  * @param {String} [path]","\t395:  * When called with one argument, the most recent path passed to `where()` is used.","\t399:  * @param {String} [path]","\t407:  * When called with one argument, the most recent path passed to `where()` is used.","\t411:  * @param {String} [path]","\t419:  * When called with one argument, the most recent path passed to `where()` is used.","\t423:  * @param {String} [path]","\t431:  * When called with one argument, the most recent path passed to `where()` is used.","\t435:  * @param {String} [path]","\t443:  * When called with one argument, the most recent path passed to `where()` is used.","\t447:  * @param {String} [path]","\t455:  * When called with one argument, the most recent path passed to `where()` is used.","\t459:  * @param {String} [path]","\t467:  * When called with one argument, the most recent path passed to `where()` is used.","\t471:  * @param {String} [path]","\t479:  * When called with one argument, the most recent path passed to `where()` is used.","\t483:  * @param {String} [path]","\t491:  * When called with one argument, the most recent path passed to `where()` is used.","\t495:  * @param {String} [path]","\t508:     var path, val;","\t511:       this._ensurePath($conditional);","\t513:       path = this._path;","\t516:       path = arguments[0];","\t519:     var conds = this._conditions[path] || (this._conditions[path] = {});","\t528:  * @param {String} [path]","\t535:   var val, path;","\t538:     this._ensurePath('mod')","\t540:     path = this._path;","\t542:     this._ensurePath('mod')","\t544:     path = this._path;","\t547:     path = arguments[0];","\t550:     path = arguments[0];","\t553:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t572:  * @param {String} [path]","\t579:   var path, val;","\t582:     this._ensurePath('exists');","\t583:     path = this._path;","\t587:       this._ensurePath('exists');","\t588:       path = this._path;","\t591:       path = arguments[0];","\t595:     path = arguments[0];","\t599:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t623:  * @param {String|Object|Function} path","\t633:   var fn, path, criteria;","\t636:     this._ensurePath('elemMatch');","\t637:     path = this._path;","\t640:     this._ensurePath('elemMatch');","\t641:     path = this._path;","\t644:     path = arguments[0];","\t647:     path = arguments[0];","\t659:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t694:   this._ensurePath('within');","\t740:  * @param {String} path","\t747:   var path, box;","\t751:     path = arguments[0];","\t755:     this._ensurePath('box');","\t756:     path = this._path;","\t762:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t775:  * @param {String|Array} [path]","\t783:   var val, path;","\t787:     path = arguments[0];","\t791:     this._ensurePath('polygon');","\t792:     path = this._path;","\t796:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t815:  * @param {String} [path]","\t823:   var path, val;","\t826:     this._ensurePath('circle');","\t827:     path = this._path;","\t830:     path = arguments[0];","\t839:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t869:  * @param {String} [path]","\t877:   var path, val;","\t884:     this._ensurePath('near');","\t885:     path = this._path;","\t888:     path = arguments[0];","\t898:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t936:  *     query.where('path').intersects().geometry({","\t941:  *     query.where('path').intersects({","\t953:   this._ensurePath('intersects');","\t996:  * The most recent path passed to `where()` is used.","\t1014:   var val, path;","\t1017:     this._ensurePath('geometry');","\t1018:     path = this._path;","\t1028:   var conds = this._conditions[path] || (this._conditions[path] = {});","\t1041:  * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.","\t1102:  * Specifies a $slice condition for a `path`","\t1112:  * @param {String} [path]","\t1125:   var path, val;","\t1128:     this._ensurePath('slice');","\t1129:     path = this._path;","\t1133:       this._ensurePath('slice');","\t1134:       path = this._path;","\t1137:       path = arguments[0];","\t1141:     path = arguments[0];","\t1146:   myFields[path] = { '$slice': val };","\t1155:  * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.","\t1798:  * _All paths passed that are not $atomic operations will become $set ops._","\t2381:  * Make sure _path is set.","\t2386: Query.prototype._ensurePath = function (method) {","\t2387:   if (!this._path) {","",""]},{"start":{"row":3938,"column":0},"end":{"row":3948,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/mquery/test/index.js:","\t61:       var path = 'street';","\t67:       q.where(path);","\t78:       assert.equal(path, m._path);","\t143:       }, /path must be a string or object/);","\t160:         assert.equal('name', m._path);","\t167:       assert.equal('name', m._path);","\t186:     it('sets value of path set with where()', function(){","\t287:       it('uses previously set `where` path if 1 arg passed', function(){","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3948,"column":0},"end":{"row":3961,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/ms/test/support/jquery.js:","\t1665: \t\t\t// the code to shortcut on the same path as a DOM node with no cache","\t3047: \t\t\tcache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;","\t3117: \t\t// Determine event propagation path in advance, per W3C events spec (#9951)","\t3119: \t\teventPath = [[ elem, special.bindType || type ]];","\t3126: \t\t\t\teventPath.push([ cur, bubbleType ]);","\t3132: \t\t\t\teventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);","\t3136: \t\t// Fire handlers on the event path","\t3137: \t\tfor ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {","\t3139: \t\t\tcur = eventPath[i][0];","\t3140: \t\t\tevent.type = eventPath[i][1];","\t6667: \t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...","",""]},{"start":{"row":3961,"column":0},"end":{"row":3965,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/mongoose/node_modules/muri/lib/index.js:","\t44:   var path = match[2];","\t75:   var parts = path.split('?');","",""]},{"start":{"row":3965,"column":0},"end":{"row":3968,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/node_modules/util/test/node/debug.js:","\t49:   var child = spawn(process.execPath, [__filename, 'child'], {","",""]},{"start":{"row":3968,"column":0},"end":{"row":3971,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/tests/testconfig.js:","\t4:         packagePath: \"../../acute-express-data\",","",""]},{"start":{"row":3971,"column":0},"end":{"row":3976,"column":0},"action":"insert","lines":["/node_modules/acute-mongoose-models/tests/testModels.js:","\t2:     path = require('path'),","\t10:         var configPath = path.join(__dirname, \"testconfig.js\");","\t11:         var config = architect.loadConfig(configPath);","",""]},{"start":{"row":3976,"column":0},"end":{"row":3980,"column":0},"action":"insert","lines":["/node_modules/acute-utils/lib/index.js:","\t3: exports.loadApp = function(configPath, cb) {","\t4:     architect.loadConfig(configPath, function(err, conf) {","",""]},{"start":{"row":3980,"column":0},"end":{"row":3985,"column":0},"action":"insert","lines":["/node_modules/acute-utils/test/testIndex.js:","\t2:     path = require('path'),","\t3:     configPath = path.join(__dirname, \"testConfig.js\");","\t8:             var config = utils.loadApp(configPath, function(err, arch) {","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":3985,"column":0},"end":{"row":4076,"column":0},"action":"insert","lines":["/node_modules/architect/architect.js:","\t13:     var dirname = require('path').dirname;","\t14:     var resolve = require('path').resolve;","\t15:     var existsSync = require('fs').existsSync || require('path').existsSync;","\t16:     var realpathSync = require('fs').realpathSync;","\t17:     var exists = require('fs').exists || require('path').exists;","\t18:     var realpath = require('fs').realpath;","\t19:     var packagePathCache = {};","\t26:     function loadConfig(configPath, callback) {","\t27:       var config = require(configPath);","\t28:       var base = dirname(configPath);","\t44:                 plugin = config[index] = { packagePath: plugin };","\t47:             if (plugin.hasOwnProperty(\"packagePath\") && !plugin.hasOwnProperty(\"setup\")) {","\t48:                 var defaults = resolveModuleSync(base, plugin.packagePath);","\t54:                 plugin.packagePath = defaults.packagePath;","\t55:                 plugin.setup = require(plugin.packagePath);","\t71:                 plugin = config[i] = { packagePath: plugin };","\t74:             if (plugin.hasOwnProperty(\"packagePath\") && !plugin.hasOwnProperty(\"setup\")) {","\t75:                 resolveModule(base, plugin.packagePath, function(err, defaults) {","\t83:                     plugin.packagePath = defaults.packagePath;","\t85:                         plugin.setup = require(plugin.packagePath);","\t103:     function resolveModuleSync(base, modulePath) {","\t104:         var packagePath;","\t106:             packagePath = resolvePackageSync(base, modulePath + \"/package.json\");","\t111:         var metadata = packagePath && require(packagePath).plugin || {};","\t112:         if (packagePath) {","\t113:             modulePath = dirname(packagePath);","\t115:             modulePath = resolvePackageSync(base, modulePath);","\t117:         var module = require(modulePath);","\t120:         metadata.packagePath = modulePath;","\t126:     function resolveModule(base, modulePath, callback) {","\t127:         resolvePackage(base, modulePath + \"/package.json\", function(err, packagePath) {","\t133:                     metadata = packagePath && require(packagePath).plugin || {};","\t142:                     resolvePackage(base, modulePath + \".js\", next);","\t144:                 else if (packagePath) {","\t145:                     next(null, dirname(packagePath));","\t148:                     resolvePackage(base, modulePath, next);","\t150:             })(function(err, modulePath) {","\t155:                     module = require(modulePath);","\t162:                 metadata.packagePath = modulePath;","\t171:     function resolvePackageSync(base, packagePath) {","\t173:         if (!(base in packagePathCache)) {","\t174:             packagePathCache[base] = {};","\t176:         var cache = packagePathCache[base];","\t177:         if (packagePath in cache) {","\t178:             return cache[packagePath];","\t180:         var newPath;","\t181:         if (packagePath[0] === \".\" || packagePath[0] === \"/\") {","\t182:             newPath = resolve(base, packagePath);","\t183:             if (existsSync(newPath)) {","\t184:                 newPath = realpathSync(newPath);","\t185:                 cache[packagePath] = newPath;","\t186:                 return newPath;","\t191:                 newPath = resolve(base, \"node_modules\", packagePath);","\t192:                 if (existsSync(newPath)) {","\t193:                     newPath = realpathSync(newPath);","\t194:                     cache[packagePath] = newPath;","\t195:                     return newPath;","\t200:         var err = new Error(\"Can't find '\" + packagePath + \"' relative to '\" + originalBase + \"'\");","\t205:     function resolvePackage(base, packagePath, callback) {","\t207:         if (!packagePathCache.hasOwnProperty(base)) {","\t208:             packagePathCache[base] = {};","\t210:         var cache = packagePathCache[base];","\t211:         if (cache.hasOwnProperty(packagePath)) {","\t212:             return callback(null, cache[packagePath]);","\t214:         if (packagePath[0] === \".\" || packagePath[0] === \"/\") {","\t215:             var newPath = resolve(base, packagePath);","\t216:             exists(newPath, function(exists) {","\t218:                     realpath(newPath, function(err, newPath) {","\t221:                         cache[packagePath] = newPath;","\t222:                         return callback(null, newPath);","\t225:                     var err = new Error(\"Can't find '\" + packagePath + \"' relative to '\" + originalBase + \"'\");","\t237:                 var err = new Error(\"Can't find '\" + packagePath + \"' relative to '\" + originalBase + \"'\");","\t242:             var newPath = resolve(base, \"node_modules\", packagePath);","\t243:             exists(newPath, function(exists) {","\t245:                     realpath(newPath, function(err, newPath) {","\t248:                         cache[packagePath] = newPath;","\t249:                         return callback(null, newPath);","\t270:     function loadConfig(path, callback) {","\t271:         require([path], function (config) {","\t282:         var paths = [], pluginIndexes = {};","\t286:                 plugin = config[index] = { packagePath: plugin };","\t289:             if (plugin.hasOwnProperty(\"packagePath\") && !plugin.hasOwnProperty(\"setup\")) {","\t290:                 paths.push((base || \"\") + plugin.packagePath);","\t291:                 pluginIndexes[plugin.packagePath] = index;","\t294:         // Mass-Load path-based plugins using amd's require","\t295:         require(paths, function () {","\t297:             paths.forEach(function (name, i) {","\t336:             packagePath: pluginConfig.packagePath,","\t386:                 unresolved[name].push(plugin.packagePath);","",""]},{"start":{"row":4076,"column":0},"end":{"row":4083,"column":0},"action":"insert","lines":["/node_modules/architect/README.markdown:","\t67:   { packagePath: \"architect-http\", port: 8080 },","\t68:   { packagePath: \"architect-http-static\", root: \"www\" },","\t75: Notice that the config is a list of plugin config options.  If the only option in the config is `packagePath`, then a string can be used in place of the object.  If you want to pass other options to the plugin when it's being created, you can put arbitrary properties here.","\t87: ### loadConfig(configPath)","\t89: This is a sync function that loads a config file and parses all the plugins into a proper config object for use with `createApp`.  While this uses sync I/O all steps along the way are memoized and I/O only occurs on the first invocation.  It's safe to call this in an event loop provided a small set of configPaths are used.","",""]},{"start":{"row":4083,"column":0},"end":{"row":4084,"column":0},"action":"insert","lines":["/node_modules/body-parser/index.js:",""]},{"start":{"row":4084,"column":0},"end":{"row":4090,"column":0},"action":"insert","lines":["\t13: var path = require('path')","\t33:  * Path to the parser modules.","\t36: var parsersDir = path.join(__dirname, 'lib', 'types')","\t45:   var loc = path.resolve(parsersDir, filename)","\t47:   var name = path.basename(filename, '.js')","",""]},{"start":{"row":4090,"column":0},"end":{"row":4093,"column":0},"action":"insert","lines":["/node_modules/body-parser/node_modules/debug/History.md:","\t48:   * Makefile: find node path using shell/which (#109, @timoxley)","",""]},{"start":{"row":4093,"column":0},"end":{"row":4097,"column":0},"action":"insert","lines":["/node_modules/body-parser/node_modules/debug/Makefile:","\t3: THIS_MAKEFILE_PATH:=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))","\t4: THIS_DIR:=$(shell cd $(dir $(THIS_MAKEFILE_PATH));pwd)","",""]},{"start":{"row":4097,"column":0},"end":{"row":4103,"column":0},"action":"insert","lines":["/node_modules/body-parser/node_modules/depd/index.js:","\t13: var relative = require('path').relative","\t22:  * Get the path to base files on.","\t25: var basePath = process.cwd()","\t357:   return relative(basePath, callSite[0])","",""]},{"start":{"row":4103,"column":0},"end":{"row":4106,"column":0},"action":"insert","lines":["/node_modules/body-parser/node_modules/iconv-lite/lib/extend-node.js:","\t29:             // Fastpath empty strings","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":4106,"column":0},"end":{"row":4109,"column":0},"action":"insert","lines":["/node_modules/body-parser/node_modules/type-is/node_modules/mime-types/index.js:","\t21:   // remove any leading paths, though we should just use path.basename","",""]},{"start":{"row":4109,"column":0},"end":{"row":4112,"column":0},"action":"insert","lines":["/node_modules/body-parser/node_modules/type-is/node_modules/mime-types/README.md:","\t40: ### mime.lookup(path)","",""]},{"start":{"row":4112,"column":0},"end":{"row":4117,"column":0},"action":"insert","lines":["/node_modules/body-parser/node_modules/type-is/node_modules/mime-types/node_modules/mime-db/db.json:","\t785:   \"application/pkix-pkipath\": {","\t787:     \"extensions\": [\"pkipath\"]","\t2113:   \"application/vnd.innopath.wamp.notification\": {","",""]},{"start":{"row":4117,"column":0},"end":{"row":4122,"column":0},"action":"insert","lines":["/node_modules/express-session/index.js:","\t148:     // pathname mismatch","\t149:     var originalPath = parseUrl.original(req).pathname;","\t150:     if (0 != originalPath.indexOf(cookie.path || '/')) return next();","",""]},{"start":{"row":4122,"column":0},"end":{"row":4128,"column":0},"action":"insert","lines":["/node_modules/express-session/README.md:","\t37: The default value is `{ path: '/', httpOnly: true, secure: false, maxAge: null }`.","\t312:   // get the url pathname","\t313:   var pathname = parseurl(req).pathname","\t316:   views[pathname] = (views[pathname] || 0) + 1","",""]},{"start":{"row":4128,"column":0},"end":{"row":4131,"column":0},"action":"insert","lines":["/node_modules/express-session/node_modules/cookie/index.js:","\t24:     if (opt.path) pairs.push('Path=' + opt.path);","",""]},{"start":{"row":4131,"column":0},"end":{"row":4135,"column":0},"action":"insert","lines":["/node_modules/express-session/node_modules/cookie/README.md:","\t27: ### path","\t28: > cookie path","",""]},{"start":{"row":4135,"column":0},"end":{"row":4138,"column":0},"action":"insert","lines":["/node_modules/express-session/node_modules/debug/History.md:","\t48:   * Makefile: find node path using shell/which (#109, @timoxley)","",""]},{"start":{"row":4138,"column":0},"end":{"row":4142,"column":0},"action":"insert","lines":["/node_modules/express-session/node_modules/debug/Makefile:","\t3: THIS_MAKEFILE_PATH:=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))","\t4: THIS_DIR:=$(shell cd $(dir $(THIS_MAKEFILE_PATH));pwd)","",""]},{"start":{"row":4142,"column":0},"end":{"row":4148,"column":0},"action":"insert","lines":["/node_modules/express-session/node_modules/depd/index.js:","\t13: var relative = require('path').relative","\t22:  * Get the path to base files on.","\t25: var basePath = process.cwd()","\t357:   return relative(basePath, callSite[0])","",""]},{"start":{"row":4148,"column":0},"end":{"row":4152,"column":0},"action":"insert","lines":["/node_modules/express-session/node_modules/parseurl/HISTORY.md:","\t12:   * Simplify the \"fast-path\" `RegExp`","\t32:   * Incorporate URL href-only parse fast-path","",""]},{"start":{"row":4152,"column":0},"end":{"row":4164,"column":0},"action":"insert","lines":["/node_modules/express-session/node_modules/parseurl/index.js:","\t17:  * Pattern for a simple path case.","\t21: var simplePathRegExp = /^(\\/\\/?(?!\\/)[^\\?#\\s]*)(\\?[^#\\s]*)?$/","\t91:  * Parse the `str` url with fast-path short-cut.","\t99:   // Try fast path regexp","\t101:   var simplePath = typeof str === 'string' && simplePathRegExp.exec(str)","\t104:   if (simplePath) {","\t105:     var pathname = simplePath[1]","\t106:     var search = simplePath[2] || null","\t110:     url.path = str","\t112:     url.pathname = pathname","",""]},{"start":{"row":4164,"column":0},"end":{"row":4168,"column":0},"action":"insert","lines":["/node_modules/express-session/node_modules/parseurl/README.md:","\t56: > node benchmark/pathquery.js","\t80: > node benchmark/simplepath.js","",""]},{"start":{"row":4168,"column":0},"end":{"row":4172,"column":0},"action":"insert","lines":["/node_modules/express-session/session/cookie.js:","\t25:   this.path = '/';","\t103:       , path: this.path","",""]},{"start":{"row":4172,"column":0},"end":{"row":4173,"column":0},"action":"insert","lines":["/node_modules/express/History.md:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":4173,"column":0},"end":{"row":4221,"column":0},"action":"insert","lines":["\t24:   * Fix handling of URLs containing `://` in the path","\t38:   * Use `path.resolve` in view lookup","\t73:   * Fix using same param name in array of paths","\t113:   * Fix regression for empty string `path` in `app.use`","\t114:   * Fix `router.use` to accept array of middleware without path","\t120:   * Fix `app.use` to accept array of middleware without path","\t171:     - Fix a path traversal issue when using `root`","\t172:     - Fix malicious path detection for empty string path","\t235:     - accepts a file system path instead of a URL","\t236:     - requires an absolute path or `root` option specified","\t311:     - Simplify the \"fast-path\" `RegExp`","\t325:   * fix `subapp.mountpath` regression for `app.use(subapp)`","\t337:   * support non-string `path` in `app.use(path, fn)`","\t338:     - supports array of paths","\t351:   * deps: path-to-regexp@0.1.3","\t480:  * revert \"fix behavior of multiple `app.VERB` for the same path\"","\t486:  * add `req.baseUrl` to access the path stripped from `req.url` in routes","\t487:  * fix behavior of multiple `app.VERB` for the same path","\t551:    - Include file path in etag","\t556:    - Support multiple index paths","\t560:    - Resolve relative paths at middleware setup","\t583:    - `app.route` -> `app.mountpath` when mounting an express app in another express app","\t592:    - [path-to-regexp](https://github.com/component/path-to-regexp)","\t602:     - Fix handling of URLs containing `://` in the path","\t767:     - Fix a path traversal issue when using `root`","\t768:     - Fix malicious path detection for empty string path","\t932:     - Simplify the \"fast-path\" `RegExp`","\t1217:  * throw 400 in case of malformed paths @rlidwka","\t1352:   * add app.VERB() paths array deprecation warning","\t1444:   * change `res.redirect()` to utilize a pathname-relative Location again. Closes #1382","\t1621:   * Added `req.path`","\t1643:   * Added `app.path()`","\t1722:   * Added  shorthand for the parsed request's pathname via `req.path`","\t1726:   * Fixed absolute path checking on windows. Closes #829 [reported by andrewpmckenzie]","\t1738:   * Added \"basepath\" setting to work in conjunction with reverse proxies etc.","\t1757:   * Fixed `options.filename`, exposing the view path to template engines","\t1772:   * Changed: when cookie `path === null` don't default it","\t1773:   * Changed; default cookie path to \"home\" setting. Closes #731","\t1893:   * Added `layout(path)` helper to change the layout within a view. Closes #610","\t1909:   * Added `app.VERB(path)` as alias of `app.lookup.VERB()`.","\t1933:   * Fixed up index view path alternative.","\t2086:   * Performance; caching view path derived partial object names","\t2123:   * Fixed `res.sendfile()` responding with 403 on malicious path","\t2158:     Use _req.params_ for path captures, _req.query_ for GET params.","\t2171:   * Added support for absolute view paths","\t2355:   * Added Request#pass() support (finds the next matching route, or the given path)","\t2381:   * Removed extname() / basename() utils. Use path module","",""]},{"start":{"row":4221,"column":0},"end":{"row":4224,"column":0},"action":"insert","lines":["/node_modules/express/package.json:","\t70:     \"path-to-regexp\": \"0.1.3\",","",""]},{"start":{"row":4224,"column":0},"end":{"row":4252,"column":0},"action":"insert","lines":["/node_modules/express/lib/application.js:","\t16: var resolve = require('path').resolve;","\t90:   this.mountpath = '/';","\t154:   var path = '/';","\t156:   // default path to '/'","\t165:     // first arg is the path","\t168:       path = fn;","\t184:       return router.use(path, fn);","\t187:     debug('.use app under %s', path);","\t188:     fn.mountpath = path;","\t192:     router.use(path, function mounted_app(req, res, next) {","\t210:  * Returns a new `Route` instance for the _path_.","\t212:  * Routes are isolated middleware stacks for specific paths.","\t218: app.route = function route(path) {","\t219:   return this.router.route(path);","\t240:  * the same signature that Express expects: `(path, options, callback)`,","\t331:  * Return the app's absolute pathname","\t344: app.path = function(){","\t346:     ? this.parent.path() + this.mountpath","\t417:   app[method] = function(path){","\t418:     if ('get' == method && 1 == arguments.length) return this.set(path);","\t420:     var route = this.route(path);","\t427:  * Special-cased \"all\" method, applying the given route `path`,","\t430:  * @param {String} path","\t436: app.all = function(path){","\t437:   var route = this.route(path);","\t501:     if (!view.path) {","",""]},{"start":{"row":4252,"column":0},"end":{"row":4257,"column":0},"action":"insert","lines":["/node_modules/express/lib/request.js:","\t362:  * Short-hand for `url.parse(req.url).pathname`.","\t368: defineGetter(req, 'path', function path() {","\t369:   return parse(this).pathname;","",""]},{"start":{"row":4257,"column":0},"end":{"row":4280,"column":0},"action":"insert","lines":["/node_modules/express/lib/response.js:","\t11: var path = require('path');","\t20: var extname = path.extname;","\t22: var resolve = path.resolve;","\t301:  * Transfer the file at the given `path`.","\t341: res.sendFile = function sendFile(path, options, fn) {","\t346:   if (!path) {","\t347:     throw new TypeError('path argument is required to res.sendFile');","\t358:   if (!options.root && !isAbsolute(path)) {","\t359:     throw new TypeError('path must be absolute or specify root to res.sendFile');","\t363:   var pathname = encodeURI(path);","\t364:   var file = send(req, pathname, options);","\t379:  * Transfer the file at the given `path` as an attachment.","\t391: res.download = function download(path, filename, fn) {","\t398:   filename = filename || path;","\t405:   // Resolve the full path for sendFile","\t406:   var fullPath = resolve(path);","\t408:   return this.sendFile(fullPath, { headers: headers }, fn);","\t595:   var opts = { expires: new Date(1), path: '/' };","\t608:  *    - `path`     defaults to \"/\"","\t637:   if (null == options.path) options.path = '/';","\t687:  * it will play nicely with mounted apps, relative paths,","",""]},{"start":{"row":4280,"column":0},"end":{"row":4288,"column":0},"action":"insert","lines":["/node_modules/express/lib/utils.js:","\t47:  * Check if `path` looks absolute.","\t49:  * @param {String} path","\t54: exports.isAbsolute = function(path){","\t55:   if ('/' == path[0]) return true;","\t56:   if (':' == path[1] && '\\\\' == path[2]) return true;","\t57:   if ('\\\\\\\\' == path.substring(0, 2)) return true; // Microsoft Azure absolute path","",""]},{"start":{"row":4288,"column":0},"end":{"row":4318,"column":0},"action":"insert","lines":["/node_modules/express/lib/view.js:","\t6: var path = require('path');","\t15: var dirname = path.dirname;","\t16: var basename = path.basename;","\t17: var extname = path.extname;","\t18: var join = path.join;","\t19: var resolve = path.resolve;","\t34:  *   - `root` root path for view lookup","\t51:   this.path = this.lookup(name);","\t63:   var path;","\t68:   for (var i = 0; i < roots.length && !path; i++) {","\t71:     // resolve the path","\t77:     path = this.resolve(dir, file);","\t80:   return path;","\t92:   debug('render \"%s\"', this.path);","\t93:   this.engine(this.path, options, fn);","\t106:   var path;","\t109:   // <path>.<ext>","\t110:   path = join(dir, file);","\t111:   stat = tryStat(path);","\t114:     return path;","\t117:   // <path>/index.<ext>","\t118:   path = join(dir, basename(file, ext), 'index' + ext);","\t119:   stat = tryStat(path);","\t122:     return path;","\t129:  * @param {string} path","\t134: function tryStat(path) {","\t135:   debug('stat \"%s\"', path);","\t138:     return fs.statSync(path);","",""]},{"start":{"row":4318,"column":0},"end":{"row":4354,"column":0},"action":"insert","lines":["/node_modules/express/lib/router/index.js:","\t128:   var pathlength = search ? search - 1 : req.url.length;","\t129:   var fqdn = req.url[0] !== '/' && 1 + req.url.substr(0, pathlength).indexOf('://');","\t189:     self.match_layer(layer, req, res, function (err, path) {","\t190:       if (err || path === undefined) {","\t225:       var layerPath = layer.path;","\t237:         trim_prefix(layer, layerError, layerPath, path);","\t242:   function trim_prefix(layer, layerError, layerPath, path) {","\t243:     var c = path[layerPath.length];","\t247:      // middleware (.use stuff) needs to have the path stripped","\t248:     if (layerPath.length !== 0) {","\t249:       debug('trim prefix (%s) from url %s', layerPath, req.url);","\t250:       removed = layerPath;","\t265:     debug('%s %s : %s', layer.name, layerPath, req.originalUrl);","\t283:   var path;","\t286:     path = parseUrl(req).pathname;","\t288:     if (!layer.match(path)) {","\t289:       path = undefined;","\t295:   done(error, path);","\t395:  * Use the given middleware function, with optional path, defaulting to \"/\".","\t401:  * The other difference is that _route_ path is stripped and not visible","\t404:  * pathname.","\t411:   var path = '/';","\t413:   // default path to '/'","\t422:     // first arg is the path","\t425:       path = fn;","\t441:     debug('use %s %s', path, fn.name || '<anonymous>');","\t443:     var layer = new Layer(path, {","\t458:  * Create a new Route for the given path.","\t465:  * @param {String} path","\t470: proto.route = function(path){","\t471:   var route = new Route(path);","\t473:   var layer = new Layer(path, {","\t487:   proto[method] = function(path){","\t488:     var route = this.route(path)","",""]},{"start":{"row":4354,"column":0},"end":{"row":4374,"column":0},"action":"insert","lines":["/node_modules/express/lib/router/layer.js:","\t5: var pathRegexp = require('path-to-regexp');","\t20: function Layer(path, options, fn) {","\t22:     return new Layer(path, options, fn);","\t25:   debug('new %s', path);","\t31:   this.path = undefined;","\t32:   this.regexp = pathRegexp(path, this.keys = [], options);","\t34:   if (path === '/' && options.end === false) {","\t89:  * Check if this route matches `path`, if so","\t92:  * @param {String} path","\t97: Layer.prototype.match = function match(path) {","\t98:   if (path == null) {","\t99:     // no path, nothing matches","\t101:     this.path = undefined;","\t106:     // fast path non-ending match for / (everything matches)","\t108:     this.path = '';","\t112:   var m = this.regexp.exec(path);","\t116:     this.path = undefined;","\t122:   this.path = m[0];","",""]},{"start":{"row":4374,"column":0},"end":{"row":4378,"column":0},"action":"insert","lines":["/node_modules/express/lib/router/match.js:","\t8: function Match(layer, path, params) {","\t11:   this.path = path || '';","",""]},{"start":{"row":4378,"column":0},"end":{"row":4386,"column":0},"action":"insert","lines":["/node_modules/express/lib/router/route.js:","\t17:  * Initialize `Route` with the given `path`,","\t19:  * @param {String} path","\t23: function Route(path) {","\t24:   debug('new %s', path);","\t25:   this.path = path;","\t163:       debug('%s %s', method, this.path);","",""]},{"start":{"row":4386,"column":0},"end":{"row":4389,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/accepts/node_modules/mime-types/index.js:","\t21:   // remove any leading paths, though we should just use path.basename","",""]},{"start":{"row":4389,"column":0},"end":{"row":4392,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/accepts/node_modules/mime-types/README.md:","\t40: ### mime.lookup(path)","",""]},{"start":{"row":4392,"column":0},"end":{"row":4397,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/accepts/node_modules/mime-types/node_modules/mime-db/db.json:","\t785:   \"application/pkix-pkipath\": {","\t787:     \"extensions\": [\"pkipath\"]","\t2113:   \"application/vnd.innopath.wamp.notification\": {","",""]},{"start":{"row":4397,"column":0},"end":{"row":4400,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/content-disposition/index.js:","\t18: var basename = require('path').basename","",""]},{"start":{"row":4400,"column":0},"end":{"row":4405,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/content-disposition/README.md:","\t94: var filePath = '/path/to/public/plans.pdf'","\t99:   res.setHeader('Content-Disposition', contentDisposition(filePath))","\t102:   var stream = fs.createReadStream(filePath)","",""]},{"start":{"row":4405,"column":0},"end":{"row":4408,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/cookie/index.js:","\t24:     if (opt.path) pairs.push('Path=' + opt.path);","",""]},{"start":{"row":4408,"column":0},"end":{"row":4412,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/cookie/README.md:","\t27: ### path","\t28: > cookie path","",""]},{"start":{"row":4412,"column":0},"end":{"row":4415,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/debug/History.md:","\t48:   * Makefile: find node path using shell/which (#109, @timoxley)","",""]},{"start":{"row":4415,"column":0},"end":{"row":4419,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/debug/Makefile:","\t3: THIS_MAKEFILE_PATH:=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))","\t4: THIS_DIR:=$(shell cd $(dir $(THIS_MAKEFILE_PATH));pwd)","",""]},{"start":{"row":4419,"column":0},"end":{"row":4425,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/depd/index.js:","\t13: var relative = require('path').relative","\t22:  * Get the path to base files on.","\t25: var basePath = process.cwd()","\t357:   return relative(basePath, callSite[0])","",""]},{"start":{"row":4425,"column":0},"end":{"row":4428,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/etag/HISTORY.md:","\t43:   * Add fast-path for empty entity","",""]},{"start":{"row":4428,"column":0},"end":{"row":4432,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/etag/index.js:","\t132:     // fast-path empty","\t152:     // fast-path empty","",""]},{"start":{"row":4432,"column":0},"end":{"row":4436,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/parseurl/HISTORY.md:","\t12:   * Simplify the \"fast-path\" `RegExp`","\t32:   * Incorporate URL href-only parse fast-path","",""]},{"start":{"row":4436,"column":0},"end":{"row":4448,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/parseurl/index.js:","\t17:  * Pattern for a simple path case.","\t21: var simplePathRegExp = /^(\\/\\/?(?!\\/)[^\\?#\\s]*)(\\?[^#\\s]*)?$/","\t91:  * Parse the `str` url with fast-path short-cut.","\t99:   // Try fast path regexp","\t101:   var simplePath = typeof str === 'string' && simplePathRegExp.exec(str)","\t104:   if (simplePath) {","\t105:     var pathname = simplePath[1]","\t106:     var search = simplePath[2] || null","\t110:     url.path = str","\t112:     url.pathname = pathname","",""]},{"start":{"row":4448,"column":0},"end":{"row":4452,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/parseurl/README.md:","\t56: > node benchmark/pathquery.js","\t80: > node benchmark/simplepath.js","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":4452,"column":0},"end":{"row":4456,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/path-to-regexp/component.json:","\t2:   \"name\": \"path-to-regexp\",","\t3:   \"description\": \"Express style path to RegExp utility\",","",""]},{"start":{"row":4456,"column":0},"end":{"row":4473,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/path-to-regexp/index.js:","\t2:  * Expose `pathtoRegexp`.","\t5: module.exports = pathtoRegexp;","\t8:  * Normalize the given path string,","\t16:  * @param  {String|RegExp|Array} path","\t23: function pathtoRegexp(path, keys, options) {","\t30:   if (path instanceof RegExp) {","\t31:     return path;","\t34:   if (Array.isArray(path)) {","\t38:     path = path.map(function (value) {","\t39:       return pathtoRegexp(value, keys, options).source;","\t42:     return new RegExp('(?:' + path.join('|') + ')', flags);","\t45:   path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))","\t66:   // If the path is non-ending, match until the end or a slash.","\t67:   path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\\\/|$)'));","\t69:   return new RegExp(path, flags);","",""]},{"start":{"row":4473,"column":0},"end":{"row":4485,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/path-to-regexp/package.json:","\t2:   \"name\": \"path-to-regexp\",","\t3:   \"description\": \"Express style path to RegExp utility\",","\t14:       \"path-to-regexp\": \"index.js\"","\t19:     \"url\": \"https://github.com/component/path-to-regexp.git\"","\t26:     \"url\": \"https://github.com/component/path-to-regexp/issues\"","\t28:   \"homepage\": \"https://github.com/component/path-to-regexp\",","\t29:   \"_id\": \"path-to-regexp@0.1.3\",","\t31:   \"_from\": \"path-to-regexp@0.1.3\",","\t157:     \"tarball\": \"http://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.3.tgz\"","\t160:   \"_resolved\": \"https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.3.tgz\",","",""]},{"start":{"row":4485,"column":0},"end":{"row":4493,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/path-to-regexp/Readme.md:","\t2: # Path-to-RegExp","\t4:   Turn an Express-style path string such as `/user/:name` into a regular expression.","\t9: var pathToRegexp = require('path-to-regexp');","\t11: ### pathToRegexp(path, keys, options)","\t13:  - **path** A string in the express format, an array of such strings, or a regular expression","\t22: var exp = pathToRegexp('/foo/:bar', keys);","",""]},{"start":{"row":4493,"column":0},"end":{"row":4494,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/path-to-regexp/test.js:",""]},{"start":{"row":4494,"column":0},"end":{"row":4535,"column":0},"action":"insert","lines":["\t1: var pathToRegExp = require('./');","\t4: describe('path-to-regexp', function () {","\t6:     it('should match simple paths', function () {","\t8:       var m = pathToRegExp('/test', params).exec('/test');","\t18:       var m = pathToRegExp('/:test', params).exec('/pathname');","\t25:       assert.equal(m[0], '/pathname');","\t26:       assert.equal(m[1], 'pathname');","\t31:       var re = pathToRegExp('/:test', params, { strict: true });","\t51:       var re = pathToRegExp('/:test/', params, { strict: true });","\t75:       var re = pathToRegExp('/:test?', params);","\t97:       var m = pathToRegExp('/:page(\\\\d+)', params).exec('/56');","\t110:       var m = pathToRegExp(':test', params).exec('string');","\t123:       var m = pathToRegExp('/:test.json', params).exec('/route.json');","\t136:       var re = pathToRegExp('/:test.:format', params);","\t159:       var m = pathToRegExp('/:test.json', params).exec('/route.json');","\t172:       var m = pathToRegExp('/test*', params).exec('/test/route');","\t183:       var re = pathToRegExp('/:test*', params);","\t207:       var re = pathToRegExp('/test*.json', params);","\t233:       var re = pathToRegExp('/:test*.json', params);","\t261:       var re = pathToRegExp('/:test*.:format', params);","\t297:       var re = pathToRegExp('/:test*.:format?', params);","\t337:       var re = pathToRegExp('/:test*?', params);","\t367:       var m = pathToRegExp('/test').exec('/TEST');","\t373:       var re = pathToRegExp('/test', null, { sensitive: true });","\t388:       var m = pathToRegExp('/:test', params, { end: false }).exec('/test/route');","\t401:       var re = pathToRegExp('/:test', params, { end: false });","\t417:       var re = pathToRegExp('/route/', params, { end: false });","\t445:       var re = pathToRegExp('/route/', params, { end: false, strict: true });","\t471:       var re = pathToRegExp('/route', params, { end: false, strict: true });","\t488:       var re = pathToRegExp('/(:test)route', params);","\t511:       var re = pathToRegExp('/(:test?)route', params);","\t537:       var re = pathToRegExp('/:test.:format?', params);","\t561:     it('should match full paths with format by default', function () {","\t563:       var m = pathToRegExp('/:test', params).exec('/test.json');","\t577:       assert.deepEqual(pathToRegExp(/.*/), /.*/);","\t583:       var re = pathToRegExp(['/test', '/route']);","\t592:       var re = pathToRegExp(['/:test', '/test/:route'], params);","\t608:       m = re.exec('/test/path');","\t611:       assert.equal(m[0], '/test/path');","\t613:       assert.equal(m[2], 'path');","",""]},{"start":{"row":4535,"column":0},"end":{"row":4541,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/send/History.md:","\t45:   * Fix malicious path detection for empty string path","\t50:   * Fix a path traversal issue when using `root`","\t169:  * Include file path in etag","\t173:  * Support multiple index paths","",""]},{"start":{"row":4541,"column":0},"end":{"row":4542,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/send/index.js:",""]},{"start":{"row":4542,"column":0},"end":{"row":4634,"column":0},"action":"insert","lines":["\t14:   , path = require('path')","\t17:   , normalize = path.normalize","\t18:   , join = path.join","\t27: var extname = path.extname","\t29: var resolve = path.resolve","\t30: var sep = path.sep","\t32: var upPathRegexp = /(?:^|[\\\\\\/])\\.\\.(?:[\\\\\\/]|$)/","\t55:  * Return a `SendStream` for `req` and `path`.","\t58:  * @param {String} path","\t64: function send(req, path, options) {","\t65:   return new SendStream(req, path, options);","\t69:  * Initialize a `SendStream` with the given `path`.","\t72:  * @param {String} path","\t77: function SendStream(req, path, options) {","\t81:   this.path = path;","\t160:  * @param {Boolean} path","\t174:  * Set index `paths`, set to a falsy","\t177:  * @param {String|Boolean|Array} paths","\t182: SendStream.prototype.index = deprecate.function(function index(paths) {","\t183:   var index = !paths ? [] : normalizeList(paths);","\t184:   debug('index %o', paths);","\t190:  * Set root `path`.","\t192:  * @param {String} path","\t197: SendStream.prototype.root = function(path){","\t198:   path = String(path);","\t199:   this._root = resolve(path)","\t255:  * Check if the pathname ends with \"/\".","\t262:   return '/' == this.path[this.path.length - 1];","\t373:  * Redirect to `path`.","\t375:  * @param {String} path","\t379: SendStream.prototype.redirect = function(path){","\t386:   path += '/';","\t389:   res.setHeader('Location', path);","\t390:   res.end('Redirecting to <a href=\"' + escapeHtml(path) + '\">' + escapeHtml(path) + '</a>\\n');","\t409:   // decode the path","\t410:   var path = decode(this.path)","\t411:   if (path === -1) return this.error(400)","\t414:   if (~path.indexOf('\\0')) return this.error(400);","\t419:     path = normalize(join(root, path))","\t422:     // malicious path","\t423:     if ((path + sep).substr(0, root.length) !== root) {","\t424:       debug('malicious path \"%s\"', path)","\t428:     // explode path parts","\t429:     parts = path.substr(root.length).split(sep)","\t432:     if (upPathRegexp.test(path)) {","\t433:       debug('malicious path \"%s\"', path)","\t437:     // explode path parts","\t438:     parts = normalize(path).split(sep)","\t440:     // resolve the path","\t441:     path = resolve(path)","\t455:     debug('%s dotfile \"%s\"', access, path)","\t468:   if (this._index.length && this.path[this.path.length - 1] === '/') {","\t469:     this.sendIndex(path);","\t473:   this.sendFile(path);","\t478:  * Transfer `path`.","\t480:  * @param {String} path","\t484: SendStream.prototype.send = function(path, stat){","\t497:   debug('pipe \"%s\"', path)","\t500:   this.setHeader(path, stat);","\t503:   this.type(path);","\t561:   this.stream(path, options);","\t565:  * Transfer file for `path`.","\t567:  * @param {String} path","\t570: SendStream.prototype.sendFile = function sendFile(path) {","\t574:   debug('stat \"%s\"', path);","\t575:   fs.stat(path, function onstat(err, stat) {","\t577:       && !extname(path)","\t578:       && path[path.length - 1] !== sep) {","\t583:     if (stat.isDirectory()) return self.redirect(self.path)","\t584:     self.emit('file', path, stat)","\t585:     self.send(path, stat)","\t595:     var p = path + '.' + self._extensions[i++]","\t608:  * Transfer index for `path`.","\t610:  * @param {String} path","\t613: SendStream.prototype.sendIndex = function sendIndex(path){","\t623:     var p = join(path, self._index[i]);","\t638:  * Stream `path` to the response.","\t640:  * @param {String} path","\t645: SendStream.prototype.stream = function(path, options){","\t653:   var stream = fs.createReadStream(path, options);","\t683:  * Set content-type based on `path`","\t686:  * @param {String} path","\t690: SendStream.prototype.type = function(path){","\t693:   var type = mime.lookup(path);","\t703:  * @param {String} path","\t708: SendStream.prototype.setHeader = function setHeader(path, stat){","\t711:   this.emit('headers', res, path, stat);","\t731:  * Determine if path parts contain a dotfile.","\t752:  * @param {String} path","\t756: function decode(path) {","\t758:     return decodeURIComponent(path)","",""]},{"start":{"row":4634,"column":0},"end":{"row":4647,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/send/Readme.md:","\t24: ### send(req, path, [options])","\t26: Create a new `SendStream` for the given path to send to a `res`. The `req` is","\t27: the Node.js HTTP request and the `path` is a urlencoded path to send (urlencoded,","\t28: not the actual file-system path).","\t36:   the path itself without checking if the path actually exists on the","\t77:   Serve files relative to `path`.","\t85:   - `file` a file was requested `(path, stat)`","\t86:   - `headers` the headers are about to be set on a file `(res, path, stat)`","\t93: object, typically `send(req, path, options).pipe(res)`.","\t147:   function headers(res, path, stat) {","\t161:   send(req, url.parse(req.url).pathname, {root: '/www/example.com/public'})","",""]},{"start":{"row":4647,"column":0},"end":{"row":4655,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/send/node_modules/mime/mime.js:","\t1: var path = require('path');","\t47:  * @param file (String) path of file to load.","\t71: Mime.prototype.lookup = function(path, fallback) {","\t72:   var ext = path.replace(/.*[\\.\\/\\\\]/, '').toLowerCase();","\t90: mime.load(path.join(__dirname, 'types/mime.types'));","\t93: mime.load(path.join(__dirname, 'types/node.types'));","",""]},{"start":{"row":4655,"column":0},"end":{"row":4661,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/send/node_modules/mime/README.md:","\t13: ### mime.lookup(path)","\t14: Get the mime type associated with a file, if no mime type is found `application/octet-stream` is returned. Performs a case-insensitive lookup using the extension in `path` (the substring after the last '/' or '.').  E.g.","\t18:     mime.lookup('/path/to/file.txt');         // => 'text/plain'","\t60: ### mime.load(filepath)","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":4661,"column":0},"end":{"row":4706,"column":0},"action":"insert","lines":["/node_modules/express/node_modules/send/node_modules/mime/test.js:","\t7: var path = require('path');","\t70: apacheTypes.load(path.join(__dirname, 'types/mime.types'));","\t71: nodeTypes.load(path.join(__dirname, 'types/node.types'));","","/node_modules/express/node_modules/send/node_modules/mime/types/mime.types:","\t177: application/pkix-pkipath\t\t\tpkipath","\t490: # application/vnd.innopath.wamp.notification","","/node_modules/express/node_modules/serve-static/HISTORY.md:","\t57:     - Fix a path traversal issue when using `root`","\t58:     - Fix malicious path detection for empty string path","\t114:     - Simplify the \"fast-path\" `RegExp`","\t185:   * Resolve relative paths at middleware setup","","/node_modules/express/node_modules/serve-static/index.js:","\t16: var resolve = require('path').resolve;","\t29:     throw new TypeError('root path required')","\t33:     throw new TypeError('root path must be a string')","\t64:     var path = parseurl(req).pathname","\t65:     var hasTrailingSlash = originalUrl.pathname[originalUrl.pathname.length - 1] === '/'","\t67:     if (path === '/' && !hasTrailingSlash) {","\t69:       path = ''","\t73:     var stream = send(req, path, opts)","\t83:         originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/')","","/node_modules/express/node_modules/serve-static/README.md:","\t35: the path itself without checking if the path actually exists on the","\t77: Redirect to trailing \"/\" when the pathname is a dir. Defaults to `true`.","\t82: occur synchronously. The function is called as `fn(res, path, stat)`, where","\t86:   - `path` the file path that is being sent","\t126: function setHeaders(res, path) {","\t127:   res.setHeader('Content-Disposition', contentDisposition(path))","","/node_modules/express/node_modules/type-is/node_modules/mime-types/index.js:","\t21:   // remove any leading paths, though we should just use path.basename","","/node_modules/express/node_modules/type-is/node_modules/mime-types/README.md:","\t40: ### mime.lookup(path)","","/node_modules/express/node_modules/type-is/node_modules/mime-types/node_modules/mime-db/db.json:","\t785:   \"application/pkix-pkipath\": {","\t787:     \"extensions\": [\"pkipath\"]","\t2113:   \"application/vnd.innopath.wamp.notification\": {","",""]},{"start":{"row":4706,"column":0},"end":{"row":4711,"column":0},"action":"insert","lines":["/node_modules/jade/History.md:","\t16:   * Clean up path/fs functions in CLI as we no longer support node@0.6 ([@TimothyGu](https://github.com/TimothyGu))","\t281:   * add support for 'include' and 'extends' to use paths relative to basedir","\t527:   * Added  -p, --path <path> flag to jade(1)","",""]},{"start":{"row":4711,"column":0},"end":{"row":4712,"column":0},"action":"insert","lines":["/node_modules/jade/jade.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":4712,"column":0},"end":{"row":4801,"column":0},"action":"insert","lines":["\t1050:  * @param {String} path","\t1055: exports.compileFile = function (path, options) {","\t1057:   options.filename = path;","\t1102:  * Render a Jade file at the given `path`.","\t1104:  * @param {String} path","\t1111: exports.renderFile = function(path, options, fn){","\t1119:       res = exports.renderFile(path, options);","\t1128:   options.filename = path;","\t1134:  * Compile a Jade file at the given `path` for use on the client.","\t1136:  * @param {String} path","\t1142: exports.compileFileClient = function(path, options){","\t1143:   var key = path + ':client';","\t1146:   options.filename = path;","\t1596:         throw new Error('missing path for include:filter');","\t1599:       var path = captures[1];","\t1600:       var tok = this.tok('include', path);","\t2749: var path = require('path');","\t2752: var extname = path.extname;","\t3191:    * Resolves a path relative to the template for use in","\t3194:    * @param {String}  path","\t3200:   resolvePath: function (path, purpose) {","\t3201:     var p = require('path');","\t3206:     if (path[0] !== '/' && !this.filename)","\t3207:       throw new Error('the \"filename\" option is required to use \"' + purpose + '\" with \"relative\" paths');","\t3209:     if (path[0] === '/' && !this.options.basedir)","\t3210:       throw new Error('the \"basedir\" option is required to use \"' + purpose + '\" with \"absolute\" paths');","\t3212:     path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename), path);","\t3214:     if (basename(path).indexOf('.') === -1) path += '.jade';","\t3216:     return path;","\t3226:     var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');","\t3227:     if ('.jade' != path.substr(-5)) path += '.jade';","\t3229:     this.dependencies.push(path);","\t3230:     var str = fs.readFileSync(path, 'utf8');","\t3231:     var parser = new this.constructor(str, path, this.options);","\t3306:     var path = this.resolvePath(tok.val.trim(), 'include');","\t3307:     this.dependencies.push(path);","\t3310:       var str = fs.readFileSync(path, 'utf8').replace(/\\r/g, '');","\t3311:       var options = {filename: path};","\t3322:     if ('.jade' != path.substr(-5)) {","\t3323:       var str = fs.readFileSync(path, 'utf8').replace(/\\r/g, '');","\t3327:     var str = fs.readFileSync(path, 'utf8');","\t3328:     var parser = new this.constructor(str, path, this.options);","\t3339:     ast.filename = path;","\t3569: },{\"./filters\":3,\"./lexer\":6,\"./nodes\":16,\"./utils\":25,\"character-parser\":29,\"constantinople\":30,\"fs\":26,\"path\":27}],24:[function(require,module,exports){","\t3797:   err.path = filename;","\t3883: // resolves . and .. elements in a path array with directory names there","\t3886: // relative and absolute paths)","\t3888:   // if the path tries to go above the root, `up` ends up > 0","\t3903:   // if the path is allowed to go above the root, restore leading ..s","\t3915: var splitPathRe =","\t3917: var splitPath = function(filename) {","\t3918:   return splitPathRe.exec(filename).slice(1);","\t3921: // path.resolve([from ...], to)","\t3924:   var resolvedPath = '',","\t3928:     var path = (i >= 0) ? arguments[i] : process.cwd();","\t3931:     if (typeof path !== 'string') {","\t3932:       throw new TypeError('Arguments to path.resolve must be strings');","\t3933:     } else if (!path) {","\t3937:     resolvedPath = path + '/' + resolvedPath;","\t3938:     resolvedAbsolute = path.charAt(0) === '/';","\t3941:   // At this point the path should be resolved to a full absolute path, but","\t3942:   // handle relative paths to be safe (might happen when process.cwd() fails)","\t3944:   // Normalize the path","\t3945:   resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {","\t3949:   return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';","\t3952: // path.normalize(path)","\t3954: exports.normalize = function(path) {","\t3955:   var isAbsolute = exports.isAbsolute(path),","\t3956:       trailingSlash = substr(path, -1) === '/';","\t3958:   // Normalize the path","\t3959:   path = normalizeArray(filter(path.split('/'), function(p) {","\t3963:   if (!path && !isAbsolute) {","\t3964:     path = '.';","\t3966:   if (path && trailingSlash) {","\t3967:     path += '/';","\t3970:   return (isAbsolute ? '/' : '') + path;","\t3974: exports.isAbsolute = function(path) {","\t3975:   return path.charAt(0) === '/';","\t3980:   var paths = Array.prototype.slice.call(arguments, 0);","\t3981:   return exports.normalize(filter(paths, function(p, index) {","\t3983:       throw new TypeError('Arguments to path.join must be strings');","\t3990: // path.relative(from, to)","\t4036: exports.dirname = function(path) {","\t4037:   var result = splitPath(path),","\t4055: exports.basename = function(path, ext) {","\t4056:   var f = splitPath(path)[2];","\t4065: exports.extname = function(path) {","\t4066:   return splitPath(path)[3];","",""]},{"start":{"row":4801,"column":0},"end":{"row":4805,"column":0},"action":"insert","lines":["/node_modules/jade/Readme_zh-cn.md:","\t1197: \tjade < $< --path $< > $@","\t1224:   -p, --path <path>  在处理 stdio 时，查找包含文件时的查找路径","",""]},{"start":{"row":4805,"column":0},"end":{"row":4809,"column":0},"action":"insert","lines":["/node_modules/jade/release.js:","\t22:       path: info.path.replace(/^\\.\\//, ''),","\t23:       content: fs.readFileSync(info.fullPath)","",""]},{"start":{"row":4809,"column":0},"end":{"row":4812,"column":0},"action":"insert","lines":["/node_modules/jade/runtime.js:","\t229:   err.path = filename;","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":4812,"column":0},"end":{"row":4856,"column":0},"action":"insert","lines":["/node_modules/jade/bin/jade.js:","\t9:   , path = require('path')","\t10:   , basename = path.basename","\t11:   , dirname = path.dirname","\t12:   , resolve = path.resolve","\t13:   , normalize = path.normalize","\t14:   , join = path.join","\t27:   .option('-O, --obj <str|path>', 'JavaScript options object or JSON file containing it')","\t29:   .option('-p, --path <path>', 'filename used to resolve includes')","\t36:   .option('--name-after-file', 'Name the template after the last section of the file path (requires --client and overriden by --name)')","\t84: // --path","\t86: if (program.path) options.filename = program.path;","\t114: // left-over args are file paths","\t118: // array of paths that are being watched","\t143:  * Watch for changes on path","\t145:  * Renders `base` if specified, otherwise renders `path`.","\t147: function watchFile(path, base) {","\t148:   path = normalize(path);","\t149:   if (watchList.indexOf(path) !== -1) return;","\t150:   console.log(\"  \\033[90mwatching \\033[36m%s\\033[0m\", path);","\t151:   fs.watchFile(path, {persistent: true, interval: 200},","\t157:     tryRender(base || path);","\t159:   watchList.push(path);","\t170:  * Try to render `path`; if an exception is thrown it is printed to stderr and","\t175: function tryRender(path) {","\t177:     renderFile(path);","\t212:  * Process the given path, compiling the jade files found.","\t216: function renderFile(path) {","\t218:   var stat = fs.lstatSync(path);","\t220:   if (stat.isFile() && re.test(path)) {","\t221:     if (options.watch) watchFile(path);","\t222:     var str = fs.readFileSync(path, 'utf8');","\t223:     options.filename = path;","\t225:       options.name = getNameFromFileName(path);","\t231:         watchFile(dep, path);","\t240:     path = path.replace(re, extname);","\t241:     if (program.out) path = join(program.out, basename(path));","\t242:     var dir = resolve(dirname(path));","\t245:     fs.writeFileSync(path, output);","\t246:     console.log('  \\033[90mrendered \\033[36m%s\\033[0m', normalize(path));","\t249:     var files = fs.readdirSync(path);","\t251:       return path + '/' + filename;","\t257:  * Get a sensible name for a template function from a file path","",""]},{"start":{"row":4856,"column":0},"end":{"row":4857,"column":0},"action":"insert","lines":["/node_modules/jade/lib/index.js:",""]},{"start":{"row":4857,"column":0},"end":{"row":4871,"column":0},"action":"insert","lines":["\t301:  * @param {String} path","\t306: exports.compileFile = function (path, options) {","\t308:   options.filename = path;","\t353:  * Render a Jade file at the given `path`.","\t355:  * @param {String} path","\t362: exports.renderFile = function(path, options, fn){","\t370:       res = exports.renderFile(path, options);","\t379:   options.filename = path;","\t385:  * Compile a Jade file at the given `path` for use on the client.","\t387:  * @param {String} path","\t393: exports.compileFileClient = function(path, options){","\t394:   var key = path + ':client';","\t397:   options.filename = path;","",""]},{"start":{"row":4871,"column":0},"end":{"row":4876,"column":0},"action":"insert","lines":["/node_modules/jade/lib/lexer.js:","\t408:         throw new Error('missing path for include:filter');","\t411:       var path = captures[1];","\t412:       var tok = this.tok('include', path);","",""]},{"start":{"row":4876,"column":0},"end":{"row":4908,"column":0},"action":"insert","lines":["/node_modules/jade/lib/parser.js:","\t7: var path = require('path');","\t10: var extname = path.extname;","\t449:    * Resolves a path relative to the template for use in","\t452:    * @param {String}  path","\t458:   resolvePath: function (path, purpose) {","\t459:     var p = require('path');","\t464:     if (path[0] !== '/' && !this.filename)","\t465:       throw new Error('the \"filename\" option is required to use \"' + purpose + '\" with \"relative\" paths');","\t467:     if (path[0] === '/' && !this.options.basedir)","\t468:       throw new Error('the \"basedir\" option is required to use \"' + purpose + '\" with \"absolute\" paths');","\t470:     path = join(path[0] === '/' ? this.options.basedir : dirname(this.filename), path);","\t472:     if (basename(path).indexOf('.') === -1) path += '.jade';","\t474:     return path;","\t484:     var path = this.resolvePath(this.expect('extends').val.trim(), 'extends');","\t485:     if ('.jade' != path.substr(-5)) path += '.jade';","\t487:     this.dependencies.push(path);","\t488:     var str = fs.readFileSync(path, 'utf8');","\t489:     var parser = new this.constructor(str, path, this.options);","\t564:     var path = this.resolvePath(tok.val.trim(), 'include');","\t565:     this.dependencies.push(path);","\t568:       var str = fs.readFileSync(path, 'utf8').replace(/\\r/g, '');","\t569:       var options = {filename: path};","\t580:     if ('.jade' != path.substr(-5)) {","\t581:       var str = fs.readFileSync(path, 'utf8').replace(/\\r/g, '');","\t585:     var str = fs.readFileSync(path, 'utf8');","\t586:     var parser = new this.constructor(str, path, this.options);","\t597:     ast.filename = path;","","/node_modules/jade/lib/runtime.js:","\t228:   err.path = filename;","",""]},{"start":{"row":4908,"column":0},"end":{"row":4917,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/commander/index.js:","\t8: var path = require('path');","\t9: var dirname = path.dirname;","\t10: var basename = path.basename;","\t112:  *        .option('-C, --chdir <path>', 'change the working directory')","\t113:  *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')","\t326:  *     program.option('-C, --chdir <path>', 'change the working directory');","\t464:   var local = path.join(dir, bin);","",""]},{"start":{"row":4917,"column":0},"end":{"row":4921,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/commander/Readme.md:","\t237:   .option('-C, --chdir <path>', 'change the working directory')","\t238:   .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')","",""]},{"start":{"row":4921,"column":0},"end":{"row":4925,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/constantinople/node_modules/acorn-globals/node_modules/acorn/bin/acorn:","\t3: var path = require(\"path\");","\t11:   print(\"usage: \" + path.basename(process.argv[1]) + \" [--ecma3|--ecma5|--ecma6] [--strictSemicolons]\");","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":4925,"column":0},"end":{"row":4930,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/constantinople/node_modules/acorn-globals/node_modules/acorn/test/driver.js:","\t70:   function addPath(str, pt) {","\t84:         if (mis) return addPath(mis, i);","\t89:         if (mis) return addPath(mis, prop);","",""]},{"start":{"row":4930,"column":0},"end":{"row":4931,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/constantinople/node_modules/acorn-globals/node_modules/acorn/test/jquery-string.js:",""]},{"start":{"row":4931,"column":0},"end":{"row":4944,"column":0},"action":"insert","lines":["\t835: \\t\\t// QSA path\\n\\","\t3699: \\t\\t// the code to shortcut on the same path as a DOM node with no cache\\n\\","\t3817: \\t\\t\\t\\t// This will only penalize the array argument path.\\n\\","\t4468: \\t\\t\\teventPath = [ elem || document ],\\n\\","\t4521: \\t\\t// Determine event propagation path in advance, per W3C events spec (#9951)\\n\\","\t4530: \\t\\t\\t\\teventPath.push( cur );\\n\\","\t4536: \\t\\t\\t\\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\\n\\","\t4540: \\t\\t// Fire handlers on the event path\\n\\","\t4542: \\t\\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\\n\\","\t4568: \\t\\t\\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\\n\\","\t5451: \\t\\t// This path appears unavoidable for IE9. When cloning an object\\n\\","\t6792: \\t\\t\\t\\t// style.removeAttribute is IE Only, but so apparently is this code path...\\n\\","",""]},{"start":{"row":4944,"column":0},"end":{"row":4948,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/constantinople/node_modules/acorn-globals/node_modules/acorn/test/compare/esprima.js:","\t5052:                 // Try first to convert to a string. This is good as fast path","\t5157:                 // Try first to convert to a string. This is good as fast path","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":4948,"column":0},"end":{"row":4949,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/constantinople/node_modules/acorn-globals/node_modules/acorn/test/compare/traceur.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":4949,"column":0},"end":{"row":5028,"column":0},"action":"insert","lines":["\t602:   function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {","\t617:     if (opt_path) {","\t618:       out.push(opt_path);","\t635:     PATH: 5,","\t642:   function removeDotSegments(path) {","\t643:     if (path === '/')","\t645:     var leadingSlash = path[0] === '/' ? '/' : '';","\t646:     var trailingSlash = path.slice(-1) === '/' ? '/' : '';","\t647:     var segments = path.split('/');","\t675:   function joinAndCanonicalizePath(parts) {","\t676:     var path = parts[ComponentIndex.PATH] || '';","\t677:     path = removeDotSegments(path);","\t678:     parts[ComponentIndex.PATH] = path;","\t679:     return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);","\t683:     return joinAndCanonicalizePath(parts);","\t689:       return joinAndCanonicalizePath(parts);","\t698:     if (parts[ComponentIndex.PATH][0] == '/') {","\t699:       return joinAndCanonicalizePath(parts);","\t701:     var path = baseParts[ComponentIndex.PATH];","\t702:     var index = path.lastIndexOf('/');","\t703:     path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];","\t704:     parts[ComponentIndex.PATH] = path;","\t705:     return joinAndCanonicalizePath(parts);","\t2432:     flags.option('--type-assertion-module <path>', 'Absolute path to the type assertion module.', (function(path) {","\t2433:       commandOptions.setOption('type-assertion-module', path);","\t2434:       return path;","\t13475:       var depPaths = this.dependencies.map((function(dep) {","\t13476:         return dep.path;","\t13486:         return parseStatements($__247, this.moduleName, depPaths, func);","\t13488:         return parseStatements($__248, depPaths, func);","\t13494:         path: tree.token,","\t19113:         path: match[5]","\t19132:       if (aParsedUrl.path) {","\t19133:         url += aParsedUrl.path;","\t19138:     function normalize(aPath) {","\t19139:       var path = aPath;","\t19140:       var url = urlParse(aPath);","\t19142:         if (!url.path) {","\t19143:           return aPath;","\t19145:         path = url.path;","\t19147:       var isAbsolute = (path.charAt(0) === '/');","\t19148:       var parts = path.split(/\\/+/);","\t19167:       path = parts.join('/');","\t19168:       if (path === '') {","\t19169:         path = isAbsolute ? '/' : '.';","\t19172:         url.path = path;","\t19175:       return path;","\t19178:     function join(aRoot, aPath) {","\t19179:       var aPathUrl = urlParse(aPath);","\t19182:         aRoot = aRootUrl.path || '/';","\t19184:       if (aPathUrl && !aPathUrl.scheme) {","\t19186:           aPathUrl.scheme = aRootUrl.scheme;","\t19188:         return urlGenerate(aPathUrl);","\t19190:       if (aPathUrl || aPath.match(dataUrlRegexp)) {","\t19191:         return aPath;","\t19193:       if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {","\t19194:         aRootUrl.host = aPath;","\t19197:       var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);","\t19199:         aRootUrl.path = joined;","\t19213:     function relative(aRoot, aPath) {","\t19216:       if (aPath.charAt(0) == \"/\" && url && url.path == \"/\") {","\t19217:         return aPath.slice(1);","\t19219:       return aPath.indexOf(aRoot + '/') === 0 ? aPath.substr(aRoot.length + 1) : aPath;","\t19525:     SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {","\t19546:             if (aSourceMapPath) {","\t19547:               mapping.source = util.join(aSourceMapPath, mapping.source);","\t19573:           if (aSourceMapPath) {","\t19574:             sourceFile = util.join(aSourceMapPath, sourceFile);","\t19847:         var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");","\t19848:         if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {","\t19849:           return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];","\t19851:         if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + aSource)) {","\t22386:           var subPath = name.split('/').splice(curMatchLength).join('/');","\t22387:           mappedName = map[curParent][curMatch] + (subPath ? '/' + subPath : '');","\t22405:     var subPath = name.split('/').splice(curMatchLength).join('/');","\t22406:     return map[curMatch] + (subPath ? '/' + subPath : '');","\t23076:       var path = normalizedName || String(uniqueNameCount++);","\t23077:       return resolveUrl(importerAddress, path);","",""]},{"start":{"row":5028,"column":0},"end":{"row":5035,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/index.js:","\t1: var path = require('path');","\t24:     p = path.resolve(p);","\t33:                 mkdirP(path.dirname(p), opts, function (er, made) {","\t67:     p = path.resolve(p);","\t76:                 made = sync(path.dirname(p), opts, made);","",""]},{"start":{"row":5035,"column":0},"end":{"row":5041,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/readme.markdown:","\t46: `opts.fs`. Your implementation should have `opts.fs.mkdir(path, mode, cb)` and","\t47: `opts.fs.stat(path, cb)`.","\t60: `opts.fs`. Your implementation should have `opts.fs.mkdirSync(path, mode)` and","\t61: `opts.fs.statSync(path)`.","",""]},{"start":{"row":5041,"column":0},"end":{"row":5046,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/bin/cmd.js:","\t16: var paths = argv._.slice();","\t20:     if (paths.length === 0) return;","\t21:     var p = paths.shift();","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5046,"column":0},"end":{"row":5049,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/test/chmod.js:","\t2: var path = require('path');","",""]},{"start":{"row":5049,"column":0},"end":{"row":5052,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/test/clobber.js:","\t2: var path = require('path');","",""]},{"start":{"row":5052,"column":0},"end":{"row":5053,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/test/mkdirp.js:",""]},{"start":{"row":5053,"column":0},"end":{"row":5059,"column":0},"action":"insert","lines":["\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","","/node_modules/jade/node_modules/mkdirp/test/opts_fs.js:","\t2: var path = require('path');","",""]},{"start":{"row":5059,"column":0},"end":{"row":5062,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/test/opts_fs_sync.js:","\t2: var path = require('path');","",""]},{"start":{"row":5062,"column":0},"end":{"row":5066,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/test/perm.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":5066,"column":0},"end":{"row":5067,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/test/perm_sync.js:",""]},{"start":{"row":5067,"column":0},"end":{"row":5074,"column":0},"action":"insert","lines":["\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","","/node_modules/jade/node_modules/mkdirp/test/race.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":5074,"column":0},"end":{"row":5078,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/test/rel.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":5078,"column":0},"end":{"row":5081,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/test/return.js:","\t2: var path = require('path');","",""]},{"start":{"row":5081,"column":0},"end":{"row":5084,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/test/return_sync.js:","\t2: var path = require('path');","",""]},{"start":{"row":5084,"column":0},"end":{"row":5088,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/test/root.js:","\t2: var path = require('path');","\t8:     var file = path.resolve('/');","",""]},{"start":{"row":5088,"column":0},"end":{"row":5092,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/test/sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":5092,"column":0},"end":{"row":5096,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/test/umask.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":5096,"column":0},"end":{"row":5100,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/mkdirp/test/umask_sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":5100,"column":0},"end":{"row":5103,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/history.md:","\t30:  - FIX lookup paths for **component** weren't set so you couldn't build components with dependancies","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5103,"column":0},"end":{"row":5132,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/lib/shared.js:","\t3: var path = require('path');","\t4: var normalize = path.normalize;","\t115: Transformer.prototype.renderFile = function (path, options, cb) {","\t119:     options.filename = (path = normalize(path));","\t120:     if (self._cache[path])","\t123:       fs.readFile(path, function (err, data) {","\t133: Transformer.prototype.renderFileSync = function (path, options) {","\t135:   options.filename = (path = normalize(path));","\t136:   return this.renderSync((this._cache[path] ? null : fs.readFileSync(path)), options);","","/node_modules/jade/node_modules/transformers/lib/transformers.js:","\t1: var dirname = require('path').dirname;","\t66:         delete options.filename; //atpl can't handle absolute windows file paths properly","\t300:     this.engine.onLoad = function(path, callback){","\t301:       if ('' == extname(path)) path += '.' + ext;","\t302:       if ('/' !== path[0]) path = views + '/' + path;","\t303:       read(path, options, callback);","\t353:       options.paths = options.paths || [dirname(options.filename)];","\t391:       options.paths = options.paths || [dirname(options.filename)];","\t508:     var path = require('path');","\t509:     builder.paths = (options.paths || ['components']).map(function (p) {","\t510:       if (path.resolve(p) === p) {","\t513:         return path.join(dirname(options.filename), p);","\t537:     var path = require('path');","\t538:     builder.paths = (options.paths || ['components']).map(function (p) {","\t539:       if (path.resolve(p) === p) {","\t542:         return path.join(dirname(options.filename), p);","",""]},{"start":{"row":5132,"column":0},"end":{"row":5142,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/README.md:","\t50:     --source-map-root  The path to the original source to be included in the","\t52:     --source-map-url   The path to the source map to be added in //@","\t59:                        names and ensure they are relative paths.","\t102: `--source-map output.js.map` (full path to the file where you want the","\t106: original files can be found.  In case you are passing full paths to input","\t108: directories to drop from the path prefix when declaring files in the source","\t138: /path/to/input/source.map`.  Normally the input source map should also point","\t338:     var result = UglifyJS.minify(\"/path/to/file.js\");","",""]},{"start":{"row":5142,"column":0},"end":{"row":5143,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/bin/uglifyjs:",""]},{"start":{"row":5143,"column":0},"end":{"row":5147,"column":0},"action":"insert","lines":["\t21:     .describe(\"source-map-root\", \"The path to the original source to be included in the source map.\")","\t22:     .describe(\"source-map-url\", \"The path to the source map to be added in //@ sourceMappingURL.  Defaults to the value passed with --source-map.\")","\t25: For example -p 3 will drop 3 directories from file names and ensure they are relative paths.\")","",""]},{"start":{"row":5147,"column":0},"end":{"row":5155,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/optimist/index.js:","\t1: var path = require('path');","\t36:             path.dirname(process.execPath) + '/', ''","\t445: // rebase an absolute path to a relative one with respect to a base directory","\t449:     var ds = path.normalize(dir).split('/').slice(1);","\t450:     var bs = path.normalize(base).split('/').slice(1);","\t455:     var p = path.normalize(","",""]},{"start":{"row":5155,"column":0},"end":{"row":5158,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/optimist/readme.markdown:","\t460: When you use dots (`.`s) in argument names, an implicit object path is assumed.","",""]},{"start":{"row":5158,"column":0},"end":{"row":5159,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/optimist/node_modules/wordwrap/test/idleness.txt:",""]},{"start":{"row":5159,"column":0},"end":{"row":5161,"column":0},"action":"insert","lines":["\t55: In the past, there was a small leisure class and a larger working class. The leisure class enjoyed advantages for which there was no basis in social justice; this necessarily made it oppressive, limited its sympathies, and caused it to invent theories by which to justify its privileges. These facts greatly diminished its excellence, but in spite of this drawback it contributed nearly the whole of what we call civilization. It cultivated the arts and discovered the sciences; it wrote the books, invented the philosophies, and refined social relations. Even the liberation of the oppressed has usually been inaugurated from above. Without the leisure class, mankind would never have emerged from barbarism.","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5161,"column":0},"end":{"row":5165,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/optimist/test/parse.js:","\t2: var path = require('path');","\t5: var $0 = 'node ./' + path.relative(process.cwd(), __filename);","",""]},{"start":{"row":5165,"column":0},"end":{"row":5166,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/CHANGELOG.md:",""]},{"start":{"row":5166,"column":0},"end":{"row":5176,"column":0},"action":"insert","lines":["\t35: * Fix a bug where finding relative paths from an empty path were creating","\t36:   absolute paths. See issue #129.","\t40: * Fix a bug where if the source root was an empty string, relative source paths","\t41:   would turn into absolute source paths. Issue #124.","\t50:   to specify a path that relative sources in the second parameter should be","\t69: * Fix some edge cases surrounding path joining and URL resolution.","\t71: * Add a third parameter for relative path to","\t133: * Fix issue with absolute paths and `file://` URIs. See","\t138: * Fix issue with absolute paths and sourcesContent, github issue 64.","",""]},{"start":{"row":5176,"column":0},"end":{"row":5187,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/Makefile.dryice.js:","\t7: var path = require('path');","\t33:     roots: [ path.join(__dirname, 'lib') ]","\t69:     roots: [ path.join(__dirname, 'lib') ]","\t95:     roots: [ __dirname, path.join(__dirname, 'lib') ]","\t120:   var testFiles = fs.readdirSync(path.join(__dirname, 'test', 'source-map')).filter(isTestFile);","\t123:     console.log('\\nCreating', path.join('dist', 'test', testFile.replace(/\\-/g, '_')));","\t128:         path.join('test', 'source-map', testFile),","\t137:                                + path.join('test', 'source-map', testFile.replace(/\\.js$/, ''))","\t146:       dest: path.join('dist', 'test', testFile.replace(/\\-/g, '_'))","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5187,"column":0},"end":{"row":5188,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/README.md:",""]},{"start":{"row":5188,"column":0},"end":{"row":5194,"column":0},"action":"insert","lines":["\t310: #### SourceMapGenerator.prototype.applySourceMap(sourceMapConsumer[, sourceFile[, sourceMapPath]])","\t323: * `sourceMapPath`: Optional. The dirname of the path to the SourceMap","\t328:   paths. If so, those relative source paths need to be rewritten","\t361: #### SourceNode.fromStringWithSourceMap(code, sourceMapConsumer[, relativePath])","\t369: * `relativePath` The optional path that relative sources in `sourceMapConsumer`","",""]},{"start":{"row":5194,"column":0},"end":{"row":5200,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/build/mini-require.js:","\t80:   function normalize(path) {","\t81:     var bits = path.split('/');","\t105:   function dirname(path) {","\t106:     var bits = path.split('/');","",""]},{"start":{"row":5200,"column":0},"end":{"row":5201,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/lib/source-map/source-map-consumer.js:",""]},{"start":{"row":5201,"column":0},"end":{"row":5209,"column":0},"action":"insert","lines":["\t69:     // Some source maps produce relative source paths like \"./foo.js\" instead of","\t141:   //       source: The path to the original source file that generated this","\t399:         // XXX: file:// URIs and absolute paths lead to unexpected behavior for","\t403:         var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");","\t405:             && this._sources.has(fileUriAbsPath)) {","\t406:           return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]","\t409:         if ((!url.path || url.path == \"/\")","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5209,"column":0},"end":{"row":5218,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/lib/source-map/source-map-generator.js:","\t162:    * @param aSourceMapPath Optional. The dirname of the path to the source map","\t166:    *        paths. If so, those relative source paths need to be rewritten","\t170:     function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {","\t203:             if (aSourceMapPath != null) {","\t204:               mapping.source = util.join(aSourceMapPath, mapping.source)","\t235:           if (aSourceMapPath != null) {","\t236:             sourceFile = util.join(aSourceMapPath, sourceFile);","",""]},{"start":{"row":5218,"column":0},"end":{"row":5226,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/lib/source-map/source-node.js:","\t55:    * @param aRelativePath Optional. The path that relative sources in the","\t59:     function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {","\t140:           if (aRelativePath != null) {","\t141:             sourceFile = util.join(aRelativePath, sourceFile);","\t153:           var source = aRelativePath","\t154:             ? util.join(aRelativePath, mapping.source)","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5226,"column":0},"end":{"row":5280,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/lib/source-map/util.js:","\t46:       path: match[5]","\t66:     if (aParsedUrl.path) {","\t67:       url += aParsedUrl.path;","\t74:    * Normalizes a path, or the path portion of a URL:","\t80:    * Based on code in the Node.js 'path' core module.","\t82:    * @param aPath The path or url to normalize.","\t84:   function normalize(aPath) {","\t85:     var path = aPath;","\t86:     var url = urlParse(aPath);","\t88:       if (!url.path) {","\t89:         return aPath;","\t91:       path = url.path;","\t93:     var isAbsolute = (path.charAt(0) === '/');","\t95:     var parts = path.split(/\\/+/);","\t104:           // The first part is blank if the path is absolute. Trying to go","\t115:     path = parts.join('/');","\t117:     if (path === '') {","\t118:       path = isAbsolute ? '/' : '.';","\t122:       url.path = path;","\t125:     return path;","\t130:    * Joins two paths/URLs.","\t132:    * @param aRoot The root path or URL.","\t133:    * @param aPath The path or URL to be joined with the root.","\t135:    * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a","\t138:    * - Otherwise aPath is a path. If aRoot is a URL, then its path portion","\t141:    *   - If aPath is absolute, the result is aPath.","\t142:    *   - Otherwise the two paths are joined with a slash.","\t145:   function join(aRoot, aPath) {","\t149:     if (aPath === \"\") {","\t150:       aPath = \".\";","\t152:     var aPathUrl = urlParse(aPath);","\t155:       aRoot = aRootUrl.path || '/';","\t159:     if (aPathUrl && !aPathUrl.scheme) {","\t161:         aPathUrl.scheme = aRootUrl.scheme;","\t163:       return urlGenerate(aPathUrl);","\t166:     if (aPathUrl || aPath.match(dataUrlRegexp)) {","\t167:       return aPath;","\t171:     if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {","\t172:       aRootUrl.host = aPath;","\t176:     var joined = aPath.charAt(0) === '/'","\t177:       ? aPath","\t178:       : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);","\t181:       aRootUrl.path = joined;","\t189:    * Make a path relative to a URL or another path.","\t191:    * @param aRoot The root path or URL.","\t192:    * @param aPath The path or URL to be made relative to aRoot.","\t194:   function relative(aRoot, aPath) {","\t203:     if (aPath.charAt(0) == \"/\" && url && url.path == \"/\") {","\t204:       return aPath.slice(1);","\t207:     return aPath.indexOf(aRoot + '/') === 0","\t208:       ? aPath.substr(aRoot.length + 1)","\t209:       : aPath;","",""]},{"start":{"row":5280,"column":0},"end":{"row":5297,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/node_modules/amdefine/amdefine.js:","\t26:         path = require('path'),","\t30:      * Trims the . and .. from an array of path segments.","\t31:      * It will keep a leading path segment if a .. will become","\t32:      * the first path segment, to help with module name lookups,","\t33:      * which act like paths, but can be remapped. But the end result,","\t34:      * all paths that use this function should look normalized.","\t36:      * @param {Array} ary the array of path segments.","\t48:                     //path segment at the front so it can be mapped","\t50:                     //no path mapping for a path starting with '..'.","\t65:         //Adjust any relative paths.","\t99:             //define, and any relative paths and requires should be relative","\t129:         amdRequire.toUrl = function (filePath) {","\t130:             if (filePath.indexOf('.') === 0) {","\t131:                 return normalize(filePath, path.dirname(module.filename));","\t133:                 return filePath;","",""]},{"start":{"row":5297,"column":0},"end":{"row":5298,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/node_modules/amdefine/package.json:",""]},{"start":{"row":5298,"column":0},"end":{"row":5306,"column":0},"action":"insert","lines":["\t29:   \"readme\": \"# amdefine\\n\\nA module that can be used to implement AMD's define() in Node. This allows you\\nto code to the AMD API and have the module work in node programs without\\nrequiring those other programs to use AMD.\\n\\n## Usage\\n\\n**1)** Update your package.json to indicate amdefine as a dependency:\\n\\n```javascript\\n    \\\"dependencies\\\": {\\n        \\\"amdefine\\\": \\\">=0.1.0\\\"\\n    }\\n```\\n\\nThen run `npm install` to get amdefine into your project.\\n\\n**2)** At the top of each module that uses define(), place this code:\\n\\n```javascript\\nif (typeof define !== 'function') { var define = require('amdefine')(module) }\\n```\\n\\n**Only use these snippets** when loading amdefine. If you preserve the basic structure,\\nwith the braces, it will be stripped out when using the [RequireJS optimizer](#optimizer).\\n\\nYou can add spaces, line breaks and even require amdefine with a local path, but\\nkeep the rest of the structure to get the stripping behavior.\\n\\nAs you may know, because `if` statements in JavaScript don't have their own scope, the var\\ndeclaration in the above snippet is made whether the `if` expression is truthy or not. If\\nRequireJS is loaded then the declaration is superfluous because `define` is already already\\ndeclared in the same scope in RequireJS. Fortunately JavaScript handles multiple `var`\\ndeclarations of the same variable in the same scope gracefully.\\n\\nIf you want to deliver amdefine.js with your code rather than specifying it as a dependency\\nwith npm, then just download the latest release and refer to it using a relative path:\\n\\n[Latest Version](https://github.com/jrburke/amdefine/raw/latest/amdefine.js)\\n\\n### amdefine/intercept\\n\\nConsider this very experimental.\\n\\nInstead of pasting the piece of text for the amdefine setup of a `define`\\nvariable in each module you create or consume, you can use `amdefine/intercept`\\ninstead. It will automatically insert the above snippet in each .js file loaded\\nby Node.\\n\\n**Warning**: you should only use this if you are creating an application that\\nis consuming AMD style defined()'d modules that are distributed via npm and want\\nto run that code in Node.\\n\\nFor library code where you are not sure if it will be used by others in Node or\\nin the browser, then explicitly depending on amdefine and placing the code\\nsnippet above is suggested path, instead of using `amdefine/intercept`. The\\nintercept module affects all .js files loaded in the Node app, and it is\\ninconsiderate to modify global state like that unless you are also controlling\\nthe top level app.\\n\\n#### Why distribute AMD-style nodes via npm?\\n\\nnpm has a lot of weaknesses for front-end use (installed layout is not great,\\nshould have better support for the `baseUrl + moduleID + '.js' style of loading,\\nsingle file JS installs), but some people want a JS package manager and are\\nwilling to live with those constraints. If that is you, but still want to author\\nin AMD style modules to get dynamic require([]), better direct source usage and\\npowerful loader plugin support in the browser, then this tool can help.\\n\\n#### amdefine/intercept usage\\n\\nJust require it in your top level app module (for example index.js, server.js):\\n\\n```javascript\\nrequire('amdefine/intercept');\\n```\\n\\nThe module does not return a value, so no need to assign the result to a local\\nvariable.\\n\\nThen just require() code as you normally would with Node's require(). Any .js\\nloaded after the intercept require will have the amdefine check injected in\\nthe .js source as it is loaded. It does not modify the source on disk, just\\nprepends some content to the text of the module as it is loaded by Node.\\n\\n#### How amdefine/intercept works\\n\\nIt overrides the `Module._extensions['.js']` in Node to automatically prepend\\nthe amdefine snippet above. So, it will affect any .js file loaded by your\\napp.\\n\\n## define() usage\\n\\nIt is best if you use the anonymous forms of define() in your module:\\n\\n```javascript\\ndefine(function (require) {\\n    var dependency = require('dependency');\\n});\\n```\\n\\nor\\n\\n```javascript\\ndefine(['dependency'], function (dependency) {\\n\\n});\\n```\\n\\n## RequireJS optimizer integration. <a name=\\\"optimizer\\\"></name>\\n\\nVersion 1.0.3 of the [RequireJS optimizer](http://requirejs.org/docs/optimization.html)\\nwill have support for stripping the `if (typeof define !== 'function')` check\\nmentioned above, so you can include this snippet for code that runs in the\\nbrowser, but avoid taking the cost of the if() statement once the code is\\noptimized for deployment.\\n\\n## Node 0.4 Support\\n\\nIf you want to support Node 0.4, then add `require` as the second parameter to amdefine:\\n\\n```javascript\\n//Only if you want Node 0.4. If using 0.5 or later, use the above snippet.\\nif (typeof define !== 'function') { var define = require('amdefine')(module, require) }\\n```\\n\\n## Limitations\\n\\n### Synchronous vs Asynchronous\\n\\namdefine creates a define() function that is callable by your code. It will\\nexecute and trace dependencies and call the factory function *synchronously*,\\nto keep the behavior in line with Node's synchronous dependency tracing.\\n\\nThe exception: calling AMD's callback-style require() from inside a factory\\nfunction. The require callback is called on process.nextTick():\\n\\n```javascript\\ndefine(function (require) {\\n    require(['a'], function(a) {\\n        //'a' is loaded synchronously, but\\n        //this callback is called on process.nextTick().\\n    });\\n});\\n```\\n\\n### Loader Plugins\\n\\nLoader plugins are supported as long as they call their load() callbacks\\nsynchronously. So ones that do network requests will not work. However plugins\\nlike [text](http://requirejs.org/docs/api.html#text) can load text files locally.\\n\\nThe plugin API's `load.fromText()` is **not supported** in amdefine, so this means\\ntranspiler plugins like the [CoffeeScript loader plugin](https://github.com/jrburke/require-cs)\\nwill not work. This may be fixable, but it is a bit complex, and I do not have\\nenough node-fu to figure it out yet. See the source for amdefine.js if you want\\nto get an idea of the issues involved.\\n\\n## Tests\\n\\nTo run the tests, cd to **tests** and run:\\n\\n```\\nnode all.js\\nnode all-intercept.js\\n```\\n\\n## License\\n\\nNew BSD and MIT. Check the LICENSE file for all the details.\\n\",","","/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/node_modules/amdefine/README.md:","\t28: You can add spaces, line breaks and even require amdefine with a local path, but","\t38: with npm, then just download the latest release and refer to it using a relative path:","\t57: snippet above is suggested path, instead of using `amdefine/intercept`. The","","/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/test/run-tests.js:",""]},{"start":{"row":5306,"column":0},"end":{"row":5310,"column":0},"action":"insert","lines":["\t10: var path = require('path');","\t43:     ? path.basename(testToRun) === f","\t51: var requires = fs.readdirSync(path.join(__dirname, 'source-map'))","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5310,"column":0},"end":{"row":5314,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/test/source-map/test-source-map-consumer.js:","\t255:   exports['test that we can get the original source content with relative source paths'] = function (assert, util) {","\t523:   exports['test absolute path, but same host sources'] = function (assert, util) {","",""]},{"start":{"row":5314,"column":0},"end":{"row":5319,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/test/source-map/test-source-map-generator.js:","\t417:     var actualMap = function (aSourceMapPath) {","\t421:       map.applySourceMap(bundleMap, '../temp/bundle.js', aSourceMapPath);","\t444:     // directory we get incorrect source paths:","",""]},{"start":{"row":5319,"column":0},"end":{"row":5324,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/node_modules/source-map/test/source-map/test-source-node.js:","\t311:     var test = function(relativePath, expectedSources) {","\t316:                                 relativePath));","\t337:     // directory we get incorrect source paths:","",""]},{"start":{"row":5324,"column":0},"end":{"row":5330,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/test/run-tests.js:","\t4: var path = require(\"path\");","\t9: var tests_dir = path.dirname(module.filename);","\t50:     return path.resolve(tests_dir, dir);","\t88:         var tests = parse_test(path.resolve(dir, file));","",""]},{"start":{"row":5330,"column":0},"end":{"row":5335,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/transformers/node_modules/uglify-js/tools/node.js:","\t1: var path = require(\"path\");","\t13:     file = path.resolve(path.dirname(module.filename), file);","\t36:     return path.join(path.dirname(fs.realpathSync(__filename)), file);","",""]},{"start":{"row":5335,"column":0},"end":{"row":5339,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/with/node_modules/acorn/bin/acorn:","\t3: var path = require(\"path\");","\t11:   print(\"usage: \" + path.basename(process.argv[1]) + \" [--ecma3|--ecma5|--ecma6] [--strictSemicolons]\");","",""]},{"start":{"row":5339,"column":0},"end":{"row":5344,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/with/node_modules/acorn/test/driver.js:","\t70:   function addPath(str, pt) {","\t84:         if (mis) return addPath(mis, i);","\t89:         if (mis) return addPath(mis, prop);","",""]},{"start":{"row":5344,"column":0},"end":{"row":5358,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/with/node_modules/acorn/test/jquery-string.js:","\t835: \\t\\t// QSA path\\n\\","\t3699: \\t\\t// the code to shortcut on the same path as a DOM node with no cache\\n\\","\t3817: \\t\\t\\t\\t// This will only penalize the array argument path.\\n\\","\t4468: \\t\\t\\teventPath = [ elem || document ],\\n\\","\t4521: \\t\\t// Determine event propagation path in advance, per W3C events spec (#9951)\\n\\","\t4530: \\t\\t\\t\\teventPath.push( cur );\\n\\","\t4536: \\t\\t\\t\\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\\n\\","\t4540: \\t\\t// Fire handlers on the event path\\n\\","\t4542: \\t\\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\\n\\","\t4568: \\t\\t\\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\\n\\","\t5451: \\t\\t// This path appears unavoidable for IE9. When cloning an object\\n\\","\t6792: \\t\\t\\t\\t// style.removeAttribute is IE Only, but so apparently is this code path...\\n\\","",""]},{"start":{"row":5358,"column":0},"end":{"row":5362,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/with/node_modules/acorn/test/compare/esprima.js:","\t5052:                 // Try first to convert to a string. This is good as fast path","\t5157:                 // Try first to convert to a string. This is good as fast path","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5362,"column":0},"end":{"row":5442,"column":0},"action":"insert","lines":["/node_modules/jade/node_modules/with/node_modules/acorn/test/compare/traceur.js:","\t602:   function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {","\t617:     if (opt_path) {","\t618:       out.push(opt_path);","\t635:     PATH: 5,","\t642:   function removeDotSegments(path) {","\t643:     if (path === '/')","\t645:     var leadingSlash = path[0] === '/' ? '/' : '';","\t646:     var trailingSlash = path.slice(-1) === '/' ? '/' : '';","\t647:     var segments = path.split('/');","\t675:   function joinAndCanonicalizePath(parts) {","\t676:     var path = parts[ComponentIndex.PATH] || '';","\t677:     path = removeDotSegments(path);","\t678:     parts[ComponentIndex.PATH] = path;","\t679:     return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);","\t683:     return joinAndCanonicalizePath(parts);","\t689:       return joinAndCanonicalizePath(parts);","\t698:     if (parts[ComponentIndex.PATH][0] == '/') {","\t699:       return joinAndCanonicalizePath(parts);","\t701:     var path = baseParts[ComponentIndex.PATH];","\t702:     var index = path.lastIndexOf('/');","\t703:     path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];","\t704:     parts[ComponentIndex.PATH] = path;","\t705:     return joinAndCanonicalizePath(parts);","\t2432:     flags.option('--type-assertion-module <path>', 'Absolute path to the type assertion module.', (function(path) {","\t2433:       commandOptions.setOption('type-assertion-module', path);","\t2434:       return path;","\t13475:       var depPaths = this.dependencies.map((function(dep) {","\t13476:         return dep.path;","\t13486:         return parseStatements($__247, this.moduleName, depPaths, func);","\t13488:         return parseStatements($__248, depPaths, func);","\t13494:         path: tree.token,","\t19113:         path: match[5]","\t19132:       if (aParsedUrl.path) {","\t19133:         url += aParsedUrl.path;","\t19138:     function normalize(aPath) {","\t19139:       var path = aPath;","\t19140:       var url = urlParse(aPath);","\t19142:         if (!url.path) {","\t19143:           return aPath;","\t19145:         path = url.path;","\t19147:       var isAbsolute = (path.charAt(0) === '/');","\t19148:       var parts = path.split(/\\/+/);","\t19167:       path = parts.join('/');","\t19168:       if (path === '') {","\t19169:         path = isAbsolute ? '/' : '.';","\t19172:         url.path = path;","\t19175:       return path;","\t19178:     function join(aRoot, aPath) {","\t19179:       var aPathUrl = urlParse(aPath);","\t19182:         aRoot = aRootUrl.path || '/';","\t19184:       if (aPathUrl && !aPathUrl.scheme) {","\t19186:           aPathUrl.scheme = aRootUrl.scheme;","\t19188:         return urlGenerate(aPathUrl);","\t19190:       if (aPathUrl || aPath.match(dataUrlRegexp)) {","\t19191:         return aPath;","\t19193:       if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {","\t19194:         aRootUrl.host = aPath;","\t19197:       var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);","\t19199:         aRootUrl.path = joined;","\t19213:     function relative(aRoot, aPath) {","\t19216:       if (aPath.charAt(0) == \"/\" && url && url.path == \"/\") {","\t19217:         return aPath.slice(1);","\t19219:       return aPath.indexOf(aRoot + '/') === 0 ? aPath.substr(aRoot.length + 1) : aPath;","\t19525:     SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {","\t19546:             if (aSourceMapPath) {","\t19547:               mapping.source = util.join(aSourceMapPath, mapping.source);","\t19573:           if (aSourceMapPath) {","\t19574:             sourceFile = util.join(aSourceMapPath, sourceFile);","\t19847:         var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");","\t19848:         if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {","\t19849:           return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];","\t19851:         if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + aSource)) {","\t22386:           var subPath = name.split('/').splice(curMatchLength).join('/');","\t22387:           mappedName = map[curParent][curMatch] + (subPath ? '/' + subPath : '');","\t22405:     var subPath = name.split('/').splice(curMatchLength).join('/');","\t22406:     return map[curMatch] + (subPath ? '/' + subPath : '');","\t23076:       var path = normalizedName || String(uniqueNameCount++);","\t23077:       return resolveUrl(importerAddress, path);","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5442,"column":0},"end":{"row":5523,"column":0},"action":"insert","lines":["/node_modules/mocha/mocha.js:","\t6:     var path = require.resolve(p)","\t7:       , mod = require.modules[path];","\t11:       mod.call(mod.exports, mod, mod.exports, require.relative(path));","\t18: require.resolve = function (path){","\t19:     var orig = path","\t20:       , reg = path + '.js'","\t21:       , index = path + '/index.js';","\t27: require.register = function (path, fn){","\t28:     require.modules[path] = fn;","\t35:       var path = parent.split('/')","\t37:       path.pop();","\t41:         if ('..' == seg) path.pop();","\t42:         else if ('.' != seg) path.push(seg);","\t45:       return require(path.join('/'));","\t77:   function clonePath(path) {","\t78:     return { newPos: path.newPos, components: path.components.slice(0) };","\t120:         var bestPath = [{ newPos: -1, components: [] }];","\t123:         var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);","\t124:         if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {","\t125:           return bestPath[0].components;","\t129:           for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {","\t130:             var basePath;","\t131:             var addPath = bestPath[diagonalPath-1],","\t132:                 removePath = bestPath[diagonalPath+1];","\t133:             oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;","\t134:             if (addPath) {","\t136:               bestPath[diagonalPath-1] = undefined;","\t139:             var canAdd = addPath && addPath.newPos+1 < newLen;","\t140:             var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;","\t142:               bestPath[diagonalPath] = undefined;","\t147:             // path whose position in the new string is the farthest from the origin","\t149:             if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {","\t150:               basePath = clonePath(removePath);","\t151:               this.pushComponent(basePath.components, oldString[oldPos], undefined, true);","\t153:               basePath = clonePath(addPath);","\t154:               basePath.newPos++;","\t155:               this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);","\t158:             var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);","\t160:             if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {","\t161:               return basePath.components;","\t163:               bestPath[diagonalPath] = basePath;","\t180:       extractCommon: function(basePath, newString, oldString, diagonalPath) {","\t183:             newPos = basePath.newPos,","\t184:             oldPos = newPos - diagonalPath;","\t189:           this.pushComponent(basePath.components, newString[newPos], undefined, undefined);","\t191:         basePath.newPos = newPos;","\t635: require.register(\"browser/path.js\", function(module, exports, require){","\t637: }); // module: browser/path.js","\t744:     ctx.beginPath();","\t750:     ctx.beginPath();","\t1426: var path = require('browser/path')","\t1441:   var join = path.join","\t1443:   module.paths.push(cwd, join(cwd, 'node_modules'));","\t1461:  * Return image `name` path.","\t1598:     file = path.resolve(file);","\t2788:   return window.location.pathname + (search ? search + '&' : '?' ) + 'grep=' + encodeURIComponent(s);","\t5594:   , path = require('browser/path')","\t5595:   , basename = path.basename","\t5596:   , exists = fs.existsSync || path.existsSync","\t5598:   , join = path.join","\t5752: function ignored(path){","\t5753:   return !~ignore.indexOf(path);","\t5771:   .forEach(function(path){","\t5772:     path = join(dir, path);","\t5773:     if (fs.statSync(path).isDirectory()) {","\t5774:       exports.files(path, ext, ret);","\t5775:     } else if (path.match(re)) {","\t5776:       ret.push(path);","\t6071:  * Lookup file names at the given `path`.","\t6073: exports.lookupFiles = function lookupFiles(path, extensions, recursive) {","\t6077:   if (!exists(path)) {","\t6078:     if (exists(path + '.js')) {","\t6079:       path += '.js';","\t6081:       files = glob.sync(path);","\t6082:       if (!files.length) throw new Error(\"cannot resolve path (or pattern) '\" + path + \"'\");","\t6088:     var stat = fs.statSync(path);","\t6089:     if (stat.isFile()) return path;","\t6095:   fs.readdirSync(path).forEach(function(file){","\t6096:     file = join(path, file);","",""]},{"start":{"row":5523,"column":0},"end":{"row":5543,"column":0},"action":"insert","lines":["/node_modules/mocha/bin/_mocha:","\t8:   , path = require('path')","\t10:   , resolve = path.resolve","\t11:   , exists = fs.existsSync || path.existsSync","\t14:   , join = path.join","\t90:   .option('--opts <path>', 'specify opts path', 'test/mocha.opts')","\t104:   .command('init <path>')","\t105:   .description('initialize a client-side mocha setup at <path>')","\t106:   .action(function(path){","\t108:     mkdir.sync(path);","\t112:     fs.writeFileSync(join(path, 'mocha.css'), css);","\t113:     fs.writeFileSync(join(path, 'mocha.js'), js);","\t114:     fs.writeFileSync(join(path, 'tests.js'), '');","\t115:     fs.writeFileSync(join(path, 'index.html'), tmpl);","\t162: module.paths.push(cwd, join(cwd, 'node_modules'));","\t172: var optsPath = process.argv.indexOf('--opts') !== -1","\t177:   var opts = fs.readFileSync(optsPath, 'utf8')","\t321: files = files.map(function(path){","\t322:   return resolve(path);","",""]},{"start":{"row":5543,"column":0},"end":{"row":5550,"column":0},"action":"insert","lines":["/node_modules/mocha/lib/mocha.js:","\t11: var path = require('path')","\t26:   var join = path.join","\t28:   module.paths.push(cwd, join(cwd, 'node_modules'));","\t46:  * Return image `name` path.","\t183:     file = path.resolve(file);","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5550,"column":0},"end":{"row":5575,"column":0},"action":"insert","lines":["/node_modules/mocha/lib/utils.js:","\t6:   , path = require('path')","\t7:   , basename = path.basename","\t8:   , exists = fs.existsSync || path.existsSync","\t10:   , join = path.join","\t164: function ignored(path){","\t165:   return !~ignore.indexOf(path);","\t183:   .forEach(function(path){","\t184:     path = join(dir, path);","\t185:     if (fs.statSync(path).isDirectory()) {","\t186:       exports.files(path, ext, ret);","\t187:     } else if (path.match(re)) {","\t188:       ret.push(path);","\t483:  * Lookup file names at the given `path`.","\t485: exports.lookupFiles = function lookupFiles(path, extensions, recursive) {","\t489:   if (!exists(path)) {","\t490:     if (exists(path + '.js')) {","\t491:       path += '.js';","\t493:       files = glob.sync(path);","\t494:       if (!files.length) throw new Error(\"cannot resolve path (or pattern) '\" + path + \"'\");","\t500:     var stat = fs.statSync(path);","\t501:     if (stat.isFile()) return path;","\t507:   fs.readdirSync(path).forEach(function(file){","\t508:     file = join(path, file);","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5575,"column":0},"end":{"row":5609,"column":0},"action":"insert","lines":["/node_modules/mocha/lib/browser/diff.js:","\t19:   function clonePath(path) {","\t20:     return { newPos: path.newPos, components: path.components.slice(0) };","\t62:         var bestPath = [{ newPos: -1, components: [] }];","\t65:         var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);","\t66:         if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {","\t67:           return bestPath[0].components;","\t71:           for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {","\t72:             var basePath;","\t73:             var addPath = bestPath[diagonalPath-1],","\t74:                 removePath = bestPath[diagonalPath+1];","\t75:             oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;","\t76:             if (addPath) {","\t78:               bestPath[diagonalPath-1] = undefined;","\t81:             var canAdd = addPath && addPath.newPos+1 < newLen;","\t82:             var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;","\t84:               bestPath[diagonalPath] = undefined;","\t89:             // path whose position in the new string is the farthest from the origin","\t91:             if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {","\t92:               basePath = clonePath(removePath);","\t93:               this.pushComponent(basePath.components, oldString[oldPos], undefined, true);","\t95:               basePath = clonePath(addPath);","\t96:               basePath.newPos++;","\t97:               this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);","\t100:             var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);","\t102:             if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {","\t103:               return basePath.components;","\t105:               bestPath[diagonalPath] = basePath;","\t122:       extractCommon: function(basePath, newString, oldString, diagonalPath) {","\t125:             newPos = basePath.newPos,","\t126:             oldPos = newPos - diagonalPath;","\t131:           this.pushComponent(basePath.components, newString[newPos], undefined, undefined);","\t133:         basePath.newPos = newPos;","",""]},{"start":{"row":5609,"column":0},"end":{"row":5613,"column":0},"action":"insert","lines":["/node_modules/mocha/lib/browser/progress.js:","\t105:     ctx.beginPath();","\t111:     ctx.beginPath();","",""]},{"start":{"row":5613,"column":0},"end":{"row":5616,"column":0},"action":"insert","lines":["/node_modules/mocha/lib/reporters/html.js:","\t186:   return window.location.pathname + (search ? search + '&' : '?' ) + 'grep=' + encodeURIComponent(s);","",""]},{"start":{"row":5616,"column":0},"end":{"row":5625,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/commander/index.js:","\t8: var path = require('path');","\t9: var dirname = path.dirname;","\t10: var basename = path.basename;","\t112:  *        .option('-C, --chdir <path>', 'change the working directory')","\t113:  *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')","\t288:  *     program.option('-C, --chdir <path>', 'change the working directory');","\t407:   var local = path.join(dir, bin);","",""]},{"start":{"row":5625,"column":0},"end":{"row":5628,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/debug/History.md:","\t32:   * Makefile: find node path using shell/which (#109, @timoxley)","",""]},{"start":{"row":5628,"column":0},"end":{"row":5632,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/debug/Makefile:","\t3: THIS_MAKEFILE_PATH:=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))","\t4: THIS_DIR:=$(shell cd $(dir $(THIS_MAKEFILE_PATH));pwd)","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5632,"column":0},"end":{"row":5666,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/diff/diff.js:","\t19:   function clonePath(path) {","\t20:     return { newPos: path.newPos, components: path.components.slice(0) };","\t62:         var bestPath = [{ newPos: -1, components: [] }];","\t65:         var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);","\t66:         if (bestPath[0].newPos+1 >= newLen && oldPos+1 >= oldLen) {","\t67:           return bestPath[0].components;","\t71:           for (var diagonalPath = -1*editLength; diagonalPath <= editLength; diagonalPath+=2) {","\t72:             var basePath;","\t73:             var addPath = bestPath[diagonalPath-1],","\t74:                 removePath = bestPath[diagonalPath+1];","\t75:             oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;","\t76:             if (addPath) {","\t78:               bestPath[diagonalPath-1] = undefined;","\t81:             var canAdd = addPath && addPath.newPos+1 < newLen;","\t82:             var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;","\t84:               bestPath[diagonalPath] = undefined;","\t89:             // path whose position in the new string is the farthest from the origin","\t91:             if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {","\t92:               basePath = clonePath(removePath);","\t93:               this.pushComponent(basePath.components, oldString[oldPos], undefined, true);","\t95:               basePath = clonePath(addPath);","\t96:               basePath.newPos++;","\t97:               this.pushComponent(basePath.components, newString[basePath.newPos], true, undefined);","\t100:             var oldPos = this.extractCommon(basePath, newString, oldString, diagonalPath);","\t102:             if (basePath.newPos+1 >= newLen && oldPos+1 >= oldLen) {","\t103:               return basePath.components;","\t105:               bestPath[diagonalPath] = basePath;","\t122:       extractCommon: function(basePath, newString, oldString, diagonalPath) {","\t125:             newPos = basePath.newPos,","\t126:             oldPos = newPos - diagonalPath;","\t131:           this.pushComponent(basePath.components, newString[newPos], undefined, undefined);","\t133:         basePath.newPos = newPos;","",""]},{"start":{"row":5666,"column":0},"end":{"row":5690,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/glob.js:","\t44: , path = require(\"path\")","\t109:     this.changedCwd = path.resolve(options.cwd) !== cwd","\t112:   this.root = options.root || path.resolve(this.cwd, \"/\")","\t113:   this.root = path.resolve(this.root)","\t342:               prefix = path.join(this.root, prefix)","\t344:               prefix = path.resolve(this.root, prefix)","\t379:       prefix = path.join(\"/\", prefix)","\t381:     read = prefix = path.resolve(prefix)","\t461:           e = path.join(this.root, e)","\t502:     abs = path.join(this.root, f)","\t504:     abs = path.resolve(this.cwd, f)","\t508:     var er = new Error(\"Path name too long\")","\t510:     er.path = f","\t545:     er.path = abs","\t568:     abs = path.join(this.root, f)","\t572:     abs = path.resolve(this.cwd, f)","\t576:     var er = new Error(\"Path name too long\")","\t578:     er.path = f","\t594:       er.path = f","\t661:   // pull off the device/UNC bit from a windows path.","\t662:   // from node's lib/path.js","\t668:     , isAbsolute = !!result[2] || isUnc // UNC paths are always absolute","",""]},{"start":{"row":5690,"column":0},"end":{"row":5703,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/README.md:","\t106:   * `false` - Path does not exist","\t107:   * `true` - Path exists","\t108:   * `1` - Path exists, and is not a directory","\t109:   * `2` - Path exists, and is a directory","\t110:   * `[file, entries, ...]` - Path exists, is a directory, and the","\t141:   onto.  Defaults to `path.resolve(options.cwd, \"/\")` (`/` on Unix","\t147:   \"mounted\" onto the root setting, so that a valid filesystem path is","\t205: thing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but","\t225: Though windows uses either `/` or `\\` as its path separator, only `/`","\t228: be interpreted as escape characters, not path separators.","\t231: root setting using `path.join`.  On windows, this will by default result","",""]},{"start":{"row":5703,"column":0},"end":{"row":5716,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/node_modules/graceful-fs/graceful-fs.js:","\t38: function open(path, flags, mode, cb) {","\t41:   new OpenReq(path, flags, mode, cb)","\t44: function OpenReq(path, flags, mode, cb) {","\t45:   this.path = path","\t55:   originalOpen.call(fs, this.path, this.flags, this.mode, this.done)","\t62:     fds['fd' + fd] = this.path","\t70: function readdir(path, cb) {","\t72:   new ReaddirReq(path, cb)","\t75: function ReaddirReq(path, cb) {","\t76:   this.path = path","\t84:   originalReaddir.call(fs, this.path, this.done)","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5716,"column":0},"end":{"row":5732,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/node_modules/graceful-fs/polyfills.js:","\t23:   fs.lchmod = function (path, mode, callback) {","\t25:     fs.open( path","\t43:   fs.lchmodSync = function (path, mode) {","\t44:     var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)","\t68:     fs.lutimes = function (path, at, mt, cb) {","\t69:       fs.open(path, constants.O_SYMLINK, function (er, fd) {","\t80:     fs.lutimesSync = function (path, at, mt) {","\t81:       var fd = fs.openSync(path, constants.O_SYMLINK)","\t102:     fs.lutimes = function (path, at, mt, cb) {","\t103:       fs.utimensat(path, at, mt, constants.AT_SYMLINK_NOFOLLOW, cb)","\t106:     fs.lutimesSync = function (path, at, mt) {","\t107:       return fs.utimensatSync(path, at, mt, constants.AT_SYMLINK_NOFOLLOW)","\t163:   fs.lchmod = function (path, mode, cb) {","\t169:   fs.lchown = function (path, uid, gid, cb) {","",""]},{"start":{"row":5732,"column":0},"end":{"row":5735,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/node_modules/graceful-fs/test/readdir-sort.js:","\t5: fs.readdir = function(path, cb) {","",""]},{"start":{"row":5735,"column":0},"end":{"row":5745,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/node_modules/minimatch/minimatch.js:","\t12:       case \"path\": return { basename: function (f) {","\t40: var path = require(\"path\")","\t200:   // step 3: now we have a set, so turn each one into a series of path-portion","\t464: // when it is the *only* thing in a path portion.  Otherwise, any series","\t532:         // Should already be path-split by now.","\t742:   // it doesn't match against an empty path part.","\t844:   // treat the test path as a set of pathparts.","\t856:   var splitFile = path.basename(f.join(\"/\")).split(\"/\")","",""]},{"start":{"row":5745,"column":0},"end":{"row":5746,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/node_modules/minimatch/README.md:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5746,"column":0},"end":{"row":5754,"column":0},"action":"insert","lines":["\t56:   corresponds to a single path-part.  For example, the pattern","\t69:   to use the pattern somewhat like `fnmatch(3)` with `FNM_PATH` enabled.","\t94: ### minimatch(path, pattern, options)","\t96: Main export.  Tests a path against the pattern using the options.","\t166: against the basename of the path if it contains slashes.  For example,","\t167: `a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`.","\t204: thing in a path part.  That is, `a/**/b` will match `a/x/y/b`, but","",""]},{"start":{"row":5754,"column":0},"end":{"row":5764,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/test/00-setup.js:","\t5: var path = require(\"path\")","\t21: var symlinkTo = path.resolve(__dirname, \"a/symlink/a/b/c\")","\t25:   return path.resolve(__dirname, f)","\t29:   rimraf(path.resolve(__dirname, \"a\"), function (er) {","\t37:     var d = path.dirname(f)","\t53:     var d = path.dirname(symlinkTo)","\t115:     var cp = spawn(\"bash\", [\"-c\", cmd], { cwd: path.dirname(__dirname) })","\t136:   var fname = path.resolve(__dirname, \"bash-results.json\")","",""]},{"start":{"row":5764,"column":0},"end":{"row":5768,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/test/bash-comparison.js:","\t8: , path = require(\"path\")","\t12: process.chdir(path.resolve(__dirname, \"..\"))","",""]},{"start":{"row":5768,"column":0},"end":{"row":5774,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/test/cwd-test.js:","\t8:   var path = require('path')","\t18:     glob('**/d', {cwd:path.resolve('a')}, function (er, matches) {","\t26:     glob('**/d', {cwd:path.resolve('a/b')}, function (er, matches) {","\t34:     glob('**/d', {cwd:path.resolve('a/b/')}, function (er, matches) {","",""]},{"start":{"row":5774,"column":0},"end":{"row":5790,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/test/nocase-nomagic.js:","\t11:   function fakeStat(path) {","\t13:     switch (path.toLowerCase()) {","\t24:   fs.stat = function(path, cb) {","\t25:     var f = fakeStat(path);","\t31:       stat.call(fs, path, cb)","\t35:   fs.statSync = function(path) {","\t36:     return fakeStat(path) || statSync.call(fs, path)","\t39:   function fakeReaddir(path) {","\t41:     switch (path.toLowerCase()) {","\t51:   fs.readdir = function(path, cb) {","\t52:     var f = fakeReaddir(path)","\t58:       readdir.call(fs, path, cb)","\t61:   fs.readdirSync = function(path) {","\t62:     return fakeReaddir(path) || readdirSync.call(fs, path)","",""]},{"start":{"row":5790,"column":0},"end":{"row":5794,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/test/pause-resume.js:","\t10: , path = require(\"path\")","\t14: process.chdir(path.resolve(__dirname, \"..\"))","",""]},{"start":{"row":5794,"column":0},"end":{"row":5795,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/test/root-nomount.js:",""]},{"start":{"row":5795,"column":0},"end":{"row":5807,"column":0},"action":"insert","lines":["\t8:   var path = require('path')","\t18:     glob('/b*/**', { globDebug: true, root: path.resolve('a'), nomount: true }, function (er, matches) {","\t26:     glob('/b*/**', { globDebug: true, root: 'a', cwd: path.resolve('a/b'), nomount: true }, function (er, matches) {","","/node_modules/mocha/node_modules/glob/test/root.js:","\t7: var path = require('path')","\t19:   console.error(\"root=\" + path.resolve('a'))","\t20:   glob('/b*/**', { globDebug: true, root: path.resolve('a') }, function (er, matches) {","\t25:         return path.join(path.resolve('a'), m).replace(/\\\\/g, '/')","\t34:   glob('/b*/**', { globDebug: true, root: 'a', cwd: path.resolve('a/b') }, function (er, matches) {","\t37:       return path.join(path.resolve('a'), m).replace(/\\\\/g, '/')","",""]},{"start":{"row":5807,"column":0},"end":{"row":5811,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/test/stat.js:","\t3: var path = require('path')","\t23:       return path.relative(__dirname, f)","",""]},{"start":{"row":5811,"column":0},"end":{"row":5815,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/glob/test/zz-cleanup.js:","\t4: , path = require(\"path\")","\t7:   rimraf(path.resolve(__dirname, \"a\"), function (er) {","",""]},{"start":{"row":5815,"column":0},"end":{"row":5823,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/growl/Readme.md:","\t33:   Download [growlnotify](http://www.growlforwindows.com/gfw/help/growlnotify.aspx) - **IMPORTANT :** Unpack growlnotify to a folder that is present in your path!","\t50:     growl('Show icon', { image: 'path/to/icon.icns' })","\t51:     growl('Show image', { image: 'path/to/my.image.png' })","\t70:       - path to an icon sets --iconpath","\t71:       - path to an image sets --image","","/node_modules/mocha/node_modules/growl/test.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5823,"column":0},"end":{"row":5837,"column":0},"action":"insert","lines":["\t10: growl('Show icon', { image: 'path/to/icon.icns' })","\t11: growl('Show image', { image: 'path/to/my.image.png' })","","/node_modules/mocha/node_modules/growl/lib/growl.js:","\t9:   , path = require('path')","\t10:   , exists = fs.existsSync || path.existsSync","\t16:   var paths = process.env.PATH.split(':');","\t19:   for (var i = 0, len = paths.length; i < len; ++i) {","\t20:     loc = path.join(paths[i], name);","\t124:  *    - path to an icon sets --iconpath","\t125:  *    - path to an image sets --image","\t158:         var flag, ext = path.extname(image).substr(1)","\t159:         flag = flag || ext == 'icns' && 'iconpath'","",""]},{"start":{"row":5837,"column":0},"end":{"row":5885,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/jade.js:","\t6:     var path = require.resolve(p)","\t7:       , mod = require.modules[path];","\t11:       mod.call(mod.exports, mod, mod.exports, require.relative(path));","\t18: require.resolve = function (path){","\t19:     var orig = path","\t20:       , reg = path + '.js'","\t21:       , index = path + '/index.js';","\t27: require.register = function (path, fn){","\t28:     require.modules[path] = fn;","\t35:       var path = parent.split('/')","\t37:       path.pop();","\t41:         if ('..' == seg) path.pop();","\t42:         else if ('.' != seg) path.push(seg);","\t45:       return require(path.join('/'));","\t1035:     var path = options.filename;","\t1037:       ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))","\t1046:  * Render a Jade file at the given `path` and callback `fn(err, str)`.","\t1048:  * @param {String} path","\t1054: exports.renderFile = function(path, options, fn){","\t1055:   var key = path + ':string';","\t1062:     options.filename = path;","\t1064:       ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))","\t1065:       : fs.readFileSync(path, 'utf8');","\t3015:     var path = require('path')","\t3017:       , dirname = path.dirname","\t3018:       , basename = path.basename","\t3019:       , join = path.join;","\t3024:     var path = this.expect('extends').val.trim()","\t3027:     var path = join(dir, path + '.jade')","\t3028:       , str = fs.readFileSync(path, 'utf8')","\t3029:       , parser = new Parser(str, path, this.options);","\t3076:     var path = require('path')","\t3078:       , dirname = path.dirname","\t3079:       , basename = path.basename","\t3080:       , join = path.join;","\t3082:     var path = this.expect('include').val.trim()","\t3089:     if (!~basename(path).indexOf('.')) {","\t3090:       path += '.jade';","\t3094:     if ('.jade' != path.substr(-5)) {","\t3095:       var path = join(dir, path)","\t3096:         , str = fs.readFileSync(path, 'utf8');","\t3100:     var path = join(dir, path)","\t3101:       , str = fs.readFileSync(path, 'utf8')","\t3102:      , parser = new Parser(str, path, this.options);","\t3109:     ast.filename = path;","\t3503:   err.path = filename;","",""]},{"start":{"row":5885,"column":0},"end":{"row":5888,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/jade.md:","\t9:          [-O|--out DIR] [-p|--path PATH] [-P|--pretty]","",""]},{"start":{"row":5888,"column":0},"end":{"row":5891,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/runtime.js:","\t171:   err.path = filename;","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5891,"column":0},"end":{"row":5914,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/bin/jade:","\t9:   , path = require('path')","\t10:   , basename = path.basename","\t11:   , dirname = path.dirname","\t12:   , resolve = path.resolve","\t13:   , join = path.join","\t28:   .option('-p, --path <path>', 'filename used to resolve includes')","\t61: if (program.path) options.filename = program.path;","\t75: // left-over args are file paths","\t108:  * Process the given path, compiling the jade files found.","\t112: function renderFile(path) {","\t114:   fs.lstat(path, function(err, stat) {","\t117:     if (stat.isFile() && re.test(path)) {","\t118:       fs.readFile(path, 'utf8', function(err, str){","\t120:         options.filename = path;","\t123:         path = path.replace(re, extname);","\t124:         if (program.out) path = join(program.out, basename(path));","\t125:         var dir = resolve(dirname(path));","\t131:           fs.writeFile(path, output, function(err){","\t133:             console.log('  \\033[90mrendered \\033[36m%s\\033[0m', path);","\t139:       fs.readdir(path, function(err, files) {","\t142:           return path + '/' + filename;","",""]},{"start":{"row":5914,"column":0},"end":{"row":5925,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/lib/jade.js:","\t196:     var path = options.filename;","\t198:       ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))","\t207:  * Render a Jade file at the given `path` and callback `fn(err, str)`.","\t209:  * @param {String} path","\t215: exports.renderFile = function(path, options, fn){","\t216:   var key = path + ':string';","\t223:     options.filename = path;","\t225:       ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, 'utf8'))","\t226:       : fs.readFileSync(path, 'utf8');","",""]},{"start":{"row":5925,"column":0},"end":{"row":5926,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/lib/parser.js:",""]},{"start":{"row":5926,"column":0},"end":{"row":5952,"column":0},"action":"insert","lines":["\t396:     var path = require('path')","\t398:       , dirname = path.dirname","\t399:       , basename = path.basename","\t400:       , join = path.join;","\t405:     var path = this.expect('extends').val.trim()","\t408:     var path = join(dir, path + '.jade')","\t409:       , str = fs.readFileSync(path, 'utf8')","\t410:       , parser = new Parser(str, path, this.options);","\t457:     var path = require('path')","\t459:       , dirname = path.dirname","\t460:       , basename = path.basename","\t461:       , join = path.join;","\t463:     var path = this.expect('include').val.trim()","\t470:     if (!~basename(path).indexOf('.')) {","\t471:       path += '.jade';","\t475:     if ('.jade' != path.substr(-5)) {","\t476:       var path = join(dir, path)","\t477:         , str = fs.readFileSync(path, 'utf8');","\t481:     var path = join(dir, path)","\t482:       , str = fs.readFileSync(path, 'utf8')","\t483:      , parser = new Parser(str, path, this.options);","\t490:     ast.filename = path;","","/node_modules/mocha/node_modules/jade/lib/runtime.js:","\t170:   err.path = filename;","",""]},{"start":{"row":5952,"column":0},"end":{"row":5959,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/node_modules/commander/lib/commander.js:","\t13:   , path = require('path')","\t15:   , basename = path.basename;","\t116:  *        .option('-C, --chdir <path>', 'change the working directory')","\t117:  *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')","\t269:  *     program.option('-C, --chdir <path>', 'change the working directory');","",""]},{"start":{"row":5959,"column":0},"end":{"row":5966,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/node_modules/mkdirp/index.js:","\t1: var path = require('path');","\t14:     p = path.resolve(p);","\t20:                 mkdirP(path.dirname(p), mode, function (er) {","\t48:     p = path.resolve(p);","\t56:                 var err1 = sync(path.dirname(p), mode)","",""]},{"start":{"row":5966,"column":0},"end":{"row":5969,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/chmod.js:","\t2: var path = require('path');","",""]},{"start":{"row":5969,"column":0},"end":{"row":5976,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/clobber.js:","\t2: var path = require('path');","","/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/mkdirp.js:","\t2: var path = require('path');","\t16:         else path.exists(file, function (ex) {","",""]},{"start":{"row":5976,"column":0},"end":{"row":5985,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/perm.js:","\t2: var path = require('path');","\t12:         else path.exists(file, function (ex) {","","/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/perm_sync.js:","\t2: var path = require('path');","\t11:     path.exists(file, function (ex) {","\t29:     path.exists(file, function (ex) {","",""]},{"start":{"row":5985,"column":0},"end":{"row":5989,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/race.js:","\t2: var path = require('path');","\t28:             else path.exists(file, function (ex) {","",""]},{"start":{"row":5989,"column":0},"end":{"row":5993,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/rel.js:","\t2: var path = require('path');","\t19:         else path.exists(file, function (ex) {","",""]},{"start":{"row":5993,"column":0},"end":{"row":5997,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/sync.js:","\t2: var path = require('path');","\t16:     else path.exists(file, function (ex) {","",""]},{"start":{"row":5997,"column":0},"end":{"row":5998,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/umask.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":5998,"column":0},"end":{"row":6001,"column":0},"action":"insert","lines":["\t2: var path = require('path');","\t16:         else path.exists(file, function (ex) {","",""]},{"start":{"row":6001,"column":0},"end":{"row":6005,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/jade/node_modules/mkdirp/test/umask_sync.js:","\t2: var path = require('path');","\t16:     else path.exists(file, function (ex) {","",""]},{"start":{"row":6005,"column":0},"end":{"row":6012,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/mkdirp/index.js:","\t1: var path = require('path');","\t24:     p = path.resolve(p);","\t33:                 mkdirP(path.dirname(p), opts, function (er, made) {","\t67:     p = path.resolve(p);","\t76:                 made = sync(path.dirname(p), opts, made);","",""]},{"start":{"row":6012,"column":0},"end":{"row":6018,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/mkdirp/readme.markdown:","\t46: `opts.fs`. Your implementation should have `opts.fs.mkdir(path, mode, cb)` and","\t47: `opts.fs.stat(path, cb)`.","\t60: `opts.fs`. Your implementation should have `opts.fs.mkdirSync(path, mode)` and","\t61: `opts.fs.statSync(path)`.","",""]},{"start":{"row":6018,"column":0},"end":{"row":6023,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/mkdirp/bin/cmd.js:","\t16: var paths = argv._.slice();","\t20:     if (paths.length === 0) return;","\t21:     var p = paths.shift();","",""]},{"start":{"row":6023,"column":0},"end":{"row":6026,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/mkdirp/test/chmod.js:","\t2: var path = require('path');","",""]},{"start":{"row":6026,"column":0},"end":{"row":6033,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/mkdirp/test/clobber.js:","\t2: var path = require('path');","","/node_modules/mocha/node_modules/mkdirp/test/mkdirp.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":6033,"column":0},"end":{"row":6043,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/mkdirp/test/opts_fs.js:","\t2: var path = require('path');","","/node_modules/mocha/node_modules/mkdirp/test/opts_fs_sync.js:","\t2: var path = require('path');","","/node_modules/mocha/node_modules/mkdirp/test/perm.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":6043,"column":0},"end":{"row":6047,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/mkdirp/test/perm_sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":6047,"column":0},"end":{"row":6051,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/mkdirp/test/race.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]}]}],[{"group":"doc","deltas":[{"start":{"row":6051,"column":0},"end":{"row":6055,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/mkdirp/test/rel.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":6055,"column":0},"end":{"row":6058,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/mkdirp/test/return.js:","\t2: var path = require('path');","",""]},{"start":{"row":6058,"column":0},"end":{"row":6065,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/mkdirp/test/return_sync.js:","\t2: var path = require('path');","","/node_modules/mocha/node_modules/mkdirp/test/root.js:","\t2: var path = require('path');","\t8:     var file = path.resolve('/');","",""]},{"start":{"row":6065,"column":0},"end":{"row":6070,"column":0},"action":"insert","lines":["/node_modules/mocha/node_modules/mkdirp/test/sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","","/node_modules/mocha/node_modules/mkdirp/test/umask.js:",""]},{"start":{"row":6070,"column":0},"end":{"row":6077,"column":0},"action":"insert","lines":["\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","","/node_modules/mocha/node_modules/mkdirp/test/umask_sync.js:","\t2: var path = require('path');","\t4: var exists = fs.exists || path.exists;","",""]},{"start":{"row":6077,"column":0},"end":{"row":6080,"column":0},"action":"insert","lines":["/node_modules/morgan/node_modules/debug/History.md:","\t48:   * Makefile: find node path using shell/which (#109, @timoxley)","",""]},{"start":{"row":6080,"column":0},"end":{"row":6084,"column":0},"action":"insert","lines":["/node_modules/morgan/node_modules/debug/Makefile:","\t3: THIS_MAKEFILE_PATH:=$(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))","\t4: THIS_DIR:=$(shell cd $(dir $(THIS_MAKEFILE_PATH));pwd)","",""]},{"start":{"row":6084,"column":0},"end":{"row":6090,"column":0},"action":"insert","lines":["/node_modules/morgan/node_modules/depd/index.js:","\t13: var relative = require('path').relative","\t22:  * Get the path to base files on.","\t25: var basePath = process.cwd()","\t357:   return relative(basePath, callSite[0])","",""]},{"start":{"row":6090,"column":0},"end":{"row":6103,"column":0},"action":"insert","lines":["/node_modules/path/package.json:","\t6:   \"name\": \"path\",","\t7:   \"description\": \"Node.JS path module\",","\t10:     \"path\"","\t14:   \"homepage\": \"http://nodejs.org/docs/latest/api/path.html\",","\t17:     \"url\": \"git://github.com/jinder/path.git\"","\t19:   \"main\": \"./path.js\",","\t22:     \"url\": \"https://github.com/jinder/path/issues\"","\t24:   \"_id\": \"path@0.11.14\",","\t27:   \"_from\": \"path@*\",","\t49:     \"tarball\": \"http://registry.npmjs.org/path/-/path-0.11.14.tgz\"","\t52:   \"_resolved\": \"https://registry.npmjs.org/path/-/path-0.11.14.tgz\"","",""]},{"start":{"row":6103,"column":0},"end":{"row":6104,"column":0},"action":"insert","lines":["/node_modules/path/path.js:",""]}]}],[{"group":"doc","deltas":[{"start":{"row":6104,"column":0},"end":{"row":6219,"column":0},"action":"insert","lines":["\t31: // resolves . and .. elements in a path array with directory names there","\t34: // relative and absolute paths)","\t36:   // if the path tries to go above the root, `up` ends up > 0","\t51:   // if the path is allowed to go above the root, restore leading ..s","\t63:   // Regex to split a windows path into three parts: [*, device, slash,","\t74:   var splitPath = function(filename) {","\t91:   // path.resolve([from ...], to)","\t99:       var path;","\t101:         path = arguments[i];","\t103:         path = process.cwd();","\t107:         // absolute path, get cwd for that drive. We're sure the device is not","\t108:         // an unc path at this points, because unc paths are always absolute.","\t109:         path = process.env['=' + resolvedDevice];","\t112:         if (!path || path.substr(0, 3).toLowerCase() !==","\t114:           path = resolvedDevice + '\\\\';","\t119:       if (!util.isString(path)) {","\t120:         throw new TypeError('Arguments to path.resolve must be strings');","\t121:       } else if (!path) {","\t125:       var result = splitDeviceRe.exec(path),","\t128:           isAbsolute = exports.isAbsolute(path),","\t134:         // This path points to another device so it is not applicable","\t157:     // At this point the path should be resolved to a full absolute path,","\t158:     // but handle relative paths to be safe (might happen when process.cwd()","\t161:     // Normalize the tail path","\t175:   exports.normalize = function(path) {","\t176:     var result = splitDeviceRe.exec(path),","\t179:         isAbsolute = exports.isAbsolute(path),","\t188:     // Normalize the tail path","\t210:   exports.isAbsolute = function(path) {","\t211:     var result = splitDeviceRe.exec(path),","\t214:     // UNC paths are always absolute","\t222:         throw new TypeError('Arguments to path.join must be strings');","\t227:     var paths = Array.prototype.filter.call(arguments, f);","\t228:     var joined = paths.join('\\\\');","\t230:     // Make sure that the joined path doesn't start with two slashes, because","\t231:     // normalize() will mistake it for an UNC path then.","\t234:     // intended to point at an UNC path. This is assumed when the first","\t238:     // Note that for normalize() to treat a path as an UNC path it needs to","\t240:     // This means that the user can use join to construct UNC paths from","\t242:     //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')","\t243:     if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {","\t250:   // path.relative(from, to)","\t251:   // it will solve the relative path from 'from' to 'to', for instance:","\t314:   var splitPathRe =","\t316:   var splitPath = function(filename) {","\t317:     return splitPathRe.exec(filename).slice(1);","\t320:   // path.resolve([from ...], to)","\t323:     var resolvedPath = '',","\t327:       var path = (i >= 0) ? arguments[i] : process.cwd();","\t330:       if (!util.isString(path)) {","\t331:         throw new TypeError('Arguments to path.resolve must be strings');","\t332:       } else if (!path) {","\t336:       resolvedPath = path + '/' + resolvedPath;","\t337:       resolvedAbsolute = path.charAt(0) === '/';","\t340:     // At this point the path should be resolved to a full absolute path, but","\t341:     // handle relative paths to be safe (might happen when process.cwd() fails)","\t343:     // Normalize the path","\t344:     resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {","\t348:     return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';","\t351:   // path.normalize(path)","\t353:   exports.normalize = function(path) {","\t354:     var isAbsolute = exports.isAbsolute(path),","\t355:         trailingSlash = path[path.length - 1] === '/',","\t356:         segments = path.split('/'),","\t359:     // Normalize the path","\t365:     path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');","\t367:     if (!path && !isAbsolute) {","\t368:       path = '.';","\t370:     if (path && trailingSlash) {","\t371:       path += '/';","\t374:     return (isAbsolute ? '/' : '') + path;","\t378:   exports.isAbsolute = function(path) {","\t379:     return path.charAt(0) === '/';","\t384:     var path = '';","\t388:         throw new TypeError('Arguments to path.join must be strings');","\t391:         if (!path) {","\t392:           path += segment;","\t394:           path += '/' + segment;","\t398:     return exports.normalize(path);","\t402:   // path.relative(from, to)","\t449: exports.dirname = function(path) {","\t450:   var result = splitPath(path),","\t468: exports.basename = function(path, ext) {","\t469:   var f = splitPath(path)[2];","\t478: exports.extname = function(path) {","\t479:   return splitPath(path)[3];","\t483: exports.exists = util.deprecate(function(path, callback) {","\t484:   require('fs').exists(path, callback);","\t485: }, 'path.exists is now called `fs.exists`.');","\t488: exports.existsSync = util.deprecate(function(path) {","\t489:   return require('fs').existsSync(path);","\t490: }, 'path.existsSync is now called `fs.existsSync`.');","\t494:   exports._makeLong = function(path) {","\t496:     if (!util.isString(path))","\t497:       return path;","\t499:     if (!path) {","\t503:     var resolvedPath = exports.resolve(path);","\t505:     if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {","\t506:       // path is local filesystem path, which needs to be converted","\t507:       // to long UNC path.","\t508:       return '\\\\\\\\?\\\\' + resolvedPath;","\t509:     } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {","\t510:       // path is network UNC path, which needs to be converted","\t511:       // to long UNC path.","\t512:       return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);","\t515:     return path;","\t518:   exports._makeLong = function(path) {","\t519:     return path;","","/node_modules/path/README.md:","\t1: # path","\t3: This is an exact copy of the NodeJS ’path’ module published to the NPM registry. ","\t5: [Documentation](http://nodejs.org/docs/latest/api/path.html)","\t10: $ npm install --save path","",""]},{"start":{"row":6219,"column":0},"end":{"row":6229,"column":0},"action":"insert","lines":["/node_modules/q/README.md:","\t829:     at explode (/path/to/test.js:3:11)","\t830:     at _fulfilled (/path/to/test.js:q:54)","\t831:     at resolvedValue.promiseDispatch.done (/path/to/q.js:823:30)","\t832:     at makePromise.promise.promiseDispatch (/path/to/q.js:496:13)","\t833:     at pending (/path/to/q.js:397:39)","\t847:     at explode (/path/to/test.js:3:11)","\t849:     at theDepthsOfMyProgram (/path/to/test.js:2:16)","\t850:     at Object.<anonymous> (/path/to/test.js:7:1)","",""]},{"start":{"row":6229,"column":0},"end":{"row":6232,"column":0},"action":"insert","lines":["/plugins/acute-user-base/package.json:","\t18:     \"path\": \"*\",","",""]},{"start":{"row":6232,"column":0},"end":{"row":6237,"column":0},"action":"insert","lines":["/plugins/acute-user-base/app/app.js:","\t6:     path = require('path'),","\t7:     configPath = path.join(__dirname, \"config.js\"),","\t17: acute_utils.loadApp(configPath, function(err, arch) {","",""]},{"start":{"row":6237,"column":0},"end":{"row":6242,"column":0},"action":"insert","lines":["/plugins/acute-user-base/app/config.js:","\t6:         packagePath: \"acute-express-app\",","\t25:         packagePath: \"acute-express-data\",","\t55:         packagePath: \"acute-express-controllers\",","",""]},{"start":{"row":6242,"column":0},"end":{"row":6246,"column":0},"action":"insert","lines":["/plugins/acute-user-base/app/index.js:","\t7:     configPath = path.join(__dirname, \"config.js\");","\t20:     acute_utils.loadApp(configPath, function(err, arch) {","",""]},{"start":{"row":6246,"column":0},"end":{"row":6252,"column":0},"action":"insert","lines":["/plugins/acute-user-base/app/swagger.yml:","\t9: # Describe your paths here","\t11:   # This is a path endpoint. Change it.","\t75:           in: path","\t110:           in: path","",""]},{"start":{"row":6252,"column":0},"end":{"row":6255,"column":0},"action":"insert","lines":["/plugins/acute-user-base/app/controllers/index.js:","\t41:            // base_path: \"/test\"","",""]},{"start":{"row":6255,"column":0},"end":{"row":6256,"column":0},"action":"insert","lines":["Found 6653 matches in 490 files ",""]},{"start":{"row":6256,"column":0},"end":{"row":6257,"column":0},"action":"insert","lines":["",""]},{"start":{"row":0,"column":26},"end":{"row":0,"column":60},"action":"insert","lines":[" (Found 6653 matches in 490 files)"]}]}]]},"ace":{"folds":[],"customSyntax":"c9search","scrolltop":0,"scrollleft":6,"selection":{"start":{"row":6257,"column":0},"end":{"row":6257,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0}}